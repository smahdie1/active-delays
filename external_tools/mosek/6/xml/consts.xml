<?xml version="1.0"?>
<!--
  Copyright: $$copyright 
  
  File: consts.xml
  
  Purpose: Lists all constants in Mosek.
  -->


<!--
  This file lists all constants and parameters used in Mosek.


  THE FORMAT OF THIS FILE

  <mosekvalues>
    descr: The document root.
    
  <version>
    elements: <major> <minor> <build> <revision> <state>
    descr: Mosek version corresponding to the content of this file.

  <major>, <minor>, <build>, <revision>
    descr: An Integer representing the version.
    
  <state>
    descr: A string representing the version state 

  <constlist>
    elements: <sec>
    descr: This contains all Mosek constant groups.

  <sec>
    attributes:
      id: The name of the constants group as found in "mosek.h"
      type: String indicating the meaning of the constants. It is
        either "enum" (indicating that the group appears as an enum in
        "mosek.h"), "constants" (meaning a logical grouping of
        constants sharing the same prefix) or "parameter" (represents
        a type of parameters).
    elements: <c> <p>
    descr: Represents a group of constants.

  <c>
    attributes:
      name: The name of the constant
      val: The value of the constant
    elements: <cmnt>
    descr: Represents a single constant value.

  <p>
    attributes:
      name: The name of the parameter
      val: The value of the constant representing the parameter (not the value of the parameter)
    elements: <cmnt> <default> <lower_bound> <upper_bound> <values_from>
    descr: Represents a single parameter.

  <cmnt>
    descr: Text (LaTeX) description of the item.

  <default>
    descr: The default value of a parameter

  <lower_bound>
    descr: The lower bound on values for a parameter

  <upper_bound>
    descr: The upper bound on values for a parameter

  <values_from>
    descr: The parameter takes its values from the constant group of this name.
  -->


<mosekvalues>
<version>
 <major>6</major>
 <minor>0</minor>
 <build>0</build>
 <revision>137</revision>
 <state></state>
</version>

<constlist>
 <sec id="MSKsolveforme" type="constants">
  <c name="MSK_SOLVE_PRIMAL" val="1">
   <cmnt>The optimizer should solve the primal problem.</cmnt>
  </c>
  <c name="MSK_SOLVE_DUAL" val="2">
   <cmnt>The optimizer should solve the dual problem.</cmnt>
  </c>
  <c name="MSK_SOLVE_FREE" val="0">
   <cmnt>The optimizer is free to solve either the primal or
                    the dual problem.</cmnt>
  </c>
 </sec>
 <sec id="MSKaccmodee" type="enum">
  <c name="MSK_ACC_VAR" val="0">
   <cmnt>Access data by columns (variable orinted)</cmnt>
  </c>
  <c name="MSK_ACC_CON" val="1">
   <cmnt>Access data by rows (constraint oriented)</cmnt>
  </c>
 </sec>
 <sec id="MSKsensitivitytypee" type="constants">
  <c name="MSK_SENSITIVITY_TYPE_OPTIMAL_PARTITION" val="1">
   <cmnt>Optimal partition sensitivity analysis is performed.</cmnt>
  </c>
  <c name="MSK_SENSITIVITY_TYPE_BASIS" val="0">
   <cmnt>Basis sensitivity analysis is performed.</cmnt>
  </c>
 </sec>
 <sec id="MSKqreadtypee" type="constants">
  <c name="MSK_Q_READ_ADD" val="0">
   <cmnt>All elements in a Q matrix are assumed to belong to the lower
                    triangular part. Duplicate elements in a Q matrix are added together.</cmnt>
  </c>
  <c name="MSK_Q_READ_DROP_LOWER" val="1">
   <cmnt>All elements in the strict lower triangular part
                    of the Q matrices are dropped.</cmnt>
  </c>
  <c name="MSK_Q_READ_DROP_UPPER" val="2">
   <cmnt>All elements in the strict upper triangular part
                    of the Q matrices are dropped.</cmnt>
  </c>
 </sec>
 <sec id="MSKiparame" type="parameters">
  <p name="MSK_IPAR_SIM_STABILITY_PRIORITY" val="175">
   <cmnt>Controls how high priority the numerical stability should be given.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>100</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_READ_ADD_CONE" val="125">
   <cmnt>Additional number of conic constraints that is made room for in the problem.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD" val="166">
   <cmnt>An exprimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>10</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_WRITE_MPS_STRICT" val="204">
   <cmnt>Controls whether the written MPS file satisfies the MPS format strictly
                    or not.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_INFEAS_REPORT_AUTO" val="25">
   <cmnt>Controls whether an infeasibility report is automatically
                    produced after the optimization if the problem is primal or dual
                    infeasible.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_NODE_OPTIMIZER" val="93">
   <cmnt>Controls which optimizer is employed at the non-root nodes in the mixed-integer optimizer.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_QCONE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LEVEL" val="118">
   <cmnt>Currently not used.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_READ_ADD_VAR" val="127">
   <cmnt>Additional number of variables that is
                    made room for in the problem.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_USE" val="121">
   <cmnt>Controls whether the presolve is applied to a problem before it is optimized.</cmnt>
   <values_from group="MSKpresolvemodee">
    <ref name="MSK_PRESOLVE_MODE_ON"/>
    <ref name="MSK_PRESOLVE_MODE_OFF"/>
    <ref name="MSK_PRESOLVE_MODE_FREE"/>
   </values_from>
   <default>MSK_PRESOLVE_MODE_FREE</default>
  </p>
  <p name="MSK_IPAR_LOG_SENSITIVITY_OPT" val="70">
   <cmnt>Controls the amount of logging from the optimizers employed during the sensitivity analysis.
                    0 means no logging information is produced.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOL_ITG" val="109">
   <cmnt>If \MSKitemtex{mosek:iparam:opf_write_solutions} is
                \MSKitemtex{mosek:onoffkey:on} and an integer solution is defined,
                write the integer solution in OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_BAS_HEAD" val="186">
   <cmnt>Controls whether the header section is written to the
                    basic solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_BRANCH_PRIORITIES_USE" val="79">
   <cmnt>Controls whether branching priorities are used by the mixed-integer optimizer.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_on</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_LEVEL_TREE" val="83">
   <cmnt>Controls the cut level employed by the mixed-integer optimizer at the tree. See \MSKitemtex{mosek:iparam:mio_cut_level_root}
                    for an explanation of the parameter values.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_WRITE_DATA_COMPRESSED" val="188">
   <cmnt>Controls whether the data file is compressed while it is written.
                    $0$ means no compression while higher values mean more compression.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_RELAX" val="140">
   <cmnt>If this option is turned on, then mixed integer constraints are ignored when a problem is read.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_PARAMETERS" val="106">
   <cmnt>Write a parameter section in an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_READ_CON" val="129">
   <cmnt>Expected maximum number of constraints to be read. The option is
                    only used by fast MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10000</default>
  </p>
  <p name="MSK_IPAR_WRITE_INT_VARIABLES" val="196">
   <cmnt>Controls whether the variables section is written to the
                    integer solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_READ_ADD_ANZ" val="123">
   <cmnt>Additional number of non-zeros in $A$ that is
                    made room for in the problem.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_INTPNT_ORDER_METHOD" val="36">
   <cmnt>Controls the ordering strategy used by the interior-point
                    optimizer when factorizing the Newton
                    equation system.</cmnt>
   <values_from group="MSKorderingtypee">
    <ref name="MSK_ORDER_METHOD_NONE"/>
    <ref name="MSK_ORDER_METHOD_APPMINLOC2"/>
    <ref name="MSK_ORDER_METHOD_APPMINLOC1"/>
    <ref name="MSK_ORDER_METHOD_GRAPHPAR2"/>
    <ref name="MSK_ORDER_METHOD_FREE"/>
    <ref name="MSK_ORDER_METHOD_GRAPHPAR1"/>
   </values_from>
   <default>MSK_ORDER_METHOD_FREE</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOL_ITR" val="110">
   <cmnt>If \MSKitemtex{mosek:iparam:opf_write_solutions} is
                \MSKitemtex{mosek:onoffkey:on} and an interior solution is defined,
                write the interior solution in OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_SENSITIVITY" val="69">
   <cmnt>Controls the amount of logging during the sensitivity analysis. 0: Means
                    no logging information is produced. 1: Timing information is
                    printed. 2: Sensitivity results are printed.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_READ_QNZ" val="143">
   <cmnt>Expected maximum number of $Q$ non-zeros to be read. The option is
                     used only by MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>20000</default>
  </p>
  <p name="MSK_IPAR_LOG_INFEAS_ANA" val="59">
   <cmnt>Controls amount of output printed by the infeasibility analyzer procedures. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_SELECTION" val="168">
   <cmnt>Controls the choice of the incoming variable,
                    known as the selection strategy, in the primal
                    simplex optimizer.</cmnt>
   <values_from group="MSKsimseltypee">
    <ref name="MSK_SIM_SELECTION_FULL"/>
    <ref name="MSK_SIM_SELECTION_PARTIAL"/>
    <ref name="MSK_SIM_SELECTION_FREE"/>
    <ref name="MSK_SIM_SELECTION_ASE"/>
    <ref name="MSK_SIM_SELECTION_DEVEX"/>
    <ref name="MSK_SIM_SELECTION_SE"/>
   </values_from>
   <default>MSK_SIM_SELECTION_FREE</default>
  </p>
  <p name="MSK_IPAR_WRITE_INT_CONSTRAINTS" val="194">
   <cmnt>Controls whether the constraint section is written to the
                    integer solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_STRICT_FORMAT" val="199">
   <cmnt>Controls whether LP  output files satisfy the LP format strictly.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SENSITIVITY_TYPE" val="148">
   <cmnt>Controls which type of sensitivity analysis is to be performed.</cmnt>
   <values_from group="MSKsensitivitytypee">
    <ref name="MSK_SENSITIVITY_TYPE_OPTIMAL_PARTITION"/>
    <ref name="MSK_SENSITIVITY_TYPE_BASIS"/>
   </values_from>
   <default>MSK_SENSITIVITY_TYPE_BASIS</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION" val="153">
   <cmnt>The dual simplex optimizer can use a so-called restricted selection/pricing strategy to
                   chooses the outgoing variable. Hence, if restricted selection is applied, then the dual simplex optimizer first
                   choose a subset of all the potential outgoing variables. Next, for some time it will choose the outgoing
                   variable only among the subset. From time to time the subset is redefined.

                   A larger value of this parameter implies that the optimizer will be more aggressive in its
                   restriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>100</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_LOG_MIO_FREQ" val="62">
   <cmnt>Controls how frequent the mixed-integer optimizer prints the log line. It
                    will print line every time \MSKitemtex{mosek:iparam:log_mio_freq} relaxations have been solved.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOL_BAS" val="108">
   <cmnt>If \MSKitemtex{mosek:iparam:opf_write_solutions} is
                \MSKitemtex{mosek:onoffkey:on} and a basic solution is defined,
                include the basic solution in OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_CHECK_TASK_DATA" val="14">
   <cmnt>If this feature is turned on, then the task data is checked for bad values i.e. NaNs.
                before an optimization is performed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_ROOT_OPTIMIZER" val="99">
   <cmnt>Controls which optimizer is employed at the root node in the mixed-integer optimizer.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_QCONE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_WRITE_FREE_CON" val="191">
   <cmnt>Controls whether the free
                    constraints are written to the
                    data file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_ELIM_FILL" val="115">
   <cmnt>Controls the maximum amount of fill-in that
                    can be created during the elimination phase
                    of the presolve. This parameter times
                    (\comp{numcon}+\comp{numvar}) denotes the amount of fill-in.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_NONCONVEX_MAX_ITERATIONS" val="101">
   <cmnt>Maximum number of iterations that can be used by the nonconvex optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100000</default>
  </p>
  <p name="MSK_IPAR_MIO_LOCAL_BRANCH_NUMBER" val="88">
   <cmnt>Controls the size of the local search space when doing local branching.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_WRITE_GENERIC_NAMES" val="192">
   <cmnt>Controls whether the generic names or user-defined
                    names are used in the data file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WARNING_LEVEL" val="184">
   <cmnt>Warning level.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_BI_FREQ" val="51">
   <cmnt>Controls how frequent the optimizer
                    outputs information about the basis identification
                    and how frequent the user-defined call-back function
                    is called.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>2500</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_PRIORITY_DUAL_SIMPLEX" val="16">
   <cmnt>Priority of the dual simplex algorithm when selecting solvers for
                    concurrent optimization.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>2</default>
  </p>
  <p name="MSK_IPAR_LOG_PRESOLVE" val="67">
   <cmnt>Controls amount of output printed
                    by the presolve procedure. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_READ_ADD_QNZ" val="126">
   <cmnt>Additional number of non-zeros in the $Q$ matrices
                    that is made room for in the problem.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_CONSTRAINTS" val="206">
   <cmnt>Controls whether the constraint section is written to the
                    solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_OFF_COL_TRH" val="35">
   <cmnt>Controls how many offending columns are detected in
                  the Jacobian of the constraint matrix. 
                  
                  1 means aggressive detection, higher values mean less
                  aggressive detection. 

                  0 means no detection.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>40</default>
  </p>
  <p name="MSK_IPAR_READ_ANZ" val="128">
   <cmnt>Expected maximum number of $A$ non-zeros to be read. The option is
                     used only by fast MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100000</default>
  </p>
  <p name="MSK_IPAR_MIO_MODE" val="92">
   <cmnt>Controls whether the optimizer includes
                    the integer restrictions when solving a
                    (mixed) integer optimization problem.</cmnt>
   <values_from group="MSKmiomodee">
    <ref name="MSK_MIO_MODE_IGNORED"/>
    <ref name="MSK_MIO_MODE_LAZY"/>
    <ref name="MSK_MIO_MODE_SATISFIED"/>
   </values_from>
   <default>MSK_MIO_MODE_SATISFIED</default>
  </p>
  <p name="MSK_IPAR_READ_LP_DROP_NEW_VARS_IN_BOU" val="134">
   <cmnt>If this option is turned on, \mosek{} will drop variables that are defined for the
                    first time in the bounds section.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM" val="71">
   <cmnt>Controls amount of output printed by the simplex optimizer. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_LIC_TRH_EXPIRY_WRN" val="41">
   <cmnt>If a license feature expires in a numbers days less than the value of this parameter then a warning will be issued.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>7</default>
  </p>
  <p name="MSK_IPAR_SOLUTION_CALLBACK" val="182">
   <cmnt>Indicates whether solution call-backs will be
                    performed during the optimization.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_SCALING_METHOD" val="173">
   <cmnt>Controls how the problem is scaled
                    before a simplex optimizer is used.</cmnt>
   <values_from group="MSKscalingmethode">
    <ref name="MSK_SCALING_METHOD_POW2"/>
    <ref name="MSK_SCALING_METHOD_FREE"/>
   </values_from>
   <default>MSK_SCALING_METHOD_POW2</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM_FREQ" val="72">
   <cmnt>Controls how frequent the simplex optimizer
                    outputs information about the optimization
                    and how frequent the user-defined call-back function
                    is called.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>500</default>
  </p>
  <p name="MSK_IPAR_LOG_NONCONVEX" val="63">
   <cmnt>Controls amount of output printed by the nonconvex optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_FEASREPAIR_OPTIMIZE" val="22">
   <cmnt>Controls which type of feasibility analysis is to be performed.</cmnt>
   <values_from group="MSKfeasrepairtypee">
    <ref name="MSK_FEASREPAIR_OPTIMIZE_NONE"/>
    <ref name="MSK_FEASREPAIR_OPTIMIZE_COMBINED"/>
    <ref name="MSK_FEASREPAIR_OPTIMIZE_PENALTY"/>
   </values_from>
   <default>MSK_FEASREPAIR_OPTIMIZE_NONE</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_QUOTED_NAMES" val="198">
   <cmnt>If this option is turned on, then \mosek{} will quote invalid LP names when
                  writing an LP file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_FACTOR" val="55">
   <cmnt>If turned on, then the factor log lines are added to the log.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_AUTO_UPDATE_SOL_INFO" val="4">
   <cmnt>Controls whether the solution information items are automatically updated after an optimization is performed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_on</default>
  </p>
  <p name="MSK_IPAR_WRITE_MPS_QUOTED_NAMES" val="203">
   <cmnt>If a name contains spaces (blanks) when writing an MPS file, then the quotes will be removed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_WIDTH" val="141">
   <cmnt>Controls the maximal number of characters allowed in one line of the MPS file.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1024</default>
  </p>
  <p name="MSK_IPAR_TIMING_LEVEL" val="183">
   <cmnt>Controls the a amount of timing performed inside \mosek{}.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_ORDER" val="65">
   <cmnt>If turned on, then factor lines are added to the log.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_LEVEL_ROOT" val="82">
   <cmnt>Controls the cut level employed by the mixed-integer optimizer at the root node.
                    A negative value means a default value determined by the mixed-integer optimizer
                    is used. By adding the appropriate values from the following table the
                    employed cut types can be controlled.
                    
                    %inline the file "../shared/miocutlevel.tex"
                    \begin{tabular}{ll}
                    GUB cover        &amp; +2\\
                    Flow cover       &amp; +4 \\
                    Lifting          &amp; +8 \\
                    Plant location   &amp; +16\\
                    Disaggregation   &amp; +32\\
                    Knapsack cover   &amp; +64\\
                    Lattice          &amp; +128\\
                    Gomory           &amp; +256\\
                    Coefficient reduction &amp; +512\\
                    GCD                   &amp; +1024 \\
                    Obj. integrality      &amp; +2048\\
                    \end{tabular}</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE" val="5">
   <cmnt>If a slack variable is in the basis, then the
                  corresponding column in the basis is a unit vector
                  with -1 in the right position. However, if this
                  parameter is set to \MSKitemtex{mosek:onoffkey:on},
                  -1 is replaced by 1.
                  \begin{MSKexcl}{!mex:cmdln}

This has siginificance for the
                  results returned by the
                  \MSKfunctex{mosek:task:solvewithbasis} function.
                  \end{MSKexcl}</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_BI_IGNORE_NUM_ERROR" val="8">
   <cmnt>If the parameter \MSKitemtex{mosek:iparam:intpnt_basis} has the value \MSKitemtex{mosek:basindtype:no_error}
                   and the interior-point optimizer has terminated due to a numerical problem, then basis identification is performed if this parameter has
                   the value \MSKitemtex{mosek:onoffkey:on}.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_NODE_SELECTION" val="94">
   <cmnt>Controls the node selection strategy employed by the
                    mixed-integer optimizer.</cmnt>
   <values_from group="MSKmionodeseltypee">
    <ref name="MSK_MIO_NODE_SELECTION_PSEUDO"/>
    <ref name="MSK_MIO_NODE_SELECTION_HYBRID"/>
    <ref name="MSK_MIO_NODE_SELECTION_FREE"/>
    <ref name="MSK_MIO_NODE_SELECTION_WORST"/>
    <ref name="MSK_MIO_NODE_SELECTION_BEST"/>
    <ref name="MSK_MIO_NODE_SELECTION_FIRST"/>
   </values_from>
   <default>MSK_MIO_NODE_SELECTION_FREE</default>
  </p>
  <p name="MSK_IPAR_ANA_SOL_PRINT_VIOLATED" val="2">
   <cmnt>\begin{MSKexcl}{!cmdln:mex}
                   Controls whether a list of violated constraints is printed when calling \MSKfunctex{mosek:task:analyzesolution}.
                   All constraints violated by more than the value set by the parameter  \MSKitemtex{mosek:dparam:ana_sol_infeas_tol} will be printed.
                  \end{MSKexcl}
                  \begin{MSKexcl}{cmdln}
                  Controls whether a list of violated constraints is printed.
                  \end{MSKexcl}</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SOL_READ_WIDTH" val="181">
   <cmnt>Controls the maximal acceptable width of line in the solutions when read by \mosek.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1024</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LINDEP_WORK_LIM" val="120">
   <cmnt>Is used to limit the amount of work that can done
                    to locate linear dependencies.  In general the
                    higher value this parameter is given the less work
                    can be used.  However, a value of $0$ means no
                    limit on the amount work that can be used.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS" val="33">
   <cmnt>Maximum number of steps to be used by the iterative
                  refinement of the search direction. A negative value
                  implies that the optimizer Chooses the maximum number
                  of iterative refinement steps.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_READ_ADD_CON" val="124">
   <cmnt>Additional number of constraints that is
                    made room for in the problem.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_LOG_CONCURRENT" val="53">
   <cmnt>Controls amount of output printed
                    by the concurrent optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM_MINOR" val="73">
   <cmnt>Currently not in use.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_SIM_MAX_ITERATIONS" val="159">
   <cmnt>Maximum number of iterations that can be used by a
                    simplex optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10000000</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MAX_ITERATIONS" val="31">
   <cmnt>Controls the maximum number of iterations
                    allowed in the interior-point optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>400</default>
  </p>
  <p name="MSK_IPAR_CPU_TYPE" val="20">
   <cmnt>Specifies the CPU type. By default \mosek{} tries to auto detect the
                  CPU type. Therefore, we recommend to change this parameter only if the
                  auto detection does not work properly.</cmnt>
   <values_from group="MSKcputypee">
    <ref name="MSK_CPU_POWERPC_G5"/>
    <ref name="MSK_CPU_INTEL_PM"/>
    <ref name="MSK_CPU_GENERIC"/>
    <ref name="MSK_CPU_UNKNOWN"/>
    <ref name="MSK_CPU_AMD_OPTERON"/>
    <ref name="MSK_CPU_INTEL_ITANIUM2"/>
    <ref name="MSK_CPU_AMD_ATHLON"/>
    <ref name="MSK_CPU_HP_PARISC20"/>
    <ref name="MSK_CPU_INTEL_P4"/>
    <ref name="MSK_CPU_INTEL_P3"/>
    <ref name="MSK_CPU_INTEL_CORE2"/>
   </values_from>
   <default>MSK_CPU_UNKNOWN</default>
  </p>
  <p name="MSK_IPAR_LOG_BI" val="50">
   <cmnt>Controls the amount of output printed
                    by the basis identification procedure. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MAX_NUM_COR" val="32">
   <cmnt>Controls the maximum number of correctors allowed
                     by the multiple corrector procedure. A
                    negative value means that \mosek{} is making the
                    choice.</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_LINE_WIDTH" val="197">
   <cmnt>Maximum width of line in an LP file written by \mosek{}.</cmnt>
   <lower_bound>40</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>80</default>
  </p>
  <p name="MSK_IPAR_SOL_READ_NAME_WIDTH" val="180">
   <cmnt>When a solution is read by \mosek{} and some constraint, variable or cone names
                    contain blanks, then a maximum name width much be specified. A negative value implies
                    that no name contain blanks.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_LICENSE_DEBUG" val="45">
   <cmnt>This option is used to turn on debugging of the incense manager.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LICENSE_WAIT" val="48">
   <cmnt>If all licenses are in use \mosek{} returns with an error code.
                    However, by turning on this parameter \mosek{} will wait for an available license.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_ANA_SOL_BASIS" val="1">
   <cmnt>Controls whether the basis matrix is analyzed in solaution analyzer.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES" val="116">
   <cmnt>Control the maximum number of times the eliminator is tried.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_WRITE_GENERIC_NAMES_IO" val="193">
   <cmnt>Index origin used in  generic names.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_NUM_OPTIMIZERS" val="15">
   <cmnt>The maximum number of simultaneous optimizations that will be started
                    by the concurrent optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>2</default>
  </p>
  <p name="MSK_IPAR_SIM_REFACTOR_FREQ" val="169">
   <cmnt>Controls how frequent the basis is refactorized.
                    The value 0 means that the optimizer determines 
                    the best point of refactorization.

                    It is strongly recommended NOT to change this parameter.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_SELECTION" val="154">
   <cmnt>Controls the choice of the incoming variable,
                    known as the selection strategy, in the dual
                    simplex optimizer.</cmnt>
   <values_from group="MSKsimseltypee">
    <ref name="MSK_SIM_SELECTION_FULL"/>
    <ref name="MSK_SIM_SELECTION_PARTIAL"/>
    <ref name="MSK_SIM_SELECTION_FREE"/>
    <ref name="MSK_SIM_SELECTION_ASE"/>
    <ref name="MSK_SIM_SELECTION_DEVEX"/>
    <ref name="MSK_SIM_SELECTION_SE"/>
   </values_from>
   <default>MSK_SIM_SELECTION_FREE</default>
  </p>
  <p name="MSK_IPAR_SIM_SOLVE_FORM" val="174">
   <cmnt>Controls whether the primal or the dual problem is solved by the primal-/dual- simplex optimizer.</cmnt>
   <values_from group="MSKsolveforme">
    <ref name="MSK_SOLVE_PRIMAL"/>
    <ref name="MSK_SOLVE_DUAL"/>
    <ref name="MSK_SOLVE_FREE"/>
   </values_from>
   <default>MSK_SOLVE_FREE</default>
  </p>
  <p name="MSK_IPAR_CHECK_CONVEXITY" val="13">
   <cmnt>Specify the level of convexity check on quadratic problems</cmnt>
   <values_from group="MSKcheckconvexitytypee">
    <ref name="MSK_CHECK_CONVEXITY_SIMPLE"/>
    <ref name="MSK_CHECK_CONVEXITY_NONE"/>
    <ref name="MSK_CHECK_CONVEXITY_FULL"/>
   </values_from>
   <default>MSK_CHECK_CONVEXITY_FULL</default>
  </p>
  <p name="MSK_IPAR_QO_SEPARABLE_REFORMULATION" val="122">
   <cmnt>Determine if Quadratic programing problems should be reformulated to separable form.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LP_WRITE_IGNORE_INCOMPATIBLE_ITEMS" val="76">
   <cmnt>Controls the result of writing a problem containing
                    incompatible items to an LP file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_READ_TASK_IGNORE_PARAM" val="144">
   <cmnt>Controls whether \mosek{} should ignore the parameter setting defined in the task file and use the
                    default parameter setting instead.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_OPTIMIZER_MODE" val="95">
   <cmnt>An exprimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>1</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_LOG_INTPNT" val="60">
   <cmnt>Controls amount of output printed printed
                    by the interior-point optimizer. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_LOG_MIO" val="61">
   <cmnt>Controls the log level for the mixed-integer optimizer. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_SIM_HOTSTART" val="156">
   <cmnt>Controls the type of hot-start that the simplex optimizer perform.</cmnt>
   <values_from group="MSKsimhotstarte">
    <ref name="MSK_SIM_HOTSTART_NONE"/>
    <ref name="MSK_SIM_HOTSTART_STATUS_KEYS"/>
    <ref name="MSK_SIM_HOTSTART_FREE"/>
   </values_from>
   <default>MSK_SIM_HOTSTART_FREE</default>
  </p>
  <p name="MSK_IPAR_LOG_PARAM" val="66">
   <cmnt>Controls the amount of information printed out about parameter changes.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_WRITE_DATA_FORMAT" val="189">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                Controls the file format when writing task data to a file. 
                \end{MSKexcl}
                
                \begin{MSKexcl}{!mex:cmdln}
                Controls the data format when a task is written using
                \MSKfunctex{mosek:task:writedata}.
                \end{MSKexcl}</cmnt>
   <values_from group="MSKdataformate">
    <ref name="MSK_DATA_FORMAT_XML"/>
    <ref name="MSK_DATA_FORMAT_FREE_MPS"/>
    <ref name="MSK_DATA_FORMAT_EXTENSION"/>
    <ref name="MSK_DATA_FORMAT_MPS"/>
    <ref name="MSK_DATA_FORMAT_LP"/>
    <ref name="MSK_DATA_FORMAT_MBT"/>
    <ref name="MSK_DATA_FORMAT_OP"/>
   </values_from>
   <default>MSK_DATA_FORMAT_EXTENSION</default>
  </p>
  <p name="MSK_IPAR_SIM_EXPLOIT_DUPVEC" val="155">
   <cmnt>Controls if the simplex optimizers are allowed to exploit duplicated columns.</cmnt>
   <values_from group="MSKsimdupvece">
    <ref name="MSK_SIM_EXPLOIT_DUPVEC_ON"/>
    <ref name="MSK_SIM_EXPLOIT_DUPVEC_OFF"/>
    <ref name="MSK_SIM_EXPLOIT_DUPVEC_FREE"/>
   </values_from>
   <default>MSK_SIM_EXPLOIT_DUPVEC_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_BRANCH_DIR" val="78">
   <cmnt>Controls whether the mixed-integer optimizer is branching up or down by default.</cmnt>
   <values_from group="MSKbranchdire">
    <ref name="MSK_BRANCH_DIR_DOWN"/>
    <ref name="MSK_BRANCH_DIR_UP"/>
    <ref name="MSK_BRANCH_DIR_FREE"/>
   </values_from>
   <default>MSK_BRANCH_DIR_FREE</default>
  </p>
  <p name="MSK_IPAR_INTPNT_FACTOR_DEBUG_LVL" val="29">
   <cmnt>Controls factorization debug level.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SOL_QUOTED_NAMES" val="179">
   <cmnt>If this options is turned on, then \mosek{} will quote names that contains blanks while writing the solution file.
                    Moreover when reading leading and trailing quotes will be stripped of.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LICENSE_PAUSE_TIME" val="46">
   <cmnt>If \MSKitemtex{mosek:iparam:license_wait}=\MSKitemtex{mosek:onoffkey:on} and no license is available,  then \mosek{} sleeps a number
                    of milliseconds between each check of whether a license has become free.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>1000000</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_IPAR_MIO_PRESOLVE_AGGREGATE" val="96">
   <cmnt>Controls whether the presolve used by the mixed-integer
                    optimizer tries to aggregate the constraints.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_TASK_INC_SOL" val="209">
   <cmnt>Controls whether the solutions are  stored in the task file too.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LICENSE_CACHE_TIME" val="43">
   <cmnt>Setting this parameter no longer has any effect. Please see \MSKitemtex{mosek:iparam:cache_license} for an alternative.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>65555</upper_bound>
   <default>5</default>
  </p>
  <p name="MSK_IPAR_BI_MAX_ITERATIONS" val="9">
   <cmnt>Controls the maximum number of
                    simplex iterations allowed to optimize
                    a basis after the basis identification.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000000</default>
  </p>
  <p name="MSK_IPAR_SIM_HOTSTART_LU" val="157">
   <cmnt>Determines if the simplex optimizer should exploit the initial factorization.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOLUTIONS" val="111">
   <cmnt>Enable inclusion of solutions in the OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_NETWORK_DETECT_HOTSTART" val="162">
   <cmnt>This parameter controls has large the network component in ``relative''
                  terms has to be before it is exploited in a simplex hot-start. 
                  The network component should be equal or larger than 
                  %
\begin{verbatim}                  
max(\MSKverbitemtex{mosek:iparam:sim_network_detect},\MSKverbitemtex{mosek:iparam:sim_network_detect_hotstart})
\end{verbatim}
                  %
                  before it is exploited.  
                  If this value is larger than 100 the network flow component is never detected or exploited.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LINDEP_USE" val="119">
   <cmnt>Controls whether the linear constraints are checked for linear dependencies.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PARAM_READ_IGN_ERROR" val="114">
   <cmnt>If turned on, then errors in paramter settings is ignored.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_HEADER" val="104">
   <cmnt>Write a text header with date and MOSEK version in an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_CONT_SOL" val="81">
   <cmnt>Controls the meaning of the interior-point and basic solutions in mixed integer problems.</cmnt>
   <values_from group="MSKmiocontsoltypee">
    <ref name="MSK_MIO_CONT_SOL_ITG"/>
    <ref name="MSK_MIO_CONT_SOL_NONE"/>
    <ref name="MSK_MIO_CONT_SOL_ROOT"/>
    <ref name="MSK_MIO_CONT_SOL_ITG_REL"/>
   </values_from>
   <default>MSK_MIO_CONT_SOL_NONE</default>
  </p>
  <p name="MSK_IPAR_OBJECTIVE_SENSE" val="102">
   <cmnt>If the objective sense for the task is undefined, then the value of this parameter is used as the default objective sense.</cmnt>
   <values_from group="MSKobjsensee">
    <ref name="MSK_OBJECTIVE_SENSE_MINIMIZE"/>
    <ref name="MSK_OBJECTIVE_SENSE_UNDEFINED"/>
    <ref name="MSK_OBJECTIVE_SENSE_MAXIMIZE"/>
   </values_from>
   <default>MSK_OBJECTIVE_SENSE_MINIMIZE</default>
  </p>
  <p name="MSK_IPAR_WRITE_INT_HEAD" val="195">
   <cmnt>Controls whether the header section is written to the
                    integer solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_STARTING_POINT" val="40">
   <cmnt>Starting point used by the interior-point optimizer.</cmnt>
   <values_from group="MSKstartpointtypee">
    <ref name="MSK_STARTING_POINT_GUESS"/>
    <ref name="MSK_STARTING_POINT_SATISFY_BOUNDS"/>
    <ref name="MSK_STARTING_POINT_CONSTANT"/>
    <ref name="MSK_STARTING_POINT_FREE"/>
   </values_from>
   <default>MSK_STARTING_POINT_FREE</default>
  </p>
  <p name="MSK_IPAR_LOG" val="49">
   <cmnt>Controls the amount of log information. The value 0 implies that all log information is suppressed.
                  A higher level implies that more information is logged.       

                  Please note  that if a task is employed to solve a sequence of optimization problems the value of 
                  this parameter is reduced by the value of \MSKitemtex{mosek:iparam:log_cut_second_opt} for the second 
                  and any subsequent optimizations.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_PRIORITY_PRIMAL_SIMPLEX" val="19">
   <cmnt>Priority of the primal simplex algorithm when selecting solvers for
                    concurrent optimization.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_OBJ_SENSE" val="138">
   <cmnt>If turned on, the MPS reader uses the objective sense section. Otherwise the MPS reader ignores it.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_CACHE_LICENSE" val="10">
   <cmnt>Specifies if the license is kept checked out for the lifetime of the 
                    mosek environment (on) or returned to the server immediately after the optimization (off).

                    \begin{MSKexcl}{c}
                    By default the license is checked out for the lifetime of the \mosek{}
                    environment by the first call to \MSKfunctex{mosek:task:optimizetrm}. 
                    The license is checked in when \MSKfunctex{mosek:env:deleteenv} is called. 

                    A specific license feature may be checked in when not in use with the function 
                    \MSKfunctex{mosek:env:checkinlicense}.
                    \end{MSKexcl}

                    \begin{MSKexcl}{java:dotnet}
                    By default the license is checked out for the lifetime of the \mosek{}
                    environment by the first call to \MSKfunctex{mosek:task:optimizetrm}. 
                    The license is checked in when the environment is deleted.

                    A specific license feature may be checked in when not in use with the function 
                    \MSKfunctex{mosek:env:checkinlicense}.
                    \end{MSKexcl}

                    Check-in and check-out of licenses have an overhead.
                    Frequent communication with the license server should be avoided.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM_NETWORK_FREQ" val="74">
   <cmnt>Controls how frequent the network simplex optimizer
                    outputs information about the optimization
                    and how frequent the user-defined call-back function
                    is called. The network optimizer will use a logging frequency equal to 
                    \MSKitemtex{mosek:iparam:log_sim_freq} times \MSKitemtex{mosek:iparam:log_sim_network_freq}.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_INTPNT_DIFF_STEP" val="28">
   <cmnt>Controls whether different step sizes
                    are allowed in the primal and dual space.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SIM_SCALING" val="172">
   <cmnt>Controls how much effort is used in scaling the problem
                    before a simplex optimizer is used.</cmnt>
   <values_from group="MSKscalingtypee">
    <ref name="MSK_SCALING_NONE"/>
    <ref name="MSK_SCALING_MODERATE"/>
    <ref name="MSK_SCALING_AGGRESSIVE"/>
    <ref name="MSK_SCALING_FREE"/>
   </values_from>
   <default>MSK_SCALING_FREE</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_TERMS_PER_LINE" val="200">
   <cmnt>Maximum number of terms on a single line in an LP file written by \mosek{}.
                    0 means unlimited.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10</default>
  </p>
  <p name="MSK_IPAR_SENSITIVITY_ALL" val="146">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                    Not applicable.
                    \end{MSKexcl}
                    \begin{MSKexcl}{!mex:cmdln}
                    If set to \MSKitemtex{mosek:onoffkey:on}, then \MSKfunctex{mosek:task:sensitivityreport} analyzes all
                    bounds and variables instead of reading a specification from the file.
                    \end{MSKexcl}</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SOL_FILTER_KEEP_RANGED" val="178">
   <cmnt>If turned on, then ranged constraints and variables are written to the solution file
                  independent of the filter setting.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_BI_IGNORE_MAX_ITER" val="7">
   <cmnt>If the parameter
                   \MSKitemtex{mosek:iparam:intpnt_basis} has the
                   value \MSKitemtex{mosek:basindtype:no_error} and
                   the interior-point optimizer has terminated due to
                   maximum number of iterations, then basis
                   identification is performed if this parameter has
                   the value \MSKitemtex{mosek:onoffkey:on}.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG_FEASREPAIR" val="56">
   <cmnt>Controls the amount of output printed when performing feasibility repair.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_INTPNT_SOLVE_FORM" val="39">
   <cmnt>Controls whether the primal
                    or the dual problem is solved.</cmnt>
   <values_from group="MSKsolveforme">
    <ref name="MSK_SOLVE_PRIMAL"/>
    <ref name="MSK_SOLVE_DUAL"/>
    <ref name="MSK_SOLVE_FREE"/>
   </values_from>
   <default>MSK_SOLVE_FREE</default>
  </p>
  <p name="MSK_IPAR_OPF_MAX_TERMS_PER_LINE" val="103">
   <cmnt>The maximum number of terms (linear and quadratic) per line when an OPF file is written.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>5</default>
  </p>
  <p name="MSK_IPAR_WRITE_PRECISION" val="205">
   <cmnt>Controls the precision with which \comp{double}
                    numbers are printed in the MPS data file. In general it
                    is not worthwhile to use a value higher than 15.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>8</default>
  </p>
  <p name="MSK_IPAR_SIM_BASIS_FACTOR_USE" val="149">
   <cmnt>Controls whether a (LU) factorization of the basis is used in a hot-start. 
                    Forcing a refactorization sometimes improves the stability of the simplex optimizers, but in most cases
                    there is a performance penanlty.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_XML_MODE" val="210">
   <cmnt>Controls if linear coefficients should be written by row or column when writing in the XML file format.</cmnt>
   <values_from group="MSKxmlwriteroutputtypee">
    <ref name="MSK_WRITE_XML_MODE_COL"/>
    <ref name="MSK_WRITE_XML_MODE_ROW"/>
   </values_from>
   <default>MSK_WRITE_XML_MODE_ROW</default>
  </p>
  <p name="MSK_IPAR_INTPNT_REGULARIZATION_USE" val="37">
   <cmnt>Controls whether regularization is allowed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_BI_CLEAN_OPTIMIZER" val="6">
   <cmnt>Controls which simplex optimizer is used in the clean-up phase.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_QCONE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_MIO_PRESOLVE_PROBING" val="97">
   <cmnt>Controls whether the mixed-integer presolve
                    performs probing. Probing can be very time consuming.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LICENSE_ALLOW_OVERUSE" val="42">
   <cmnt>Controls if license overuse is allowed when caching licenses</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INFEAS_PREFER_PRIMAL" val="24">
   <cmnt>If both certificates of primal and dual infeasibility are supplied then
                    only the primal is used when this option is turned on.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_BAS_VARIABLES" val="187">
   <cmnt>Controls whether the variables section is written to the
                    basic solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_STORAGE" val="75">
   <cmnt>When turned on, \mosek{} prints messages regarding
                    the storage usage and allocation.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_MIO_PRESOLVE_USE" val="98">
   <cmnt>Controls whether presolve is performed by the mixed-integer optimizer.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_READ_LP_QUOTED_NAMES" val="135">
   <cmnt>If a name is in quotes when reading an LP file, the quotes will be removed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_BASIS" val="27">
   <cmnt>Controls whether the interior-point optimizer also
                    computes an optimal basis.</cmnt>
   <values_from group="MSKbasindtypee">
    <ref name="MSK_BI_ALWAYS"/>
    <ref name="MSK_BI_NO_ERROR"/>
    <ref name="MSK_BI_NEVER"/>
    <ref name="MSK_BI_IF_FEASIBLE"/>
    <ref name="MSK_BI_OTHER"/>
   </values_from>
   <default>MSK_BI_ALWAYS</default>
  </p>
  <p name="MSK_IPAR_LOG_CUT_SECOND_OPT" val="54">
   <cmnt>If a task is employed to solve a sequence of optimization problems, then the value of the log levels is reduced by the value
                  of this parameter. E.g \MSKitemtex{mosek:iparam:log} and \MSKitemtex{mosek:iparam:log_sim} are reduced by the value of this parameter 
                  for the second and any subsequent optimizations.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_KEEP_INT" val="137">
   <cmnt>Controls whether \mosek{} should keep the integer restrictions
                    on the variables while reading the MPS file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_SOLUTIONS" val="91">
   <cmnt>The mixed-integer optimizer can be terminated after a certain number of different feasible  
                    solutions has been located. If this parameter has the value $n$ and $n$ is strictly positive, then the mixed-integer optimizer
                    will be terminated when $n$ feasible solutions have been located.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_LICENSE_CHECK_TIME" val="44">
   <cmnt>The parameter specifies the number of seconds between the checks of 
                    all the active licenses in the \mosek{}
                    environment license cache. These checks are performed to determine
                    if the licenses should be returned to the server.</cmnt>
   <lower_bound>1</lower_bound>
   <upper_bound>120</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_VARIABLES" val="208">
   <cmnt>Controls whether the variables section is written to the
                    solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SENSITIVITY_OPTIMIZER" val="147">
   <cmnt>Controls which optimizer is used for optimal partition sensitivity analysis.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_QCONE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE_SIMPLEX</default>
  </p>
  <p name="MSK_IPAR_WRITE_MPS_INT" val="201">
   <cmnt>Controls if  marker records are written to the MPS file
                    to indicate whether variables are integer restricted.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SIM_MAX_NUM_SETBACKS" val="160">
   <cmnt>Controls how many set-backs are allowed within a simplex
                    optimizer. A set-back is an event where the optimizer moves in
                    the wrong direction. This is impossible in theory but may happen due
                    to numerical problems.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>250</default>
  </p>
  <p name="MSK_IPAR_DATA_CHECK" val="21">
   <cmnt>If this option is turned on, then extensive data checking is enabled.
                  It will slow down \mosek{} but on the other hand help locating bugs.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_PRIORITY_FREE_SIMPLEX" val="17">
   <cmnt>Priority of the free simplex optimizer when selecting solvers for
                    concurrent optimization.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>3</default>
  </p>
  <p name="MSK_IPAR_READ_KEEP_FREE_CON" val="133">
   <cmnt>Controls whether the free constraints are included in
                    the problem.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG_FILE" val="57">
   <cmnt>If turned on, then some log info is printed when a file is written or read.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_PRIORITY_INTPNT" val="18">
   <cmnt>Priority of the interior-point algorithm when selecting solvers for
                    concurrent optimization.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_SIM_NON_SINGULAR" val="164">
   <cmnt>Controls if the simplex optimizer ensures a non-singular basis, if possible.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_DATA_PARAM" val="190">
   <cmnt>If this option is turned on the parameter settings are written to the
                    data file as parameters.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_DEGEN" val="150">
   <cmnt>Controls how aggressively degeneration is handled.</cmnt>
   <values_from group="MSKsimdegene">
    <ref name="MSK_SIM_DEGEN_NONE"/>
    <ref name="MSK_SIM_DEGEN_MODERATE"/>
    <ref name="MSK_SIM_DEGEN_MINIMUM"/>
    <ref name="MSK_SIM_DEGEN_AGGRESSIVE"/>
    <ref name="MSK_SIM_DEGEN_FREE"/>
   </values_from>
   <default>MSK_SIM_DEGEN_FREE</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_HINTS" val="105">
   <cmnt>Write a hint section with problem dimensions in the beginning of an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_ELIMINATOR_USE" val="117">
   <cmnt>Controls whether free or implied free
                    variables are eliminated from the problem.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_ALLOC_ADD_QNZ" val="0">
   <cmnt>Additional number of $Q$ non-zeros that are allocated space for when \comp{numanz} exceeds \comp{maxnumqnz}
                    during addition of new $Q$ entries.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>5000</default>
  </p>
  <p name="MSK_IPAR_MIO_HOTSTART" val="86">
   <cmnt>Controls whether the integer optimizer is hot-started.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_FORMAT" val="136">
   <cmnt>Controls how strictly the MPS file reader interprets the MPS format.</cmnt>
   <values_from group="MSKmpsformate">
    <ref name="MSK_MPS_FORMAT_STRICT"/>
    <ref name="MSK_MPS_FORMAT_RELAXED"/>
    <ref name="MSK_MPS_FORMAT_FREE"/>
   </values_from>
   <default>MSK_MPS_FORMAT_RELAXED</default>
  </p>
  <p name="MSK_IPAR_PARAM_READ_CASE_NAME" val="113">
   <cmnt>If turned on, then names in the parameter file are case sensitive.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_QUOTED_NAMES" val="139">
   <cmnt>If a name is in quotes when reading an MPS file, then the quotes will be removed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_OPTIMIZER" val="64">
   <cmnt>Controls the amount of general optimizer information that is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_WRITE_MPS_OBJ_SENSE" val="202">
   <cmnt>If turned off, the objective sense section is not written to the MPS file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_NUM_THREADS" val="34">
   <cmnt>Controls the number of threads employed by the interior-point optimizer. If set to a positive number MOSEK will use this number of threads.
                    If zero the number of threads used will equal the number of cores detected on the machine.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_BRANCHES" val="89">
   <cmnt>Maximum number of branches allowed during the branch and bound search. A negative
                    value means infinite.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_CRASH" val="165">
   <cmnt>Controls whether crashing is performed in the primal simplex optimizer.
                    
                    In general, if a basis consists of more than (100-this parameter value)\%
                    fixed variables, then a crash will be performed.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>90</default>
  </p>
  <p name="MSK_IPAR_MIO_CONSTRUCT_SOL" val="80">
   <cmnt>If set to \MSKitemtex{mosek:onoffkey:on} and all integer variables have been given a
                    value for which a feasible mixed integer solution exists, then \mosek{}
                    generates an initial solution to the mixed integer problem by fixing all integer
                    values and solving the remaining problem.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_AUTO_SORT_A_BEFORE_OPT" val="3">
   <cmnt>Controls whether the elements in each column of $A$ are sorted before an optimization is performed.
                       This is not required but makes the optimization more deterministic.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_STRONG_BRANCH" val="100">
   <cmnt>The value specifies the depth from the root in which strong branching is used.
                    A negative value means that the optimizer chooses a default value automatically.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_PHASEONE_METHOD" val="152">
   <cmnt>An exprimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>10</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_INTEGER" val="158">
   <cmnt>An exprimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>10</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION" val="167">
   <cmnt>The primal simplex optimizer can use a so-called restricted selection/pricing strategy to
                   chooses the outgoing variable. Hence, if restricted selection is applied, then the primal simplex optimizer first
                   choose a subset of all the potential incoming variables. Next, for some time it will choose the incoming
                   variable only among the subset. From time to time the subset is redefined.

                   A larger value of this parameter implies that the optimizer will be more aggressive in its
                   restriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>100</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_READ_CONE" val="130">
   <cmnt>Expected maximum number of conic constraints to be read. The option is
                     used only by fast MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>2500</default>
  </p>
  <p name="MSK_IPAR_OPTIMIZER" val="112">
   <cmnt>The paramter controls which optimizer is used to optimize the task.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_QCONE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_MAX_NUM_WARNINGS" val="77">
   <cmnt>Waning level. A higher value results in more warnings.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10</default>
  </p>
  <p name="MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS" val="47">
   <cmnt>Controls whether license features expire warnings are suppressed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_HEAD" val="207">
   <cmnt>Controls whether the header section is written to the
                    solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_BAS_CONSTRAINTS" val="185">
   <cmnt>Controls whether the constraint section is written to the
                    basic solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_FEASPUMP_LEVEL" val="84">
   <cmnt>Feasibility pump is a heuristic designed to compute an initial feasible solution.
                A value of 0 implies that the feasibility pump heuristic is not used. A value of -1 implies that the mixed-integer
                optimizer decides how the feasibility pump heuristic is used. A larger value than 1 implies that the feasibility pump is
                employed more aggressively. Normally a value beyond 3 is not worthwhile.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>3</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_INFEAS_GENERIC_NAMES" val="23">
   <cmnt>Controls whether generic names are used when an infeasible subproblem is created.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_NETWORK_DETECT" val="161">
   <cmnt>The simplex optimizer is capable of exploiting a
                  network flow component in a problem. However it is
                  only worthwhile to exploit the network flow
                  component if it is sufficiently large. This
                  parameter controls how large the network component
                  has to be in ``relative'' terms before it is
                  exploited. For instance a value of $20$ means at least
                  20\% of the model should be a network before it is
                  exploited. If this value is larger than 100 the
                  network flow component is never detected or
                  exploited.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>101</default>
  </p>
  <p name="MSK_IPAR_LOG_RESPONSE" val="68">
   <cmnt>Controls amount of output printed when response codes are reported. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_INFEAS_REPORT_LEVEL" val="26">
   <cmnt>Controls the amount of information presented in an infeasibility report.
                    Higher values imply more information.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_CACHE_SIZE_L1" val="11">
   <cmnt>Specifies the size of the cache
                    of the computer. This parameter is
                    potentially very important for the efficiency
                    on computers if \mosek{} cannot determine the
                    cache size automatically. If the cache size is
                    negative, then \mosek{} tries to determine the value
                    automatically.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_CACHE_SIZE_L2" val="12">
   <cmnt>Specifies the size of the cache
                    of the computer. This parameter is
                    potentially very important for the efficiency
                    on computers where \mosek{} cannot determine the
                    cache size automatically. If the cache size is
                    negative, then \mosek{} tries to determine the value
                    automatically.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_SIM_SWITCH_OPTIMIZER" val="176">
   <cmnt>The simplex optimizer sometimes chooses to solve the dual problem instead of the primal problem.
                   This implies that if you have chosen to use the dual simplex optimizer and the problem is dualized, 
                   then it actually makes sense to use the primal simplex optimizer instead. If this parameter is on
                   and the problem is dualized and furthermore the simplex optimizer is chosen to be the primal (dual) one, 
                   then it is switched to the dual (primal).</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_READ_DATA_COMPRESSED" val="131">
   <cmnt>If this option is turned on,it is assumed that the data file is compressed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_READ_Q_MODE" val="142">
   <cmnt>Controls how the Q matrices are read from the MPS file.</cmnt>
   <values_from group="MSKqreadtypee">
    <ref name="MSK_Q_READ_ADD"/>
    <ref name="MSK_Q_READ_DROP_LOWER"/>
    <ref name="MSK_Q_READ_DROP_UPPER"/>
   </values_from>
   <default>MSK_Q_READ_ADD</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_PROBLEM" val="107">
   <cmnt>Write objective, constraints, bounds etc. to an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_CHECK_CONVEXITY" val="52">
   <cmnt>Controls logging in convexity check on quadratic problems.
                    Set to a positive value to turn logging on. 

                    If a quadratic coefficient matrix is found to violate the requirement of PSD (NSD)
                    then a list of negative (positive) pivot elements is printed. The absolute value of the pivot elements
                    is also shown.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_READ_DATA_FORMAT" val="132">
   <cmnt>Format of the data file to be read.</cmnt>
   <values_from group="MSKdataformate">
    <ref name="MSK_DATA_FORMAT_XML"/>
    <ref name="MSK_DATA_FORMAT_FREE_MPS"/>
    <ref name="MSK_DATA_FORMAT_EXTENSION"/>
    <ref name="MSK_DATA_FORMAT_MPS"/>
    <ref name="MSK_DATA_FORMAT_LP"/>
    <ref name="MSK_DATA_FORMAT_MBT"/>
    <ref name="MSK_DATA_FORMAT_OP"/>
   </values_from>
   <default>MSK_DATA_FORMAT_EXTENSION</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_CRASH" val="151">
   <cmnt>Controls whether crashing is performed in the dual simplex optimizer.
                    
                    In general if a basis consists of more than (100-this parameter value)\%
                    fixed variables, then a crash will be performed.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>90</default>
  </p>
  <p name="MSK_IPAR_SIM_NETWORK_DETECT_METHOD" val="163">
   <cmnt>Controls which type of detection method the network extraction should use.</cmnt>
   <values_from group="MSKnetworkdetecte">
    <ref name="MSK_NETWORK_DETECT_SIMPLE"/>
    <ref name="MSK_NETWORK_DETECT_ADVANCED"/>
    <ref name="MSK_NETWORK_DETECT_FREE"/>
   </values_from>
   <default>MSK_NETWORK_DETECT_FREE</default>
  </p>
  <p name="MSK_IPAR_READ_VAR" val="145">
   <cmnt>Expected maximum number of variable to be read. The option is
                    used only by MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10000</default>
  </p>
  <p name="MSK_IPAR_LOG_HEAD" val="58">
   <cmnt>If turned on, then a header line is added to the log.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_SIM_REFORMULATION" val="170">
   <cmnt>Controls if the simplex optimizers are allowed to reformulate the problem.</cmnt>
   <values_from group="MSKsimreforme">
    <ref name="MSK_SIM_REFORMULATION_ON"/>
    <ref name="MSK_SIM_REFORMULATION_AGGRESSIVE"/>
    <ref name="MSK_SIM_REFORMULATION_OFF"/>
    <ref name="MSK_SIM_REFORMULATION_FREE"/>
   </values_from>
   <default>MSK_SIM_REFORMULATION_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_SAVE_LU" val="171">
   <cmnt>Controls if the LU factorization stored should be replaced with the LU factorization 
                    corresponding to the initial basis.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_INTPNT_FACTOR_METHOD" val="30">
   <cmnt>Controls the method used to factor the Newton equation system.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_RELAXS" val="90">
   <cmnt>Maximum number of relaxations allowed during the branch and bound search. A negative
                    value means infinite.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_SOL_FILTER_KEEP_BASIC" val="177">
   <cmnt>If turned on, then basic and super basic constraints and variables
                    are written to the solution file independent of the filter setting.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_HEURISTIC_LEVEL" val="85">
   <cmnt>Controls the heuristic employed by the mixed-integer
                    optimizer to locate an initial good integer feasible
                    solution.  A value of zero means the heuristic is not used
                    at all. A larger value than 0 means that a gradually more
                    sophisticated heuristic is used which is computationally
                    more expensive. A negative value implies that the optimizer
                    chooses the heuristic. Normally a value around $3$ to $5$
                    should be optimal.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_KEEP_BASIS" val="87">
   <cmnt>Controls whether the integer presolve keeps bases in memory. This speeds
                    on the solution process at cost of bigger memory consumption.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_SCALING" val="38">
   <cmnt>Controls how the problem is scaled
                    before the interior-point optimizer
                    is used.</cmnt>
   <values_from group="MSKscalingtypee">
    <ref name="MSK_SCALING_NONE"/>
    <ref name="MSK_SCALING_MODERATE"/>
    <ref name="MSK_SCALING_AGGRESSIVE"/>
    <ref name="MSK_SCALING_FREE"/>
   </values_from>
   <default>MSK_SCALING_FREE</default>
  </p>
 </sec>
 <sec id="MSKadopcodee" type="enum">
  <c name="MSK_ADOP_SUB" val="1">
   <cmnt>Subtract two operands.</cmnt>
  </c>
  <c name="MSK_ADOP_POW" val="4">
   <cmnt>First operand to the power the second operand.</cmnt>
  </c>
  <c name="MSK_ADOP_RET" val="7">
   <cmnt>Return one operand.</cmnt>
  </c>
  <c name="MSK_ADOP_ADD" val="0">
   <cmnt>Add two operands.</cmnt>
  </c>
  <c name="MSK_ADOP_EXP" val="5">
   <cmnt>Exponential function of one oparand.</cmnt>
  </c>
  <c name="MSK_ADOP_MUL" val="2">
   <cmnt>Multiply two operands.</cmnt>
  </c>
  <c name="MSK_ADOP_DIV" val="3">
   <cmnt>Divide two operands.</cmnt>
  </c>
  <c name="MSK_ADOP_LOG" val="6">
   <cmnt>Logarithm function of one operand.</cmnt>
  </c>
 </sec>
 <sec id="MSKsolstae" type="enum">
  <c name="MSK_SOL_STA_DUAL_INFEAS_CER" val="6">
   <cmnt>The solution is a certificate of dual infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_INFEAS_CER" val="5">
   <cmnt>The solution is a certificate
                    of primal infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_UNKNOWN" val="0">
   <cmnt>Status of the solution is unknown.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_OPTIMAL" val="8">
   <cmnt>The solution is nearly optimal.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_PRIM_INFEAS_CER" val="12">
   <cmnt>The solution is almost a certificate
                    of primal infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_FEAS" val="2">
   <cmnt>The solution is primal feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_INTEGER_OPTIMAL" val="15">
   <cmnt>The primal solution is near integer optimal.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_DUAL_FEAS" val="10">
   <cmnt>The solution is nearly dual feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_INTEGER_OPTIMAL" val="14">
   <cmnt>The primal solution is integer optimal.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_DUAL_INFEAS_CER" val="13">
   <cmnt>The solution is almost a certificate of dual infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_PRIM_AND_DUAL_FEAS" val="11">
   <cmnt>The solution is nearly both
                    primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_OPTIMAL" val="1">
   <cmnt>The solution is optimal.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_AND_DUAL_FEAS" val="4">
   <cmnt>The solution is both primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_PRIM_FEAS" val="9">
   <cmnt>The solution is nearly primal feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_DUAL_FEAS" val="3">
   <cmnt>The solution is dual feasible.</cmnt>
  </c>
 </sec>
 <sec id="MSKobjsensee" type="enum">
  <c name="MSK_OBJECTIVE_SENSE_MINIMIZE" val="1">
   <cmnt>The problem should be minimized.</cmnt>
  </c>
  <c name="MSK_OBJECTIVE_SENSE_UNDEFINED" val="0">
   <cmnt>The objective sense is undefined.</cmnt>
  </c>
  <c name="MSK_OBJECTIVE_SENSE_MAXIMIZE" val="2">
   <cmnt>The problem should be maximized.</cmnt>
  </c>
 </sec>
 <sec id="MSKsoliteme" type="enum">
  <c name="MSK_SOL_ITEM_SUC" val="4">
   <cmnt>Lagrange multipliers for upper
                    bounds on the constraints.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_XC" val="0">
   <cmnt>Solution for the constraints.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_XX" val="1">
   <cmnt>Variable solution.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_Y" val="2">
   <cmnt>Lagrange multipliers for equations.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SLX" val="5">
   <cmnt>Lagrange multipliers for lower
                    bounds on the variables.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SUX" val="6">
   <cmnt>Lagrange multipliers for upper
                    bounds on the variables.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SNX" val="7">
   <cmnt>Lagrange multipliers corresponding to the conic constraints on the variables.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SLC" val="3">
   <cmnt>Lagrange multipliers for lower
                    bounds on the constraints.</cmnt>
  </c>
 </sec>
 <sec id="MSKboundkeye" type="enum">
  <c name="MSK_BK_FX" val="2">
   <cmnt>The constraint or variable is fixed.</cmnt>
  </c>
  <c name="MSK_BK_LO" val="0">
   <cmnt>The constraint or variable has a finite
                    lower bound and an infinite upper bound.</cmnt>
  </c>
  <c name="MSK_BK_FR" val="3">
   <cmnt>The constraint or variable is free.</cmnt>
  </c>
  <c name="MSK_BK_UP" val="1">
   <cmnt>The constraint or variable has an infinite
                    lower bound and an finite upper bound.</cmnt>
  </c>
  <c name="MSK_BK_RA" val="4">
   <cmnt>The constraint or variable is ranged.</cmnt>
  </c>
 </sec>
 <sec id="MSKbasindtypee" type="constants">
  <c name="MSK_BI_ALWAYS" val="1">
   <cmnt>Basis identification is always performed even if the interior-point optimizer terminates
                    abnormally.</cmnt>
  </c>
  <c name="MSK_BI_NO_ERROR" val="2">
   <cmnt>Basis identification is performed if the interior-point optimizer terminates without an error.</cmnt>
  </c>
  <c name="MSK_BI_NEVER" val="0">
   <cmnt>Never do basis identification.</cmnt>
  </c>
  <c name="MSK_BI_IF_FEASIBLE" val="3">
   <cmnt>Basis identification is not performed if the interior-point optimizer terminates
                    with a problem status saying that the problem is primal or dual infeasible.</cmnt>
  </c>
  <c name="MSK_BI_OTHER" val="4">
   <cmnt>Try another BI method.</cmnt>
  </c>
 </sec>
 <sec id="MSKbranchdire" type="constants">
  <c name="MSK_BRANCH_DIR_DOWN" val="2">
   <cmnt>The mixed-integer optimizer always chooses the down branch first.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_UP" val="1">
   <cmnt>The mixed-integer optimizer always chooses the up branch first.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_FREE" val="0">
   <cmnt>The mixed-integer optimizer decides which branch to choose.</cmnt>
  </c>
 </sec>
 <sec id="MSKliinfiteme" type="enum">
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_ITER" val="6">
   <cmnt>Number of primal clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_INTPNT_FACTOR_NUM_NZ" val="9">
   <cmnt>Number of non-zeros in factorization.</cmnt>
  </c>
  <c name="MSK_LIINF_MIO_INTPNT_ITER" val="10">
   <cmnt>Number of interior-point iterations performed by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_DUAL_ITER" val="4">
   <cmnt>Number of primal-dual clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_DUAL_DEG_ITER" val="3">
   <cmnt>Number of primal-dual degenerate clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER" val="2">
   <cmnt>Number of primal degenerate clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_DUAL_ITER" val="1">
   <cmnt>Number of dual clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_RD_NUMQNZ" val="13">
   <cmnt>Number of Q non-zeros.</cmnt>
  </c>
  <c name="MSK_LIINF_RD_NUMANZ" val="12">
   <cmnt>Number of non-zeros in A that is read.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_PRIMAL_ITER" val="8">
   <cmnt>Number of primal pivots performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_DUAL_ITER" val="7">
   <cmnt>Number of dual pivots performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER" val="0">
   <cmnt>Number of dual degenerate clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_MIO_SIMPLEX_ITER" val="11">
   <cmnt>Number of simplex iterations performed by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_DUAL_SUB_ITER" val="5">
   <cmnt>Number of primal-dual subproblem clean iterations performed in the basis identification.</cmnt>
  </c>
 </sec>
 <sec id="MSKstreamtypee" type="enum">
  <c name="MSK_STREAM_MSG" val="1">
   <cmnt>Message stream. Log information relating to performance and progress of the optimization is written to this stream.</cmnt>
  </c>
  <c name="MSK_STREAM_WRN" val="3">
   <cmnt>Warning stream. Warning messages are written to this stream.</cmnt>
  </c>
  <c name="MSK_STREAM_LOG" val="0">
   <cmnt>Log stream. Contains the aggregated contents of all other streams. This means that a message written to any other stream will also be written to this stream.</cmnt>
  </c>
  <c name="MSK_STREAM_ERR" val="2">
   <cmnt>Error stream. Error messages are written to this stream.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimhotstarte" type="enum">
  <c name="MSK_SIM_HOTSTART_NONE" val="0">
   <cmnt>The simplex optimizer performs a coldstart.</cmnt>
  </c>
  <c name="MSK_SIM_HOTSTART_STATUS_KEYS" val="2">
   <cmnt>Only the status keys of the constraints and variables are used
                   to choose the type of hot-start.</cmnt>
  </c>
  <c name="MSK_SIM_HOTSTART_FREE" val="1">
   <cmnt>The simplex optimize chooses the hot-start type.</cmnt>
  </c>
 </sec>
 <sec id="MSKcallbackcodee" type="enum">
  <c name="MSK_CALLBACK_END_INTPNT" val="44">
   <cmnt>The call-back function is called
                    when the interior-point optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_DUAL_SIMPLEX_BI" val="21">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal-dual simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_NETWORK_PRIMAL_SIMPLEX" val="48">
   <cmnt>The call-back function is called when the primal network simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_ADD_CONS" val="99">
   <cmnt>A chunk of constraints has been read from a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI" val="115">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the primal simplex clean-up phase.
                    The frequency of the call-backs is controlled by the
                    \MSKitemtex{mosek:iparam:log_sim_freq} parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_MIO" val="46">
   <cmnt>The call-back function is called when the mixed-integer optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_NETWORK_DUAL_SIMPLEX" val="13">
   <cmnt>The call-back function is called when the dual network simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_CONCURRENT" val="35">
   <cmnt>Concurrent optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_NEW_INT_MIO" val="93">
   <cmnt>The call-back function is called after a new integer solution
                    has been located by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_SIMPLEX" val="88">
   <cmnt>The call-back function is called at an intermediate point in the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_SIMPLEX_NETWORK_DETECT" val="64">
   <cmnt>The call-back function is called when the network detection procedure is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_NETWORK_DUAL_SIMPLEX" val="47">
   <cmnt>The call-back function is called when the dual network simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_INTPNT" val="72">
   <cmnt>The call-back function is called
                    at an intermediate stage within the interior-point optimizer where
                    the information database has not been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_DUAL_BI" val="68">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the dual phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_FULL_CONVEXITY_CHECK" val="8">
   <cmnt>Begin full convexity check.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_BI" val="3">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the dual phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY" val="4">
   <cmnt>Dual sensitivity analysis is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX" val="79">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the
                    primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_BI" val="19">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_ADD_QNZ" val="100">
   <cmnt>A chunk of $Q$ non-zeos has been read from a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_CONCURRENT" val="1">
   <cmnt>Concurrent optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_DUAL_BI" val="104">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the dual phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_DUAL_SIMPLEX" val="70">
   <cmnt>The call-back function is called at an intermediate point in the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_LICENSE_WAIT" val="11">
   <cmnt>Begin waiting for license.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_NETWORK_PRIMAL_SIMPLEX" val="81">
   <cmnt>The call-back function is called at an intermediate point in the primal network simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_NETWORK_SIMPLEX" val="49">
   <cmnt>The call-back function is called when the simplex network optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_CONIC" val="32">
   <cmnt>The call-back function is called from within the
                    conic optimizer after the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_QO_REFORMULATE" val="89">
   <cmnt>The call-back function is called at an intermediate stage of the QP to SOCP reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_CONIC" val="2">
   <cmnt>The call-back function is called
                    when the conic optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI" val="106">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the dual simplex clean-up phase.
                    The frequency of the call-backs is controlled by the
                    \MSKitemtex{mosek:iparam:log_sim_freq} parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_OPTIMIZER" val="51">
   <cmnt>The call-back function is called when the optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRESOLVE" val="110">
   <cmnt>The call-back function is called
                    from within the presolve procedure.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_SIMPLEX" val="90">
   <cmnt>The call-back function is called
                    from within the simplex optimizer at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_OPF" val="102">
   <cmnt>The call-back function is called
                    from the OPF reader.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_LICENSE_WAIT" val="73">
   <cmnt>MOSEK is waiting for a license.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_NETWORK_SIMPLEX" val="15">
   <cmnt>The call-back function is called when the simplex network optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_CONIC" val="36">
   <cmnt>The call-back function is called
                    when the conic optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_NETWORK_DUAL_SIMPLEX" val="107">
   <cmnt>The call-back function is called in the dual network simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_QCQO_REFORMULATE" val="26">
   <cmnt>Begin QCQO reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SENSITIVITY" val="38">
   <cmnt>Dual sensitivity analysis is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI" val="59">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_ADD_VARS" val="101">
   <cmnt>A chunk of variables has been read from a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_OPF_SECTION" val="103">
   <cmnt>A chunk of $Q$ non-zeos has been read from a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_LU" val="74">
   <cmnt>The call-back function is called
                    from within the LU factorization procedure at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SIMPLEX_BI" val="41">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the dual clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_LICENSE_WAIT" val="45">
   <cmnt>End waiting for license.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRESOLVE" val="84">
   <cmnt>The call-back function is called
                    from within the presolve procedure
                    at an intermediate stage.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SETUP_BI" val="5">
   <cmnt>The call-back function is called when the dual BI phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_INFEAS_ANA" val="43">
   <cmnt>The call-back function is called when the infeasibility analyzer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_INTPNT" val="92">
   <cmnt>The call-back function is called from within the
                    interior-point optimizer after the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_BI" val="111">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the primal phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_NONCOVEX" val="94">
   <cmnt>The call-back function is called from within the
                    nonconvex optimizer after the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_DUAL_SIMPLEX_BI" val="113">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the primal-dual simplex clean-up phase.
                    The frequency of the call-backs is controlled by the
                    \MSKitemtex{mosek:iparam:log_sim_freq} parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_NONCONVEX" val="109">
   <cmnt>The call-back function is called
                    at an intermediate stage within the nonconvex optimizer where
                    the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_BI" val="37">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the dual phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_READ" val="61">
   <cmnt>MOSEK has finished reading a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_ADD_CONES" val="98">
   <cmnt>A chunk of cones has been read from a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI" val="25">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_SIMPLEX_NETWORK_DETECT" val="30">
   <cmnt>The call-back function is called when the network detection procedure is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_ADD_ANZ" val="97">
   <cmnt>A chunk of $A$ non-zeos has been read from a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_DUAL_SIMPLEX" val="86">
   <cmnt>The call-back function is called at an intermediate point in the primal-dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX" val="114">
   <cmnt>The call-back function is called  in the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_DUAL_SIMPLEX" val="33">
   <cmnt>The call-back function is called
                    from within the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_FULL_CONVEXITY_CHECK" val="71">
   <cmnt>The call-back function is called at an intermediate stage of the full convexity check.</cmnt>
  </c>
  <c name="MSK_CALLBACK_PRIMAL_SIMPLEX" val="95">
   <cmnt>The call-back function is called
                    from within the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_NONCONVEX" val="16">
   <cmnt>The call-back function is called
                    when the nonconvex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_SIMPLEX_BI" val="91">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the simplex clean-up phase.
                    The frequency of the call-backs is controlled by the
                    \MSKitemtex{mosek:iparam:log_sim_freq} parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SIMPLEX" val="6">
   <cmnt>The call-back function is called when the dual simplex optimizer started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX" val="24">
   <cmnt>The call-back function is called when the primal simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_NONCONVEX" val="50">
   <cmnt>The call-back function is called
                    when the nonconvex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI" val="23">
   <cmnt>The call-back function is called when the primal BI setup is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_OPTIMIZER" val="17">
   <cmnt>The call-back function is called when the optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_READ" val="27">
   <cmnt>MOSEK has started reading a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_NONCONVEX" val="82">
   <cmnt>The call-back function is called
                    at an intermediate stage within the nonconvex optimizer where
                    the information database has not been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SIMPLEX" val="58">
   <cmnt>The call-back function is called when the primal simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_DUAL_SIMPLEX_BI" val="55">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal-dual clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_BI" val="66">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_NETWORK_DUAL_SIMPLEX" val="80">
   <cmnt>The call-back function is called at an intermediate point in the dual network simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SETUP_BI" val="39">
   <cmnt>The call-back function is called when the dual BI phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_BI" val="34">
   <cmnt>The call-back function is called
                    when the basis identification procedure
                    is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SETUP_BI" val="57">
   <cmnt>The call-back function is called when the primal BI setup is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_WRITE" val="31">
   <cmnt>MOSEK has started writing a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_SIMPLEX_BI" val="63">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the simplex clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SENSITIVITY" val="56">
   <cmnt>Primal sensitivity analysis is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_SIMPLEX" val="28">
   <cmnt>The call-back function is called when the simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRESOLVE" val="52">
   <cmnt>The call-back function is called
                    when the presolve is completed.</cmnt>
  </c>
  <c name="MSK_CALLBACK_QCONE" val="96">
   <cmnt>The call-back function is called
                    from within the Qcone optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_INFEAS_ANA" val="9">
   <cmnt>The call-back function is called when the infeasibility analyzer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_DUAL_SIMPLEX" val="20">
   <cmnt>The call-back function is called when the primal-dual simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY" val="22">
   <cmnt>Primal sensitivity analysis is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI" val="7">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the dual simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_QCQO_REFORMULATE" val="60">
   <cmnt>End QCQO reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_SENSIVITY" val="87">
   <cmnt>The call-back function is called at an intermediate stage of the primal sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_WRITE" val="65">
   <cmnt>MOSEK has finished writing a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SIMPLEX" val="40">
   <cmnt>The call-back function is called when the dual simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_DUAL_SIMPLEX" val="112">
   <cmnt>The call-back function is called  in the primal-dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_SIMPLEX_BI" val="29">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_INTPNT" val="10">
   <cmnt>The call-back function is called
                    when the interior-point optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_DUAL_SENSIVITY" val="69">
   <cmnt>The call-back function is called at an intermediate stage of the dual sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_SIMPLEX" val="62">
   <cmnt>The call-back function is called when the simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_BI" val="53">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO" val="75">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_DUAL_SIMPLEX" val="105">
   <cmnt>The call-back function is called in the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_INTPNT" val="77">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the
                    interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_DUAL_SIMPLEX" val="54">
   <cmnt>The call-back function is called when the primal-dual simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_CONIC" val="67">
   <cmnt>The call-back function is called
                    at an intermediate stage within the conic optimizer where
                    the information database has not been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_PRESOLVE" val="78">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the
                    presolve.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_BI" val="0">
   <cmnt>The basis identification procedure
                    has been started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX" val="76">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the
                    dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_WRITE_OPF" val="116">
   <cmnt>The call-back function is called
                    from the OPF writer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_NETWORK_PRIMAL_SIMPLEX" val="108">
   <cmnt>The call-back function is called in the primal network simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_FULL_CONVEXITY_CHECK" val="42">
   <cmnt>End full convexity check.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_ORDER" val="83">
   <cmnt>The call-back function is called
                    from within the matrix ordering procedure at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_BI" val="85">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the primal phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRESOLVE" val="18">
   <cmnt>The call-back function is called
                    when the presolve is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_MIO" val="12">
   <cmnt>The call-back function is called when the mixed-integer optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_NETWORK_PRIMAL_SIMPLEX" val="14">
   <cmnt>The call-back function is called when the primal network simplex optimizer is started.</cmnt>
  </c>
 </sec>
 <sec id="MSKproblemiteme" type="enum">
  <c name="MSK_PI_VAR" val="0">
   <cmnt>Item is a variable.</cmnt>
  </c>
  <c name="MSK_PI_CONE" val="2">
   <cmnt>Item is a cone.</cmnt>
  </c>
  <c name="MSK_PI_CON" val="1">
   <cmnt>Item is a constraint.</cmnt>
  </c>
 </sec>
 <sec id="MSKfeaturee" type="enum">
  <c name="MSK_FEATURE_PTOM" val="2">
   <cmnt>Mixed-integer extension.</cmnt>
  </c>
  <c name="MSK_FEATURE_PTON" val="1">
   <cmnt>Nonlinear extension.</cmnt>
  </c>
  <c name="MSK_FEATURE_PTS" val="0">
   <cmnt>Base system.</cmnt>
  </c>
  <c name="MSK_FEATURE_PTOX" val="3">
   <cmnt>Non-convex extension.</cmnt>
  </c>
 </sec>
 <sec id="MSKsparame" type="parameters">
  <p name="MSK_SPAR_PARAM_COMMENT_SIGN" val="8">
   <cmnt>Only the first character in this string is
                    used. It is considered as a start of comment sign
                    in the \mosek{} parameter file. Spaces are ignored
                    in the string.</cmnt>
   <default>"%%"</default>
  </p>
  <p name="MSK_SPAR_FEASREPAIR_NAME_PREFIX" val="3">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                    Not applicable.
                    \end{MSKexcl}
                    
                    \begin{MSKexcl}{!mex:cmdln}
                    If the function \MSKfunctex{mosek:task:relaxprimal} adds new constraints to the problem, then
                    they are prefixed by the value of this parameter.
                    \end{MSKexcl}</cmnt>
   <default>"MSK-"</default>
  </p>
  <p name="MSK_SPAR_BAS_SOL_FILE_NAME" val="0">
   <cmnt>Name of the \comp{bas} solution file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_OBJ_NAME" val="12">
   <cmnt>Name of the free constraint  used as objective function.
                    An empty name means that the first constraint is used as objective function.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_FEASREPAIR_NAME_WSUMVIOL" val="5">
   <cmnt>The constraint and variable associated with the total weighted sum of violations
                    are each given the name of this parameter postfixed with \texttt{CON} and \texttt{VAR} respectively.</cmnt>
   <default>"WSUMVIOL"</default>
  </p>
  <p name="MSK_SPAR_FEASREPAIR_NAME_SEPARATOR" val="4">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                    Not applicable.
                    \end{MSKexcl}
                    \begin{MSKexcl}{!mex:cmdln}
                    Separator string for names of constraints and
                    variables generated by
                    \MSKfunctex{mosek:task:relaxprimal}.
                    \end{MSKexcl}</cmnt>
   <default>"-"</default>
  </p>
  <p name="MSK_SPAR_PARAM_WRITE_FILE_NAME" val="10">
   <cmnt>The parameter database is written to this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_INT_SOL_FILE_NAME" val="6">
   <cmnt>Name of the \comp{int} solution file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_RHS_NAME" val="14">
   <cmnt>Name of the RHS used.
                    An empty name means that the first RHS vector is used.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_STAT_FILE_NAME" val="21">
   <cmnt>Statistics file name.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_WRITE_LP_GEN_VAR_NAME" val="24">
   <cmnt>Sometimes when an LP file is written additional variables must be inserted.
                    They will have the prefix denoted by this parameter.</cmnt>
   <default>"xmskgen"</default>
  </p>
  <p name="MSK_SPAR_DATA_FILE_NAME" val="1">
   <cmnt>Data are read and written to this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_RAN_NAME" val="13">
   <cmnt>Name of the RANGE vector  used.
                    An empty name means that the first RANGE vector is used.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XC_LOW" val="17">
   <cmnt>A filter used to determine which constraints
                    should be listed in the solution file. A value of ``0.5'' means that
                    all constraints having  \comp{xc[i]&gt;0.5} should be listed, whereas
                    ``+0.5'' means that all constraints having \comp{xc[i]&gt;=blc[i]+0.5} should
                    be listed. An empty filter means that no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XC_UPR" val="18">
   <cmnt>A filter  used to determine which constraints
                     should be listed in the solution file. A value of ``0.5'' means
                    that all constraints having \comp{xc[i]&lt;0.5} should be listed, whereas
                    ``-0.5'' means all constraints having \comp{xc[i]&lt;=buc[i]-0.5} should
                    be listed. An empty filter means that no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_BOU_NAME" val="11">
   <cmnt>Name of the BOUNDS vector used.
                    An empty name means that the first BOUNDS vector is used.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XX_UPR" val="20">
   <cmnt>A filter  used to determine which variables
                     should be listed in the solution file. A value of ``0.5'' means
                    that all constraints having \comp{xx[j]&lt;0.5} should be printed, whereas
                    ``-0.5'' means all constraints having \comp{xx[j]&lt;=bux[j]-0.5} should
                    be listed. An empty filter means no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_STAT_NAME" val="23">
   <cmnt>Name used when writing the statistics file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_PARAM_READ_FILE_NAME" val="9">
   <cmnt>Modifications to the parameter
                    database is read from this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_ITR_SOL_FILE_NAME" val="7">
   <cmnt>Name of the \comp{itr} solution file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SENSITIVITY_FILE_NAME" val="15">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                    Not applicable.
                    \end{MSKexcl}
                    \begin{MSKexcl}{!mex:cmdln}
                    If defined \MSKfunctex{mosek:task:sensitivityreport} reads this file as
                    a sensitivity analysis data file specifying the type of analysis
                    to be done.
                    \end{MSKexcl}</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_DEBUG_FILE_NAME" val="2">
   <cmnt>MOSEK debug file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_STAT_KEY" val="22">
   <cmnt>Key used when writing the summary file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SENSITIVITY_RES_FILE_NAME" val="16">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                    Not applicable.
                    \end{MSKexcl}
                    \begin{MSKexcl}{!mex:cmdln}
                    If this is a nonempty string, then \MSKfunctex{mosek:task:sensitivityreport} writes results to this file.
                    \end{MSKexcl}</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XX_LOW" val="19">
   <cmnt>A filter  used to determine which variables
                     should be listed in the solution file. A value of ``0.5'' means
                    that all constraints having \comp{xx[j]&gt;=0.5} should be listed, whereas
                    ``+0.5'' means that all constraints having \comp{xx[j]&gt;=blx[j]+0.5} should
                    be listed. An empty filter means no filter is applied.</cmnt>
   <default>""</default>
  </p>
 </sec>
 <sec id="MSKmarke" type="enum">
  <c name="MSK_MARK_LO" val="0">
   <cmnt>The lower bound is selected for sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_MARK_UP" val="1">
   <cmnt>The upper bound is selected for sensitivity analysis.</cmnt>
  </c>
 </sec>
 <sec id="MSKconetypee" type="enum">
  <c name="MSK_CT_QUAD" val="0">
   <cmnt>The cone is a quadratic cone.</cmnt>
  </c>
  <c name="MSK_CT_RQUAD" val="1">
   <cmnt>The cone is a rotated quadratic cone.</cmnt>
  </c>
 </sec>
 <sec id="MSKfeasrepairtypee" type="constants">
  <c name="MSK_FEASREPAIR_OPTIMIZE_NONE" val="0">
   <cmnt>Do not optimize the feasibility repair problem.</cmnt>
  </c>
  <c name="MSK_FEASREPAIR_OPTIMIZE_COMBINED" val="2">
   <cmnt>Minimize with original objective subject to minimal weighted violation of bounds.</cmnt>
  </c>
  <c name="MSK_FEASREPAIR_OPTIMIZE_PENALTY" val="1">
   <cmnt>Minimize weighted sum of violations.</cmnt>
  </c>
 </sec>
 <sec id="MSKiomodee" type="constants">
  <c name="MSK_IOMODE_READ" val="0">
   <cmnt>The file is read-only.</cmnt>
  </c>
  <c name="MSK_IOMODE_WRITE" val="1">
   <cmnt>The file is write-only. If the file exists then it is
                    truncated when it is opened. Otherwise it is created when it is opened.</cmnt>
  </c>
  <c name="MSK_IOMODE_READWRITE" val="2">
   <cmnt>The file is to read and written.</cmnt>
  </c>
 </sec>
 <sec id="MSKadoptypee" type="enum">
  <c name="MSK_ADOPTYPE_VARIABLE" val="2">
   <cmnt>Operand refers to a variable.</cmnt>
  </c>
  <c name="MSK_ADOPTYPE_NONE" val="0">
   <cmnt>Operand not used.</cmnt>
  </c>
  <c name="MSK_ADOPTYPE_CONSTANT" val="1">
   <cmnt>Operand refers to a constant.</cmnt>
  </c>
  <c name="MSK_ADOPTYPE_REFERENCE" val="3">
   <cmnt>Operand refers to the result of another operation.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimseltypee" type="constants">
  <c name="MSK_SIM_SELECTION_FULL" val="1">
   <cmnt>The optimizer uses full pricing.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_PARTIAL" val="5">
   <cmnt>The optimizer uses a partial selection approach. The approach is usually
                    beneficial if the number of variables is much larger than  the number of constraints.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_FREE" val="0">
   <cmnt>The optimizer chooses the pricing strategy.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_ASE" val="2">
   <cmnt>The optimizer uses approximate steepest-edge
                    pricing.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_DEVEX" val="3">
   <cmnt>The optimizer uses devex steepest-edge pricing (or if it is not available an
                    approximate steep-edge selection).</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_SE" val="4">
   <cmnt>The optimizer uses steepest-edge selection (or if it is not available an
                    approximate steep-edge selection).</cmnt>
  </c>
 </sec>
 <sec id="MSKmsgkeye" type="enum">
  <c name="MSK_MSG_READING_FILE" val="1000">
   <cmnt></cmnt>
  </c>
  <c name="MSK_MSG_WRITING_FILE" val="1001">
   <cmnt></cmnt>
  </c>
  <c name="MSK_MSG_MPS_SELECTED" val="1100">
   <cmnt></cmnt>
  </c>
 </sec>
 <sec id="MSKmiomodee" type="constants">
  <c name="MSK_MIO_MODE_IGNORED" val="0">
   <cmnt>The integer constraints are ignored and the problem is solved as a continuous problem.</cmnt>
  </c>
  <c name="MSK_MIO_MODE_LAZY" val="2">
   <cmnt>Integer restrictions should be satisfied if
                    an optimizer is available for the problem.</cmnt>
  </c>
  <c name="MSK_MIO_MODE_SATISFIED" val="1">
   <cmnt>Integer restrictions should be satisfied.</cmnt>
  </c>
 </sec>
 <sec id="MSKdinfiteme" type="enum">
  <c name="MSK_DINF_INTPNT_PRIMAL_FEAS" val="13">
   <cmnt>Primal feasibility measure reported by the
                    interior-point or Qcone optimizers. (For the
                    interior-point optimizer this measure does not
                    directly related to the original problem because
                    a homogeneous model is employed).</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_MAX_PCNI" val="58">
   <cmnt>Maximal primal cone infeasibility in the interior-point solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_RD_TIME" val="32">
   <cmnt>Time spent reading the data file.</cmnt>
  </c>
  <c name="MSK_DINF_PRESOLVE_ELI_TIME" val="28">
   <cmnt>Total time spent in the eliminator
                    since the presolve was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OPTIMIZER_TIME" val="22">
   <cmnt>Time spent in the optimizer while solving the relaxtions.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_FACTOR_NUM_FLOPS" val="10">
   <cmnt>An estimate of the number of flops used in the factorization.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_TIME" val="25">
   <cmnt>Time spent in the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_BI_DUAL_TIME" val="4">
   <cmnt>Time spent within the dual phase basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_NETWORK_TIME" val="37">
   <cmnt>Time spent in the network simplex
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_PRESOLVE_TIME" val="30">
   <cmnt>Total time (in seconds) spent in the presolve
                    since it was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_PRESOLVE_LINDEP_TIME" val="29">
   <cmnt>Total time spent  in the linear dependency checker
                    since the presolve was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_DUAL_TIME" val="33">
   <cmnt>Time spent in the dual simplex 
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_MAX_PINTI" val="60">
   <cmnt>Maximal primal integer infeasibility in the interior-point solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_OBJ" val="38">
   <cmnt>Objective value reported by the
                    simplex optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_REL_GAP" val="21">
   <cmnt>Given that the mixed-integer optimizer has computed a feasible solution and a bound
                    on the optimal objective value, then this item contains the relative gap defined by
                    \[
\frac{| \mbox{(objective value of feasible solution)}-\mbox{(objective bound)} | }{\max(\delta,|\mbox{(objective value of feasible solution)}|)}.
\]
%
where $\delta$ is given by the paramater \MSKitemtex{mosek:dparam:mio_rel_gap_const}. Otherwise it has the value -1.0.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_PRIMAL_OBJ" val="48">
   <cmnt>Primal objective value of the basic solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_HEURISTIC_TIME" val="17">
   <cmnt>Time spent in the optimizer while solving the relaxtions.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_MAX_PBI" val="57">
   <cmnt>Maximal primal bound infeasibility in the interior-point solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_MAX_PBI" val="45">
   <cmnt>Maximal primal bound infeasibility in the basic solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_OPTIMIZER_TIME" val="27">
   <cmnt>Total time spent in the optimizer since it was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_MAX_DCNI" val="55">
   <cmnt>Maximal dual cone infeasibility in the interior-point solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_ROOT_PRESOLVE_TIME" val="24">
   <cmnt>Time spent in while presolveing the root relaxation.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_DUAL_OBJ" val="9">
   <cmnt>Dual objective value reported by the
                    interior-point or Qcone optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_TIME" val="15">
   <cmnt>Time spent within the interior-point optimizer
                    since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ" val="16">
   <cmnt>If \mosek{} has successfully constructed an integer feasible solution, then this item
                    contains the optimal objective value corresponding to the feasible solution.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_FEAS" val="34">
   <cmnt>Feasibility measure reported by the
                    simplex optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_MAX_DEQI" val="56">
   <cmnt>Maximal dual equality infeasibility in the interior-point solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_PRIMAL_TIME" val="40">
   <cmnt>Time spent in the primal simplex 
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_TIME" val="41">
   <cmnt>Time spent in the simplex
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_NETWORK_PRIMAL_TIME" val="36">
   <cmnt>Time spent in the primal network simplex 
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_MAX_PINTI" val="47">
   <cmnt>Maximal primal integer infeasibility in the basic solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_INT_MAX_PINTI" val="51">
   <cmnt>Maximal primal integer infeasibility in the integer solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_TIME" val="3">
   <cmnt>Time spent within the clean-up phase of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_QCQO_REFORMULATE_TIME" val="31">
   <cmnt>Time spent with QP reformulation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DUAL_OBJ" val="53">
   <cmnt>Dual objective value of the interior-point solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_INT_MAX_PBI" val="49">
   <cmnt>Maximal primal bound infeasibility in the integer solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_DUAL_FEAS" val="8">
   <cmnt>Dual feasibility measure reported by the
                    interior-point and Qcone optimizer. (For the
                    interior-point optimizer this measure does not
                    directly related to the original problem because
                    a homogeneous model is employed.)</cmnt>
  </c>
  <c name="MSK_DINF_CONCURRENT_TIME" val="7">
   <cmnt>Time spent within the concurrent optimizer since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_KAP_DIV_TAU" val="11">
   <cmnt>This measure should converge to zero if the problem
                    has a primal-dual optimal solution or
                    to infinity if problem is (strictly) primal or dual infeasible.
                    In  case the measure is converging towards a positive but bounded constant
                    the problem is usually ill-posed.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_INT_MAX_PEQI" val="50">
   <cmnt>Maximal primal equality infeasibility in the basic solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PRIMAL_OBJ" val="61">
   <cmnt>Primal objective value of the interior-point solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_NETWORK_DUAL_TIME" val="35">
   <cmnt>Time spent in the dual network simplex 
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_INT" val="20">
   <cmnt>The primal objective value corresponding to the best integer feasible
                    solution. Please note that at least one integer feasible solution must have located i.e.
                    check \MSKitemtex{mosek:iinfitem:mio_num_int_solutions}.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_USER_OBJ_CUT" val="26">
   <cmnt>If the objective cut is used, then this information item has the value of the cut.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_MAX_DBI" val="43">
   <cmnt>Maximal dual bound infeasibility in the basic solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_MAX_PEQI" val="46">
   <cmnt>Maximal primal equality infeasibility in the basic solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_BOUND" val="19">
   <cmnt>The best known bound on the objective function. This value
                    is undefined until at least one relaxation has been solved:
                    To see if this is the case check that
                    \MSKitemtex{mosek:iinfitem:mio_num_relax} is stricly
                    positive.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_DUAL_TIME" val="0">
   <cmnt>Time  spent within the dual clean-up optimizer of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_BI_TIME" val="6">
   <cmnt>Time spent within the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_DUAL_OBJ" val="42">
   <cmnt>Dual objective value of the basic solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_PRIMAL_DUAL_TIME" val="1">
   <cmnt>Time spent within the primal-dual clean-up optimizer of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_PRIMAL_OBJ" val="14">
   <cmnt>Primal objective value reported by the
                    interior-point or Qcone optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_ORDER_TIME" val="12">
   <cmnt>Order time (in seconds).</cmnt>
  </c>
  <c name="MSK_DINF_SOL_INT_PRIMAL_OBJ" val="52">
   <cmnt>Primal objective value of the integer solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_BI_PRIMAL_TIME" val="5">
   <cmnt>Time  spent within the primal phase of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_ABS_GAP" val="18">
   <cmnt>Given the mixed-integer optimizer has computed a feasible solution and a bound
                    on the optimal objective value, then this item contains the absolute gap defined by
                    \[
|\mbox{(objective value of feasible solution)}-\mbox{(objective bound)}|.
\]
%
Otherwise it has the value -1.0.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_MAX_DEQI" val="44">
   <cmnt>Maximal dual equality infeasibility in the basic solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_MAX_PEQI" val="59">
   <cmnt>Maximal primal equality infeasibility in the interior-point solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_PRIMAL_DUAL_TIME" val="39">
   <cmnt>Time spent in the primal-dual simplex optimizer
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_PRIMAL_TIME" val="2">
   <cmnt>Time spent within the primal clean-up optimizer of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_MAX_DBI" val="54">
   <cmnt>Maximal dual bound infeasibility in the interior-point solution.
                    Updated at the end of the optimization.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_ROOT_OPTIMIZER_TIME" val="23">
   <cmnt>Time spent in the optimizer while solving the root relaxation.</cmnt>
  </c>
 </sec>
 <sec id="MSKparametertypee" type="enum">
  <c name="MSK_PAR_INVALID_TYPE" val="0">
   <cmnt>Not a valid parameter.</cmnt>
  </c>
  <c name="MSK_PAR_STR_TYPE" val="3">
   <cmnt>Is a string parameter.</cmnt>
  </c>
  <c name="MSK_PAR_DOU_TYPE" val="1">
   <cmnt>Is a double parameter.</cmnt>
  </c>
  <c name="MSK_PAR_INT_TYPE" val="2">
   <cmnt>Is an integer parameter.</cmnt>
  </c>
 </sec>
 <sec id="MSKrescodetypee" type="enum">
  <c name="MSK_RESPONSE_WRN" val="1">
   <cmnt>The response code is a warning.</cmnt>
  </c>
  <c name="MSK_RESPONSE_TRM" val="2">
   <cmnt>The response code is an optimizer termination status.</cmnt>
  </c>
  <c name="MSK_RESPONSE_UNK" val="4">
   <cmnt>The response code does not belong to any class.</cmnt>
  </c>
  <c name="MSK_RESPONSE_OK" val="0">
   <cmnt>The response code is OK.</cmnt>
  </c>
  <c name="MSK_RESPONSE_ERR" val="3">
   <cmnt>The response code is an error.</cmnt>
  </c>
 </sec>
 <sec id="MSKprostae" type="enum">
  <c name="MSK_PRO_STA_PRIM_AND_DUAL_INFEAS" val="6">
   <cmnt>The problem is primal and dual infeasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_INFEAS" val="4">
   <cmnt>The problem is primal infeasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_ILL_POSED" val="7">
   <cmnt>The problem is ill-posed. For example,
                    it may be primal and dual feasible but
                    have a positive duality gap.</cmnt>
  </c>
  <c name="MSK_PRO_STA_UNKNOWN" val="0">
   <cmnt>Unknown problem status.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_FEAS" val="2">
   <cmnt>The problem is primal feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_NEAR_PRIM_AND_DUAL_FEAS" val="8">
   <cmnt>The problem is at least nearly primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_NEAR_DUAL_FEAS" val="10">
   <cmnt>The problem is at least nearly dual feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED" val="11">
   <cmnt>The problem is either primal infeasible or unbounded. This may occur for
                    mixed-integer problems.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_AND_DUAL_FEAS" val="1">
   <cmnt>The problem is primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_DUAL_INFEAS" val="5">
   <cmnt>The problem is dual infeasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_NEAR_PRIM_FEAS" val="9">
   <cmnt>The problem is at least nearly primal feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_DUAL_FEAS" val="3">
   <cmnt>The problem is dual feasible.</cmnt>
  </c>
 </sec>
 <sec id="MSKscalingtypee" type="constants">
  <c name="MSK_SCALING_NONE" val="1">
   <cmnt>No scaling is performed.</cmnt>
  </c>
  <c name="MSK_SCALING_MODERATE" val="2">
   <cmnt>A conservative scaling is performed.</cmnt>
  </c>
  <c name="MSK_SCALING_AGGRESSIVE" val="3">
   <cmnt>A very aggressive scaling is performed.</cmnt>
  </c>
  <c name="MSK_SCALING_FREE" val="0">
   <cmnt>The optimizer chooses the scaling heuristic.</cmnt>
  </c>
 </sec>
 <sec id="MSKrescodee" type="enum">
  <c name="MSK_RES_WRN_SOL_FILE_IGNORED_VAR" val="352">
   <cmnt>One or more lines in the variable section were ignored when reading a solution file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_TYPE" val="1218">
   <cmnt>The parameter type is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_IS_TOO_SMALL" val="1203">
   <cmnt>An index in an argument is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_MARKI" val="2501">
   <cmnt>Invalid value in marki.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PRESOLVE_BAD_PRECISION" val="803">
   <cmnt>The presolve estimates that the model is specified with insufficient precision.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_PROBLEM" val="1500">
   <cmnt>Invalid problem type.
                    Probably a nonconvex problem
                    has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SKX" val="1268">
   <cmnt>Invalid value in \comp{skx}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_NO_OPTIMIZER" val="1551">
   <cmnt>No optimizer is available for the current class of integer optimization problems.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NUM_BRANCHES" val="4009">
   <cmnt>The mixed-integer optimizer terminated as to the maximum number of branches was reached.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NEAR_ABS_GAP" val="4004">
   <cmnt>The mixed-integer optimizer terminated because the near optimal absolute gap tolerance was satisfied.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_DUAL_INFEAS_CER" val="2001">
   <cmnt>A certificate of infeasibility is not available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MUL_A_ELEMENT" val="1254">
   <cmnt>An element in $A$ is defined multiple times.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE" val="1170">
   <cmnt>An invalid name occurred in a solution file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_QOBJ" val="1114">
   <cmnt>The Q term in the objective
                    is specified multiple times in the MPS data file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_INIT_ENV" val="1063">
   <cmnt>\comp{env} is not initialized.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNDEF_SOLUTION" val="1265">
   <cmnt>\mosek{} has the following solution types:
                        %                
                       \begin{itemize}                
                          \item an interior-point solution,
                          \item an basic solution,
                         \item and an integer solution.
                       \end{itemize}   
                       %
                       Each optimizer may set one or more of these solutions; e.g by default a successful optimization with the interior-point optimizer defines the interior-point solution,
                       and, for linear problems, also the basic solution. This error occurs when asking for a solution or for information 
                       about a solution that is not defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LASTJ" val="1288">
   <cmnt>Invalid \comp{lastj}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_EXPIRED" val="1001">
   <cmnt>The license has expired.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_INDEX_INVALID" val="3055">
   <cmnt>Invalid range given in the sensitivity file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SKN" val="1274">
   <cmnt>Invalid value in \comp{skn}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OBJ_Q_NOT_PSD" val="1295">
   <cmnt>The quadratic coefficient matrix in the objective is not positive semi-definite as expected for a minimization problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_LINT_NAME" val="1234">
   <cmnt>A long integer information name is invalid.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_CLOSE_BOUNDS" val="903">
   <cmnt>This warning is issued by problem analyzer, if ranged constraints or variables with very close upper and lower bounds are detected.  One should consider treating such constraints as equalities and such variables as constants.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MISSING_LICENSE_FILE" val="1008">
   <cmnt>\mosek{} cannot find the license file or license server. Usually this happens if the operating system variable
                       \texttt{MOSEKLM\_LICENSE\_FILE} is not set up appropriately. Please see the \mosek{} installation manual for details.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX" val="1235">
   <cmnt>An index is out of range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SOL_FILE_INVALID_NUMBER" val="1350">
   <cmnt>An invalid number is specified in a solution file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LU_MAX_NUM_TRIES" val="2800">
   <cmnt>Could not compute the LU factors of the matrix within the maximum number of allowed tries.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SKC" val="1267">
   <cmnt>Invalid value in \comp{skc}.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DROPPED_NZ_QOBJ" val="201">
   <cmnt>One or more non-zero elements were dropped in the Q matrix in the objective.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INTERNAL" val="3000">
   <cmnt>An internal error occurred. Please report this problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BASIS_FACTOR" val="1610">
   <cmnt>The factorization of the basis is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_IS_TOO_LARGE" val="1204">
   <cmnt>An index in an argument is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_INVALID_VAR_NAME" val="1154">
   <cmnt>A variable name is invalid when used in an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL" val="2950">
   <cmnt>No dual information is available for the integer solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OVERFLOW" val="1590">
   <cmnt>A computation produced an overflow i.e. a very large number.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_INCOMPATIBLE" val="1150">
   <cmnt>The problem cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIXED_PROBLEM" val="1501">
   <cmnt>The problem contains both conic and nonlinear constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX" val="1700">
   <cmnt>An optimization problem cannot be relaxed.
                    This is the case e.g. for general nonlinear optimization problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME_INT" val="1207">
   <cmnt>The parameter name is not correct for an integer parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_SOLUTION_STATUS" val="3057">
   <cmnt>No optimal solution found to the original problem given for sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_LINT_INDEX" val="1225">
   <cmnt>A long integer information index is out of range for the specified type.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NUM_RELAXS" val="4008">
   <cmnt>The mixed-integer optimizer terminated as the maximum number of relaxations was reached.</cmnt>
  </c>
  <c name="MSK_RES_WRN_TOO_MANY_BASIS_VARS" val="405">
   <cmnt>A basis with too many variables has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SPACE_NO_INFO" val="1081">
   <cmnt>No available information about the space usage.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME" val="1205">
   <cmnt>The parameter name is not correct.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_UNDEF_VAR_NAME" val="1106">
   <cmnt>An undefined variable name occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NZ_IN_UPR_TRI" val="200">
   <cmnt>Non-zero elements specified in the upper triangle of a matrix were ignored.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LICENSE_FEATURE_EXPIRE" val="505">
   <cmnt>The license expires.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NEGATIVE_SURPLUS" val="1263">
   <cmnt>Negative surplus.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_SUBK" val="1404">
   <cmnt>Invalid value in \comp{qcsubk}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_SUBJ" val="1406">
   <cmnt>Invalid value in \comp{qcsubj}.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ZEROS_IN_SPARSE_ROW" val="705">
   <cmnt>One or more (near) zero elements are specified in a sparse row of a matrix. 
                    It is redundant to specify zero elements. Hence it may indicate an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_TYPE" val="1198">
   <cmnt>Incorrect argument type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON" val="1017">
   <cmnt>The MOSEKLM license manager daemon is not up and running.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_WCHAR" val="2901">
   <cmnt>An invalid \comp{wchar} string is encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_END_OF_FILE" val="1059">
   <cmnt>End of file reached.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_INVALID_CODELIST" val="3102">
   <cmnt>The code list data was invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BUC" val="1462">
   <cmnt>$u^c$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONLINEAR_EQUALITY" val="1290">
   <cmnt>The model contains a nonlinear equality which defines a nonconvex set.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DATA_FILE_EXT" val="1055">
   <cmnt>The data file format cannot be determined from the file name.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_INDEX" val="1210">
   <cmnt>Parameter index is out of range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIRSTI" val="1285">
   <cmnt>Invalid \comp{firsti}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE" val="1000">
   <cmnt>Invalid license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_PERM_ARRAY" val="1299">
   <cmnt>An invalid permutation array is specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LP_DROP_VARIABLE" val="85">
   <cmnt>Ignored a variable because the variable was not previously defined.
                    Usually this implies that a variable appears in the bound section but not in the objective or the constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIRSTJ" val="1287">
   <cmnt>Invalid \comp{firstj}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_NLO_FUNC" val="1432">
   <cmnt>The user-defined nonlinear function reported an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_DOU_INDEX" val="1219">
   <cmnt>A double information index is out of range for the specified type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LASTI" val="1286">
   <cmnt>Invalid \comp{lasti}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_FUNC_RET_DATA" val="1431">
   <cmnt>An user function returned invalid data.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_NUMCORES" val="3900">
   <cmnt>The computer contains more cpu cores than the license allows for.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NR_ARGUMENTS" val="1199">
   <cmnt>Incorrect number of function arguments.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CON_Q_NOT_PSD" val="1293">
   <cmnt>The quadratic constraint matrix is not positive semi-definite as expected for a constraint with finite upper bound. This results in a nonconvex problem.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ZERO_AIJ" val="63">
   <cmnt>One or more zero elements are specified in A.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_NUMJ" val="2504">
   <cmnt>Invalid numj.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FACTOR" val="1650">
   <cmnt>An error occurred while factorizing a matrix.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_BRANCH_PRIORITY" val="3201">
   <cmnt>An invalid branching priority is specified. It should be nonnegative.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_IS_TOO_SMALL" val="1216">
   <cmnt>The parameter value is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_WRITE_CONIC_PROBLEM" val="1163">
   <cmnt>The problem contains cones that cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_VERSION" val="1002">
   <cmnt>The license is valid for another version of \mosek{}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMCON" val="1240">
   <cmnt>The maximum number of constraints specified is smaller than the number of
                    constraints in the task.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNKNOWN" val="1050">
   <cmnt>Unknown error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_READ_LP_NONEXISTING_NAME" val="1162">
   <cmnt>A variable never occurred in objective or constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_NUMI" val="2503">
   <cmnt>Invalid numi.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONLINEAR_RANGED" val="1292">
   <cmnt>The model contains a nonlinear ranged constraint which by definition defines a nonconvex set.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_MUTEX_UNLOCK" val="1047">
   <cmnt>Could not unlock a mutex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_FILE" val="1100">
   <cmnt>An error occurred while reading an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME" val="1156">
   <cmnt>Empty variable names cannot be written to OPF files.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_DUP_SLACK_NAME" val="1152">
   <cmnt>The name of the slack variable added to a ranged constraint already exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_PRIMAL_INFEAS_CER" val="2000">
   <cmnt>A certificate of primal infeasibility is not available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_LP_FORMAT" val="1158">
   <cmnt>Problem cannot be written as an LP file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BLC" val="1461">
   <cmnt>$l^c$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_NUMERICAL" val="3058">
   <cmnt>Numerical difficulties encountered performing the sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_INDEX_RANGE" val="3052">
   <cmnt>Index out of range in the sensitivity analysis file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT" val="1027">
   <cmnt>The license server does not support the requested feature. 
                    Possible reasons for this error include:
                    \begin{itemize}
                        \item The feature has expired.
                        \item The feature's start date is later than today's date.
                        \item The version requested is higher than feature's the highest supported version.
                        \item A corrupted license file.
                    \end{itemize}
                    
                    
                    Try restarting the license and inspect the license server debug file, usually called \texttt{lmgrd.log}.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SPAR_MAX_LEN" val="66">
   <cmnt>A value for a string parameter is longer than the buffer that is supposed to hold it.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_FORMAT" val="3050">
   <cmnt>Syntax error in sensitivity analysis file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_VAL" val="1407">
   <cmnt>Invalid value in \comp{qcval}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME_DOU" val="1206">
   <cmnt>The parameter name is not correct for a double parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPF_PREMATURE_EOF" val="1172">
   <cmnt>Premature end of file in an OPF file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_INDEX" val="1300">
   <cmnt>An index of a non-existing cone has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_C" val="1470">
   <cmnt>$c$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LIVING_TASKS" val="1066">
   <cmnt>All tasks associated with an enviroment must be deleted
                       before the environment is deleted. There are still some undeleted tasks.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMCONE" val="1304">
   <cmnt>The value specified for \comp{maxnumcone} is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NULL_CON_NAME" val="1103">
   <cmnt>An empty constraint name is used in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QCON_UPPER_TRIANGLE" val="1417">
   <cmnt>An element in the upper triangle of a $Q^k$ is specified. Only elements in the lower triangle should be specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_INVALID_CON_NAME" val="1171">
   <cmnt>A constraint name is invalid when used in an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_TAB_IN_FIELD2" val="1125">
   <cmnt>A tab char occurred in field 2.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MIO_INFEASIBLE_FINAL" val="270">
   <cmnt>The final mixed-integer problem with all the integer variables fixed at their optimal values is infeasible.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ZEROS_IN_SPARSE_COL" val="710">
   <cmnt>One or more (near) zero elements are specified in a sparse column of a matrix. 
                    It is redundant to specify zero elements. Hence, it may indicate an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_NLO_EVAL" val="1433">
   <cmnt>The user-defined nonlinear function reported an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_TYPE" val="1232">
   <cmnt>The information type is invalid.</cmnt>
  </c>
  <c name="MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK" val="800">
   <cmnt>The linear dependency check(s) was not completed and therefore the $A$ matrix 
                    may contain linear dependencies.</cmnt>
  </c>
  <c name="MSK_RES_WRN_USING_GENERIC_NAMES" val="503">
   <cmnt>The file writer reverts to generic names because a name is blank.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_TAB_IN_FIELD5" val="1127">
   <cmnt>A tab char occurred in field 5.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_NAME" val="1056">
   <cmnt>An invalid file name has been specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_WRITE_DISCARDED_CFIX" val="804">
   <cmnt>The fixed objective term could not be converted to a variable and was discarded in the output file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QOBJ_UPPER_TRIANGLE" val="1415">
   <cmnt>An element in the upper triangle of $Q^o$ is specified. Only elements in the lower triangle should be specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_WRITE" val="1054">
   <cmnt>File write error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_CREATE" val="1048">
   <cmnt>Could not create a thread. This error may occur if a large
                    number of environments are created and not deleted again.
                    In any case it is a good practice to minimize the number of
                    environments created.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMQNZ" val="1243">
   <cmnt>The maximum number of non-zeros specified for the $Q$ matrices is smaller than the
                    number of non-zeros in the current $Q$ matrices.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CANNOT_HANDLE_NL" val="2506">
   <cmnt>A function cannot handle a task with nonlinear function call-backs.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_BASIS_SOL" val="1600">
   <cmnt>No basic solution is defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ORD_INVALID" val="1131">
   <cmnt>Invalid content in branch ordering file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_REP_VAR" val="1303">
   <cmnt>A variable is included multiple times in the cone.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_OBJ_NAME" val="1075">
   <cmnt>An invalid objective name is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_OPEN" val="1052">
   <cmnt>Error while opening a file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_IGNORE_INTEGER" val="250">
   <cmnt>Ignored integer constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OBJ_Q_NOT_NSD" val="1296">
   <cmnt>The quadratic coefficient matrix in the objective is not negative semi-definite as expected for a maximization problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_TASK" val="1064">
   <cmnt>The \texttt{task} is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NULL_POINTER" val="1065">
   <cmnt>An argument to a function is unexpectedly a NULL pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONCURRENT_OPTIMIZER" val="3059">
   <cmnt>An unsupported optimizer was chosen for use with the concurrent optimizer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_FATAL_ERROR" val="3005">
   <cmnt>An internal error occurred in the API. Please report this problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_OPTIMIZER" val="1550">
   <cmnt>An invalid optimizer has been chosen for the problem. This
                    means that the simplex or the conic optimizer is chosen to
                    optimize a nonlinear problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_REMOVE_CONE_VARIABLE" val="1310">
   <cmnt>A variable cannot be removed because it will make a cone invalid.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_AIJ" val="62">
   <cmnt>A numerically large value is specified for an $a_{i,j}$ element in $A$.
                  The parameter \MSKitemtex{mosek:dparam:data_tol_aij_large} controls when an $a_{i,j}$ is considered large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME_STR" val="1208">
   <cmnt>The parameter name is not correct for a string parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_FEATURE" val="1018">
   <cmnt>A requested feature is not available in the license file(s). Most likely due to an incorrect license system setup.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NO_GLOBAL_OPTIMIZER" val="251">
   <cmnt>No global optimizer is available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LINK_FILE_DLL" val="1040">
   <cmnt>A file cannot be linked to a stream in the DLL version.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED" val="1701">
   <cmnt>The relaxed problem could not be solved to optimality. Please consult the log file for further details.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL" val="1221">
   <cmnt>An index in an array argument is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SOLVER_PROBTYPE" val="1259">
   <cmnt>Problem type does not match the chosen optimizer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_INT_INDEX" val="1220">
   <cmnt>An integer information index is out of range for the specified type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_READ" val="1053">
   <cmnt>File read error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_NLO_EVAL_HESSUBI" val="1440">
   <cmnt>The user-defined nonlinear function reported an invalid subscript in the Hessian.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_NLO_EVAL_HESSUBJ" val="1441">
   <cmnt>The user-defined nonlinear function reported an invalid subscript in the Hessian.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SOL_FILTER" val="300">
   <cmnt>Invalid solution filter is specified.</cmnt>
  </c>
  <c name="MSK_RES_TRM_INTERNAL" val="4030">
   <cmnt>The optimizer terminated due to some internal reason. Please contact \mosek{} support.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NO_OBJECTIVE" val="1110">
   <cmnt>No objective is defined in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QOBJ_VAL" val="1403">
   <cmnt>Invalid value in \comp{qoval}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INFINITE_BOUND" val="1400">
   <cmnt>A numerically huge bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPEN_DL" val="1030">
   <cmnt>A dynamic link library could not be opened.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_ARRAY_TOO_SMALL" val="3001">
   <cmnt>An input array was too short.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_MUTEX_LOCK" val="1046">
   <cmnt>Could not lock a mutex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAST" val="1262">
   <cmnt>Invalid index \comp{last}. A given index was out of expected range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_EMPTY" val="1151">
   <cmnt>The problem cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_VAR" val="1011">
   <cmnt>The problem has too many variables to be solved with the available license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_STREAM" val="1062">
   <cmnt>An invalid stream is referenced.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CANNOT_CLONE_NL" val="2505">
   <cmnt>A task with a nonlinear function call-back cannot be cloned.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_ACCMODE" val="2520">
   <cmnt>An invalid access mode is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NUMCONLIM" val="1250">
   <cmnt>Maximum number of constraints limit is exceeded.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MBT_INCOMPATIBLE" val="2550">
   <cmnt>The MBT file is incompatible with this platform. This results from reading a file on a 32 bit platform generated on a 64 bit platform.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NULL_VAR_NAME" val="1104">
   <cmnt>An empty variable name is used in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR" val="72">
   <cmnt>A BOUNDS vector is split into several nonadjacent parts in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_SERVER_VERSION" val="1026">
   <cmnt>The version specified in the checkout request is greater than the highest version number the daemon supports.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_INVALID_HOSTID" val="1025">
   <cmnt>The host ID specified in the license file does not match the host ID of the computer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_MUTEX_INIT" val="1045">
   <cmnt>Could not initialize a mutex.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_CON_FX" val="54">
   <cmnt>An equality constraint is fixed to a numerically large value. This can cause numerical problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_NAME_ITEM" val="1280">
   <cmnt>An invalid name item code is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_MISSING_RETURN" val="3106">
   <cmnt>The code list data was invalid. Missing return operation in function.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_UP_BOUND" val="53">
   <cmnt>A numerically large upper bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INFEAS_UNDEFINED" val="3910">
   <cmnt>The requested value is not defined for this solution type.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_C_ZERO" val="901">
   <cmnt>This warning is issued by the problem analyzer, if the coefficients in the linear part of the objective are all zero.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_CON_NAME" val="1112">
   <cmnt>A constraint name was specified multiple times in the \comp{ROWS} section.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_IOMODE" val="1801">
   <cmnt>Invalid io mode.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_SEC_ORDER" val="1115">
   <cmnt>The sections in the MPS data file
                    are not in the correct order.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_MAX" val="1016">
   <cmnt>Maximum number of licenses is reached.</cmnt>
  </c>
  <c name="MSK_RES_TRM_USER_CALLBACK" val="4007">
   <cmnt>The optimizer terminated due to the return of
                    the user-defined call-back function.</cmnt>
  </c>
  <c name="MSK_RES_WRN_CONSTRUCT_SOLUTION_INFEAS" val="805">
   <cmnt>After fixing the integer variables at the suggested values then the problem is infeasible.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_MBT_FILE" val="1058">
   <cmnt>A \mosek{} binary task file is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CON_Q_NOT_NSD" val="1294">
   <cmnt>The quadratic constraint matrix is not negative semi-definite as expected for a constraint with finite lower bound. This results in a nonconvex problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE" val="3600">
   <cmnt>The problem type is not supported by the XML format.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_INT_NAME" val="1231">
   <cmnt>An integer information name is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_CON_KEY" val="1107">
   <cmnt>An invalid constraint key occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIXED_BOUND_VALUES" val="1425">
   <cmnt>A fixed constraint/variable has been specified using the bound keys but the numerical value of the lower and upper 
                    bound is different.</cmnt>
  </c>
  <c name="MSK_RES_TRM_NUMERICAL_PROBLEM" val="4025">
   <cmnt>The optimizer terminated due to numerical problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_INVALID_REGEXP" val="3056">
   <cmnt>Syntax error in regexp or regexp longer than 1024.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_LO_BOUND" val="52">
   <cmnt>A numerically large lower bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_INTERNAL" val="3999">
   <cmnt>An internal fatal error occurred in an interface function.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR" val="70">
   <cmnt>An RHS vector is split into several nonadjacent parts in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_BOUND_INVALID_UP" val="3053">
   <cmnt>Analysis of upper bound requested for an index, where no upper bound exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND" val="1702">
   <cmnt>The upper bound is less than the lower bound for a variable or a constraint.
                    %A ranged constraint on a bound or variable has a lower bound that is larger than its upper bound. 
                    Please correct this before running the feasibility repair.</cmnt>
  </c>
  <c name="MSK_RES_ERR_Y_IS_UNDEFINED" val="1449">
   <cmnt>The solution item $y$ is undefined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_BRANCH_DIRECTION" val="3200">
   <cmnt>An invalid branching direction is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_FUNC_RET" val="1430">
   <cmnt>An user function reported an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAME_MAX_LEN" val="1750">
   <cmnt>A name is longer than the buffer that is supposed to hold it.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_TYPE" val="1305">
   <cmnt>Invalid cone type specified.</cmnt>
  </c>
  <c name="MSK_RES_TRM_USER_BREAK" val="4005">
   <cmnt>Not in use.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_BKC" val="1256">
   <cmnt>Invalid bound key is specified for a constraint.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MAX_NUM_SETBACKS" val="4020">
   <cmnt>The optimizer terminated as the maximum number of set-backs was reached.
                    This indicates
                    % serious 
                    numerical problems and a possibly badly formulated problem.</cmnt>
  </c>
  <c name="MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS" val="4015">
   <cmnt>The mixed-integer optimizer terminated as the maximum number of feasible solutions was reached.</cmnt>
  </c>
  <c name="MSK_RES_ERR_IDENTICAL_TASKS" val="3101">
   <cmnt>Some tasks related to this function call were identical. Unique tasks were expected.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE" val="1020">
   <cmnt>The license system cannot allocate the memory required.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS" val="904">
   <cmnt>This warning is issued by the problem analyzer if a
                    constraint is bound nearly integral.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QOBJ_SUBJ" val="1402">
   <cmnt>Invalid value in \comp{qosubj}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_OVERLAP" val="1302">
   <cmnt>A new cone which variables overlap with an existing cone has been specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_CONSTRUCT_INVALID_SOL_ITG" val="807">
   <cmnt>The intial value for one or more  of the integer variables is not feasible.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QOBJ_SUBI" val="1401">
   <cmnt>Invalid value in \comp{qosubi}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_MPS_INVALID_NAME" val="1153">
   <cmnt>An invalid name is created while writing an MPS file. Usually this will make the MPS file unreadable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_NOT_LOADED" val="1553">
   <cmnt>The mixed-integer optimizer is not loaded.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NULL_TASK" val="1061">
   <cmnt>\comp{task} is a NULL pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BLANK_NAME" val="1070">
   <cmnt>An all blank name has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOO_SMALL_MAXNUMANZ" val="1252">
   <cmnt>The maximum number of non-zeros specified for $A$ is smaller than the
                    number of non-zeros in the current $A$.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_LENNEQ" val="1197">
   <cmnt>Incorrect length of arguments.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LICENSE_EXPIRE" val="500">
   <cmnt>The license expires.</cmnt>
  </c>
  <c name="MSK_RES_ERR_IN_ARGUMENT" val="1200">
   <cmnt>A function argument is incorrect.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SPACE" val="1051">
   <cmnt>Out of space.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMVAR" val="1241">
   <cmnt>The maximum number of variables specified is smaller than the number of
                    variables in the task.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_COMPRESSION" val="1800">
   <cmnt>Invalid compression type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_FIELD" val="1101">
   <cmnt>A field in the MPS file is invalid. Probably it is too wide.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NULL_ENV" val="1060">
   <cmnt>\comp{env} is a NULL pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INTERNAL_TEST_FAILED" val="3500">
   <cmnt>An internal unit test function failed.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LICENSE_SERVER" val="501">
   <cmnt>The license server is not responding.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INVALID_OBJSENSE" val="1122">
   <cmnt>An invalid objective sense is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPF_FORMAT" val="1168">
   <cmnt>Syntax error in an OPF file</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_LARGE_BOUNDS" val="900">
   <cmnt>This warning is issued by the problem analyzer, if one or more constraint or variable bounds are very large.  
                    One should consider omitting these bounds entirely by setting them to +inf or -inf.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUP_NAME" val="1071">
   <cmnt>The same name was used multiple times for the same problem item type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_CSEC" val="1116">
   <cmnt>Multiple \comp{CSECTION}s are given the same name.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_BOUND" val="51">
   <cmnt>A numerically large bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_OPEN_PARAM_FILE" val="50">
   <cmnt>The parameter file could not be opened.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONCONVEX" val="1291">
   <cmnt>The optimization problem is nonconvex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNB_STEP_SIZE" val="3100">
   <cmnt>A step size in an optimizer was unexpectedly unbounded. For
                    instance, if the step-size becomes unbounded in phase 1 of
                    the simplex algorithm then an error occurs.  Normally this
                    will happen only if the problem is badly formulated. Please
                    contact \mosek{} support if this error occurs.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BASIS_SINGULAR" val="1615">
   <cmnt>The basis is singular and hence cannot be factored.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_FREE_CONSTRAINT" val="1155">
   <cmnt>Free constraints cannot be written in LP file format.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_OBJECTIVE_SENSE" val="1445">
   <cmnt>An invalid objective sense is specified.</cmnt>
  </c>
  <c name="MSK_RES_OK" val="0">
   <cmnt>No error occurred.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_CB_CONNECT" val="3002">
   <cmnt>Failed to connect a callback object.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_APTRE" val="1253">
   <cmnt>\comp{aptre[j]} is strictly smaller than \comp{aptrb[j]} for some \comp{j}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPTIMIZER_LICENSE" val="1013">
   <cmnt>The optimizer required is not licensed.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_LICENSE" val="1007">
   <cmnt>Invalid license file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_FORMAT" val="1160">
   <cmnt>Syntax error in an LP file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SOLITEM" val="1237">
   <cmnt>The solution item number \comp{solitem} is invalid. Please note that \MSKitemtex{mosek:solitem:snx}
                    is invalid for the basic solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_CON" val="1010">
   <cmnt>The problem has too many constraints to be solved with the available license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_CONE_OVERLAP" val="1118">
   <cmnt>A variable is specified to be a member of several cones.</cmnt>
  </c>
  <c name="MSK_RES_ERR_READ_FORMAT" val="1090">
   <cmnt>The specified format cannot be read.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QCON_SUBI_TOO_SMALL" val="1408">
   <cmnt>Invalid value in \comp{qcsubi}.</cmnt>
  </c>
  <c name="MSK_RES_TRM_STALL" val="4006">
   <cmnt>The optimizer terminated due to slow progress. The most likely reason causing slow progress is that the problem is badly formulated
                    e.g. badly scaly scaled of near infeasible. Sometimes a few dense columns in the constraint matrix can also lead to numerical problems that causes a stall.

                    The solution returned may or may not be of acceptable quality. Therefore, the solution status should be examined to determine the status of the solution. 
                    If the solution is near optimal, then for most practical purposes the solution will be good enough.
                    
                    In particular, if a linear optimization problem is solved
                    with the interior-point optimizer with basis identification
                    turned on, the returned solution may be of acceptable
                    quality, even in the optimizer stalled.</cmnt>
  </c>
  <c name="MSK_RES_ERR_POSTSOLVE" val="1580">
   <cmnt>An error occurred during the postsolve. Please contact \mosek{} support.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_IS_TOO_LARGE" val="1215">
   <cmnt>The parameter value is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_WRITE_GECO_PROBLEM" val="1164">
   <cmnt>The problem contains general convex terms that cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PRO_ITEM" val="1281">
   <cmnt>An invalid problem is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_SOL_FILE_NAME" val="1057">
   <cmnt>An invalid file name has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_CONE_TYPE_STR" val="1271">
   <cmnt>Invalid cone type string encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FORMAT_TYPE" val="1283">
   <cmnt>Invalid format type.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_CJ" val="57">
   <cmnt>A numerically large value is specified for one $c_{j}$.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OLDER_DLL" val="1035">
   <cmnt>The dynamic link library is older than the specified version.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PLATFORM_NOT_LICENSED" val="1019">
   <cmnt>A requested license feature is not available for the required platform.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_CONE_REPEAT" val="1119">
   <cmnt>A variable is repeated within the \comp{CSECTION}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_UNDEF_NAME" val="3051">
   <cmnt>An undefined name was encountered in the sensitivity analysis file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_HUGE_AIJ" val="1380">
   <cmnt>A numerically huge value is specified for an
                  $a_{i,j}$ element in $A$.  The parameter
                  \MSKitemtex{mosek:dparam:data_tol_aij_huge} controls
                  when an $a_{i,j}$ is considered huge.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR" val="71">
   <cmnt>A RANGE vector is split into several nonadjacent parts in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_BOUND_INVALID_LO" val="3054">
   <cmnt>Analysis of lower bound requested for an index, where no lower bound exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_MISSING_OPERAND" val="3105">
   <cmnt>The code list data was invalid. Missing operand for operator.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_SPLITTED_VAR" val="1111">
   <cmnt>All elements in a column of the $A$ matrix must be specified consecutively. 
                       Hence, it is illegal to specify non-zero elements in $A$ for variable 1, then for variable 2 and then variable 1 again.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SPACE_LEAKING" val="1080">
   <cmnt>\mosek{} is leaking memory. This can be due to either an incorrect use of \mosek{} or a bug.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_DIMENSION" val="1201">
   <cmnt>A function argument is of incorrect dimension.</cmnt>
  </c>
  <c name="MSK_RES_ERR_READ_LP_MISSING_END_TAG" val="1159">
   <cmnt>Missing End tag in LP file.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MAX_TIME" val="4001">
   <cmnt>The optimizer terminated at the maximum amount of time.</cmnt>
  </c>
  <c name="MSK_RES_WRN_CONSTRUCT_NO_SOL_ITG" val="810">
   <cmnt>The construct solution requires an integer solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_AMPL_STUB" val="3700">
   <cmnt>Invalid AMPL stub.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OBJECTIVE_RANGE" val="1260">
   <cmnt>Empty objective range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WHICHITEM_NOT_ALLOWED" val="1238">
   <cmnt>\comp{whichitem} is unacceptable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BLX" val="1471">
   <cmnt>$l^x$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WHICHSOL" val="1236">
   <cmnt>The solution defined by comp{whichsol} does not exists.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ELIMINATOR_SPACE" val="801">
   <cmnt>The eliminator is skipped at least once due to lack of space.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_COND_INIT" val="1049">
   <cmnt>Could not initialize a condition.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SK_STR" val="1269">
   <cmnt>Invalid status key string encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NEWER_DLL" val="1036">
   <cmnt>The dynamic link library is newer than the specified version.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NUMVARLIM" val="1251">
   <cmnt>Maximum number of variables limit is exceeded.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_QSEC" val="1113">
   <cmnt>Multiple \comp{QSECTION}s are specified
                    for a constraint in the MPS data file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_EMPTY_NAME" val="502">
   <cmnt>A variable or constraint name is empty. The output file may be invalid.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NEAR_REL_GAP" val="4003">
   <cmnt>The mixed-integer optimizer terminated because the near optimal relative gap tolerance was satisfied.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LP_OLD_QUAD_FORMAT" val="80">
   <cmnt>Missing '/2' after quadratic expressions in bound or objective.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_CONE_TYPE" val="1272">
   <cmnt>Invalid cone type code is encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_MARKER" val="1102">
   <cmnt>An invalid marker has been specified in the MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_DOU_NAME" val="1230">
   <cmnt>A double information name is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NEGATIVE_APPEND" val="1264">
   <cmnt>Cannot append a negative number.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SK" val="1270">
   <cmnt>Invalid status key code.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PROB_LICENSE" val="1006">
   <cmnt>The software is not licensed to solve the problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_INVALID_OPERAND" val="3104">
   <cmnt>The code list data was invalid. An unknown operand was used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_SERVER" val="1015">
   <cmnt>The license server is not responding.</cmnt>
  </c>
  <c name="MSK_RES_WRN_TOO_FEW_BASIS_VARS" val="400">
   <cmnt>An incomplete basis has been specified. Too few basis variables are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_LP_NON_UNIQUE_NAME" val="1161">
   <cmnt>An auto-generated name is not unique.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_BOUND_KEY" val="1108">
   <cmnt>An invalid bound key occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BUX" val="1472">
   <cmnt>$u^x$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_DOUBLE_DATA" val="1450">
   <cmnt>An invalid floating point value was used in some double data.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_SEC_NAME" val="1109">
   <cmnt>An invalid section name occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BASIS" val="1266">
   <cmnt>An invalid basis is specified. Either
                    too many or too few basis variables are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_BKX" val="1257">
   <cmnt>An invalid bound key is specified for a variable.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SOL_FILE_IGNORED_CON" val="351">
   <cmnt>One or more lines in the constraint section were ignored when reading a solution file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_EMPTY_COLS" val="902">
   <cmnt>This warning is issued by the problem analyzer, if columns, in which all coefficients are zero, are found.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INVALID_OBJ_NAME" val="1128">
   <cmnt>An invalid objective name is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_VALUE_STR" val="1217">
   <cmnt>The parameter value string is incorrect.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE" val="1222">
   <cmnt>An index in an array argument is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_TYPE_STR" val="1306">
   <cmnt>Invalid cone type specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_SUBI" val="1405">
   <cmnt>Invalid value in \comp{qcsubi}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAME_IS_NULL" val="1760">
   <cmnt>The name buffer is a NULL pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_VAR_TYPE" val="1258">
   <cmnt>An invalid variable type is specified for a variable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_FILE_FORMAT" val="1157">
   <cmnt>Syntax error in an LP file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_CANNOT_CONNECT" val="1021">
   <cmnt>\mosek{} cannot connect to the license server.
                    Most likely the license server is not up and running.</cmnt>
  </c>
  <c name="MSK_RES_TRM_OBJECTIVE_RANGE" val="4002">
   <cmnt>The optimizer terminated on the bound of the objective range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_TAB_IN_FIELD3" val="1126">
   <cmnt>A tab char occurred in field 3.</cmnt>
  </c>
  <c name="MSK_RES_WRN_UNDEF_SOL_FILE_NAME" val="350">
   <cmnt>Undefined name occurred in a solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_BK" val="1255">
   <cmnt>Invalid bound key.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPF_NEW_VARIABLE" val="1169">
   <cmnt>Introducing new variables is now allowed. When a \comp{[variables]} section is present, it is not allowed to introduce new variables later in the problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FLEXLM" val="1014">
   <cmnt>The FLEXlm license manager reported an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_SURPLUS" val="1275">
   <cmnt>Invalid surplus.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NAME_MAX_LEN" val="65">
   <cmnt>A name is longer than the buffer that is supposed to hold it.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_SIZE" val="1301">
   <cmnt>A cone with too few members is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIRST" val="1261">
   <cmnt>Invalid \comp{first}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_AIJ" val="1473">
   <cmnt>$a_{i,j}$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_TRM_INTERNAL_STOP" val="4031">
   <cmnt>The optimizer terminated for internal reasons. Please contact \mosek{} support.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_CONE_TYPE" val="1117">
   <cmnt>Invalid cone type specified in a \comp{CSECTION}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE" val="1005">
   <cmnt>The problem is bigger than the license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QCON_SUBI_TOO_LARGE" val="1409">
   <cmnt>Invalid value in \comp{qcsubi}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_HUGE_C" val="1375">
   <cmnt>A huge value in absolute size is specified for one $c_{j}$.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE" val="1446">
   <cmnt>The objective sense has not been specified before the optimization.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MAX_ITERATIONS" val="4000">
   <cmnt>The optimizer terminated at the maximum number of iterations.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PRESOLVE_OUTOFSPACE" val="802">
   <cmnt>The presolve is incomplete due to lack of space.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ORD_INVALID_BRANCH_DIR" val="1130">
   <cmnt>An invalid branch direction key is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_INVALID_OPERATOR" val="3103">
   <cmnt>The code list data was invalid. An unknown operator was used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITING_FILE" val="1166">
   <cmnt>An error occurred while writing file</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_MARKJ" val="2502">
   <cmnt>Invalid value in markj.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK" val="2500">
   <cmnt>The required solution is not available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_UTF8" val="2900">
   <cmnt>An invalid UTF8 string is encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_UNDEF_CON_NAME" val="1105">
   <cmnt>An undefined constraint name occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_INTVAR" val="1012">
   <cmnt>The problem contains too many integer variables to be solved with the available license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INT64_TO_INT32_CAST" val="3800">
   <cmnt>An 32 bit integer could not cast to a 64 bit integer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE" val="1552">
   <cmnt>No optimizer is available for this class of optimization problems.</cmnt>
  </c>
 </sec>
 <sec id="MSKmionodeseltypee" type="constants">
  <c name="MSK_MIO_NODE_SELECTION_PSEUDO" val="5">
   <cmnt>The optimizer employs selects the node based on a pseudo cost estimate.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_HYBRID" val="4">
   <cmnt>The optimizer employs a hybrid strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_FREE" val="0">
   <cmnt>The optimizer decides the node selection strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_WORST" val="3">
   <cmnt>The optimizer employs a worst bound node selection strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_BEST" val="2">
   <cmnt>The optimizer employs a best bound node selection strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_FIRST" val="1">
   <cmnt>The optimizer employs a depth first node selection strategy.</cmnt>
  </c>
 </sec>
 <sec id="MSKonoffkeye" type="constants">
  <c name="MSK_ON" val="1">
   <cmnt>Switch the option on.</cmnt>
  </c>
  <c name="MSK_OFF" val="0">
   <cmnt>Switch the option off.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimdegene" type="enum">
  <c name="MSK_SIM_DEGEN_NONE" val="0">
   <cmnt>The simplex optimizer should use no degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_MODERATE" val="3">
   <cmnt>The simplex optimizer should use a moderate degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_MINIMUM" val="4">
   <cmnt>The simplex optimizer should use a minimum degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_AGGRESSIVE" val="2">
   <cmnt>The simplex optimizer should use an aggressive degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_FREE" val="1">
   <cmnt>The simplex optimizer chooses the degeneration strategy.</cmnt>
  </c>
 </sec>
 <sec id="MSKdataformate" type="constants">
  <c name="MSK_DATA_FORMAT_XML" val="5">
   <cmnt>The data file is an XML formatted file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_FREE_MPS" val="6">
   <cmnt>The data data a free MPS formatted file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_EXTENSION" val="0">
   <cmnt>The file extension is used to determine the data file format.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_MPS" val="1">
   <cmnt>The data file is MPS formatted.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_LP" val="2">
   <cmnt>The data file is LP formatted.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_MBT" val="3">
   <cmnt>The data file is a \mosek{} binary task file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_OP" val="4">
   <cmnt>The data file is an optimization problem formatted file.</cmnt>
  </c>
 </sec>
 <sec id="MSKorderingtypee" type="constants">
  <c name="MSK_ORDER_METHOD_NONE" val="5">
   <cmnt>No ordering is used.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_APPMINLOC2" val="2">
   <cmnt>A variant of the approximate minimum local-fill-in
                    ordering is used.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_APPMINLOC1" val="1">
   <cmnt>Approximate minimum local-fill-in  ordering is used.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_GRAPHPAR2" val="4">
   <cmnt>An alternative graph partitioning based ordering.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_FREE" val="0">
   <cmnt>The ordering method is chosen automatically.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_GRAPHPAR1" val="3">
   <cmnt>Graph partitioning based ordering.</cmnt>
  </c>
 </sec>
 <sec id="MSKproblemtypee" type="enum">
  <c name="MSK_PROBTYPE_QCQO" val="2">
   <cmnt>The problem is a quadratically constrained optimization problem.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_LO" val="0">
   <cmnt>The problem is
a linear optimization problem.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_CONIC" val="4">
   <cmnt>A conic optimization.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_GECO" val="3">
   <cmnt>General convex optimization.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_MIXED" val="5">
   <cmnt>General nonlinear constraints and conic constraints. This combination can not be solved by \mosek{}.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_QO" val="1">
   <cmnt>The problem is a quadratic optimization problem.</cmnt>
  </c>
 </sec>
 <sec id="MSKinftypee" type="enum">
  <c name="MSK_INF_DOU_TYPE" val="0">
   <cmnt>Is a double information type.</cmnt>
  </c>
  <c name="MSK_INF_LINT_TYPE" val="2">
   <cmnt>Is a long integer.</cmnt>
  </c>
  <c name="MSK_INF_INT_TYPE" val="1">
   <cmnt>Is an integer.</cmnt>
  </c>
 </sec>
 <sec id="MSKpresolvemodee" type="constants">
  <c name="MSK_PRESOLVE_MODE_ON" val="1">
   <cmnt>The problem is presolved before it is optimized.</cmnt>
  </c>
  <c name="MSK_PRESOLVE_MODE_OFF" val="0">
   <cmnt>The problem is not presolved before it is optimized.</cmnt>
  </c>
  <c name="MSK_PRESOLVE_MODE_FREE" val="2">
   <cmnt>It is decided automatically whether to presolve before the problem is optimized.</cmnt>
  </c>
 </sec>
 <sec id="MSKdparame" type="parameters">
  <p name="MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH" val="40">
   <cmnt>If the lower objective cut is less than the value of this parameter value,
                    then the lower objective cut i.e. \MSKitemtex{mosek:dparam:lower_obj_cut}
                    is treated as $-\infty$.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-0.5e30</default>
  </p>
  <p name="MSK_DPAR_MIO_MAX_TIME" val="43">
   <cmnt>This parameter limits the maximum time spent by the mixed-integer optimizer.
                    A negative number means infinity.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_BASIS_TOL_S" val="2">
   <cmnt>Maximum absolute dual bound violation in
                    an optimal basic solution.</cmnt>
   <lower_bound>1.0e-9</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_S" val="60">
   <cmnt>Absolute zero tolerance employed for $s_i$ in the presolve.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_UPPER_OBJ_CUT" val="65">
   <cmnt>If either a primal or dual feasible solution is found proving that the optimal  
                    objective value is outside,
                    [\MSKitemtex{mosek:dparam:lower_obj_cut}, \MSKitemtex{mosek:dparam:upper_obj_cut}],
                    then \mosek{} is terminated.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e30</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_DFEAS" val="16">
   <cmnt>Dual feasibility tolerance used by the conic interior-point optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_AIJ_LARGE" val="8">
   <cmnt>An element in $A$ which is larger
                    than this value in absolute size causes a
                    warning message to be printed.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e10</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_ABS_GAP" val="49">
   <cmnt>Absolute optimality tolerance employed by the mixed-integer optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0.0</default>
  </p>
  <p name="MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH" val="66">
   <cmnt>If the upper objective cut is greater than the value of this value parameter, then the
                    the upper objective cut \MSKitemtex{mosek:dparam:upper_obj_cut} is treated as $\infty$.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0.5e30</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_ABS_RELAX_INT" val="50">
   <cmnt>Absolute relaxation tolerance of the integer constraints. I.e.
                    $\min(|x|-\lfloor x \rfloor,\lceil x \rceil - |x|)$ is less than the tolerance
                    then the integer restrictions assumed to be satisfied.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-5</default>
  </p>
  <p name="MSK_DPAR_NONCONVEX_TOL_OPT" val="56">
   <cmnt>Optimality tolerance used by the nonconvex optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-7</default>
  </p>
  <p name="MSK_DPAR_NONCONVEX_TOL_FEAS" val="55">
   <cmnt>Feasibility tolerance used by the nonconvex optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_SIMPLEX_ABS_TOL_PIV" val="64">
   <cmnt>Absolute pivot tolerance employed by the simplex optimizers.</cmnt>
   <lower_bound>1.0e-12</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-7</default>
  </p>
  <p name="MSK_DPAR_MIO_HEURISTIC_TIME" val="42">
   <cmnt>Minimum amount of time to be used in the heuristic search for a good feasible integer solution.
                    A negative values implies that the optimizer decides the amount of time to be spent in the heuristic.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_CHECK_CONVEXITY_REL_TOL" val="5">
   <cmnt>This parameter controls when the full convexity check declares a problem to be non-convex.
                     Increasing this tolerance relaxes the criteria for declaring the problem non-convex.

                     A problem is declared non-convex if negative (positive) pivot elements are detected in the cholesky factor of a matrix
                     which is required to be PSD (NSD). This parameter controles how much this non-negativity requirement may be violated.

                     If $d_i$ is the pivot element for column $i$, then the matrix $Q$ is considered to not be PSD if:
                     \[
                         d_i \leq - |Q_{ii}| * \mathtt{check\_convexity\_rel\_tol}
                     \]</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1e-10</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_X" val="61">
   <cmnt>Absolute zero tolerance employed for $x_j$ in the presolve.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_MU_RED" val="24">
   <cmnt>Relative complementarity gap tolerance.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_MIO_NEAR_TOL_REL_GAP" val="46">
   <cmnt>The mixed-integer optimizer is terminated when this tolerance is satisfied.
                    This termination criteria is delayed. See \MSKitemtex{mosek:dparam:mio_disable_term_time} for details.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-3</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_AIJ" val="6">
   <cmnt>Absolute zero tolerance for elements in $A$. If any value $A_{ij}$ is smaller than this parameter in absolute terms MOSEK will treat the values as zero and generate a warning.</cmnt>
   <lower_bound>1.0e-16</lower_bound>
   <upper_bound>1.0e-6</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_FEASREPAIR_TOL" val="15">
   <cmnt>Tolerance for constraint enforcing upper bound on
                    sum of weighted violations in feasibility repair.</cmnt>
   <lower_bound>1.0e-16</lower_bound>
   <upper_bound>1.0e+16</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_DSAFE" val="30">
   <cmnt>Controls the initial dual starting point used by
                    the interior-point optimizer. If the interior-point optimizer
                    converges slowly.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_FEAS" val="51">
   <cmnt>Feasibility tolerance for mixed integer solver. Any solution with
                    maximum infeasibility below this value will be considered feasible.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-7</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_INFEAS" val="31">
   <cmnt>Controls when the optimizer declares the model
                    primal or dual infeasible. A small number means
                    the optimizer gets more conservative about
                    declaring the model infeasible.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_NEAR_REL" val="25">
   <cmnt>If the \mosek{} nonlinear interior-point optimizer
                    cannot compute a solution that has the prescribed
                    accuracy, then it will multiply the termination
                    tolerances with value of this parameter.  If the
                    solution then satisfies the termination criteria,
                    then the solution is denoted near optimal, near
                    feasible and so forth.</cmnt>
   <lower_bound>1.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000.0</default>
  </p>
  <p name="MSK_DPAR_OPTIMIZER_MAX_TIME" val="57">
   <cmnt>Maximum amount of time the optimizer is allowed to spent on the optimization.
                    A negative number means infinity.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_X" val="14">
   <cmnt>Zero tolerance for constraints and variables i.e.
                    if the distance between the lower and upper bound
                    is less than this value, then the lower and lower
                    bound is considered identical.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_ANA_SOL_INFEAS_TOL" val="0">
   <cmnt>If a constraint violates its bound with an amount larger than this value,
                   the constraint name, index and violation will be printed by the solution analyzer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>+1e-8</default>
  </p>
  <p name="MSK_DPAR_MIO_REL_ADD_CUT_LIMITED" val="47">
   <cmnt>Controls how many cuts the mixed-integer optimizer is
                    allowed to add to the problem.  Let $\alpha$ be the value
                    of this parameter and $m$ the number constraints, then
                    mixed-integer optimizer is allowed to $\alpha m$ cuts.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>2.0</upper_bound>
   <default>0.75</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_MU_RED" val="32">
   <cmnt>Relative complementarity gap tolerance.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-16</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_MU_RED" val="18">
   <cmnt>Relative complementarity gap tolerance feasibility
                    tolerance used by the conic interior-point
                    optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_REL_GAP" val="21">
   <cmnt>Relative gap termination tolerance used by the
                    conic interior-point optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_LOWER_OBJ_CUT" val="39">
   <cmnt>If either a primal or dual feasible solution is found proving that the optimal  
                    objective value is outside,
                    the interval [\MSKitemtex{mosek:dparam:lower_obj_cut}, \MSKitemtex{mosek:dparam:upper_obj_cut}],
                    then \mosek{} is terminated.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0e30</default>
  </p>
  <p name="MSK_DPAR_MIO_DISABLE_TERM_TIME" val="41">
   <cmnt>The termination criteria governed by
                    %   
                    \begin{itemize}
                       \item \MSKitemtex{mosek:iparam:mio_max_num_relaxs}
                       \item \MSKitemtex{mosek:iparam:mio_max_num_branches}
                       \item \MSKitemtex{mosek:dparam:mio_near_tol_abs_gap}
                       \item \MSKitemtex{mosek:dparam:mio_near_tol_rel_gap}
                    \end{itemize}
                    %
                    is disabled the first $n$ seconds. This parameter specifies the number $n$.
                    A negative value is identical to infinity i.e. the termination criteria are never checked.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_REL_STEP" val="37">
   <cmnt>Relative step size to the boundary
                    for linear and quadratic optimization problems.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>0.999999</upper_bound>
   <default>0.9999</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_X" val="54">
   <cmnt>Absolute solution tolerance used in mixed-integer optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_C_HUGE" val="11">
   <cmnt>An element in $c$ which is larger
                    than the value of this parameter  in absolute terms is considered
                    to be huge and generates an error.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e16</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_LIN_DEP" val="59">
   <cmnt>Controls when a constraint is determined to be
                    linearly dependent.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_SIM_LU_TOL_REL_PIV" val="63">
   <cmnt>Relative pivot tolerance employed when computing the LU factorization 
                    of the basis in the simplex optimizers and in the basis identification procedure.

                    A value closer to $1.0$ generally improves numerical stability but typically also implies an
                    increase in the computational work.</cmnt>
   <lower_bound>1.0e-6</lower_bound>
   <upper_bound>0.999999</upper_bound>
   <default>0.01</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_CJ_LARGE" val="12">
   <cmnt>An element in $c$ which is larger
                    than this value in absolute terms causes a
                    warning message to be printed.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_REL_STEP" val="28">
   <cmnt>Relative step size to the boundary
                    for general nonlinear optimization problems.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>0.9999999</upper_bound>
   <default>0.995</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_STEP_SIZE" val="38">
   <cmnt>If the step size falls below the value of this parameter, then
                    the interior-point optimizer assumes that it is stalled. It it does not
                    not make any progress.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_PFEAS" val="34">
   <cmnt>Primal feasibility tolerance used for
                    linear and quadratic optimization problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_BASIS_REL_TOL_S" val="1">
   <cmnt>Maximum relative dual bound violation allowed in an optimal
                    basic solution.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_INFEAS" val="17">
   <cmnt>Controls when the conic interior-point optimizer declares
                    the model primal or dual infeasible. A small number means the optimizer
                    gets more conservative about declaring the model infeasible.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_MIO_REL_GAP_CONST" val="48">
   <cmnt>This value is used to compute the relative gap for the solution to an integer optimization problem.</cmnt>
   <lower_bound>1.0e-15</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_AIJ" val="58">
   <cmnt>Absolute zero tolerance employed for $a_{ij}$ in the presolve.</cmnt>
   <lower_bound>1.0e-15</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_MIO_MAX_TIME_APRX_OPT" val="44">
   <cmnt>Number of seconds spent by the mixed-integer optimizer before the
                    \MSKitemtex{mosek:dparam:mio_tol_rel_relax_int} is applied.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>60</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_PATH" val="33">
   <cmnt>Controls how close
                    the interior-point optimizer follows the central path. A large
                    value of this parameter means the central is
                    followed very closely. On numerical unstable
                    problems it may be worthwhile to increase this
                    parameter.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>0.9999</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_MERIT_BAL" val="22">
   <cmnt>Controls if the complementarity and infeasibility is converging to zero
                    at about equal rates.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>0.99</upper_bound>
   <default>1.0e-4</default>
  </p>
  <p name="MSK_DPAR_BASIS_TOL_X" val="3">
   <cmnt>Maximum absolute primal bound violation allowed
                    in an optimal basic solution.</cmnt>
   <lower_bound>1.0e-9</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_REL_GAP" val="36">
   <cmnt>Relative gap termination tolerance.</cmnt>
   <lower_bound>1.0e-14</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_AIJ_HUGE" val="7">
   <cmnt>An element in $A$ which is larger
                    than this value in absolute size causes an error.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e20</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_BOUND_WRN" val="10">
   <cmnt>If a bound value is larger than this value
                    in absolute size, then a warning message is issued.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e8</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_BOUND_INF" val="9">
   <cmnt>Any bound which in absolute value
                    is greater than this parameter is
                    considered infinite.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e16</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_PSAFE" val="35">
   <cmnt>Controls the initial primal starting point used by
                    the interior-point optimizer. If the interior-point optimizer
                    converges slowly and/or the constraint or variable bounds are very
                    large, then it may be worthwhile to increase this value.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_NEAR_REL" val="19">
   <cmnt>If \mosek{} cannot compute a solution that has the prescribed accuracy,
                    then it will multiply the termination tolerances with value of this parameter.
                    If the solution then satisfies the termination criteria, then the solution is denoted
                    near optimal, near feasible and so forth.</cmnt>
   <lower_bound>1.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_DPAR_CALLBACK_FREQ" val="4">
   <cmnt>Controls the time between calls to the progress call-back function.
                    Hence, if the value of this parameter is for example 10, then
                    the call-back is called approximately each 10 seconds. A negative
                    value is equivalent to infinity.
                    
                    In general frequent call-backs may hurt the performance.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_PFEAS" val="26">
   <cmnt>Primal feasibility tolerance used when a nonlinear
                    model is solved.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_DFEAS" val="23">
   <cmnt>Dual feasibility tolerance used when a nonlinear
                    model is solved.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_REL_GAP" val="52">
   <cmnt>Relative optimality tolerance employed by the mixed-integer optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-4</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_DFEAS" val="29">
   <cmnt>Dual feasibility tolerance used for
                    linear and quadratic optimization problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_MIO_NEAR_TOL_ABS_GAP" val="45">
   <cmnt>Relaxed absolute optimality tolerance employed by the mixed-integer optimizer.
                    This termination criteria is delayed. See \MSKitemtex{mosek:dparam:mio_disable_term_time} for details.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0.0</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_REL_RELAX_INT" val="53">
   <cmnt>Relative relaxation tolerance of the integer constraints. I.e
                    $(\min(|x|-\lfloor x \rfloor,\lceil x \rceil - |x|))$ is less than the tolerance times $|x|$
                    then the integer restrictions assumed to be satisfied.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL" val="62">
   <cmnt>This parameter determines when columns are dropped in incomplete cholesky factorization doing reformulation of quadratic problems.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1e-15</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_QIJ" val="13">
   <cmnt>Absolute zero tolerance for elements in
                    $Q$ matrices.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-16</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_REL_GAP" val="27">
   <cmnt>Relative gap termination tolerance for nonlinear problems.</cmnt>
   <lower_bound>1.0e-14</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_PFEAS" val="20">
   <cmnt>Primal feasibility tolerance used by the conic interior-point optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
 </sec>
 <sec id="MSKsimdupvece" type="enum">
  <c name="MSK_SIM_EXPLOIT_DUPVEC_ON" val="1">
   <cmnt>Allow the simplex optimizer to exploit duplicated columns.</cmnt>
  </c>
  <c name="MSK_SIM_EXPLOIT_DUPVEC_OFF" val="0">
   <cmnt>Disallow the simplex optimizer to exploit duplicated columns.</cmnt>
  </c>
  <c name="MSK_SIM_EXPLOIT_DUPVEC_FREE" val="2">
   <cmnt>The simplex optimizer can choose freely.</cmnt>
  </c>
 </sec>
 <sec id="MSKnetworkdetecte" type="constants">
  <c name="MSK_NETWORK_DETECT_SIMPLE" val="1">
   <cmnt>The network detection should use a very simple heuristic.</cmnt>
  </c>
  <c name="MSK_NETWORK_DETECT_ADVANCED" val="2">
   <cmnt>The network detection should use a more advanced heuristic.</cmnt>
  </c>
  <c name="MSK_NETWORK_DETECT_FREE" val="0">
   <cmnt>The network detection is free.</cmnt>
  </c>
 </sec>
 <sec id="MSKcompresstypee" type="constants">
  <c name="MSK_COMPRESS_GZIP" val="2">
   <cmnt>The type of compression used is gzip compatible.</cmnt>
  </c>
  <c name="MSK_COMPRESS_NONE" val="0">
   <cmnt>No compression is used.</cmnt>
  </c>
  <c name="MSK_COMPRESS_FREE" val="1">
   <cmnt>The type of compression used is chosen automatically.</cmnt>
  </c>
 </sec>
 <sec id="MSKmpsformate" type="constants">
  <c name="MSK_MPS_FORMAT_STRICT" val="0">
   <cmnt>It is assumed that the input file satisfies
                    the MPS format strictly.</cmnt>
  </c>
  <c name="MSK_MPS_FORMAT_RELAXED" val="1">
   <cmnt>It is assumed that the input file satisfies
                    a slightly relaxed version of the MPS format.</cmnt>
  </c>
  <c name="MSK_MPS_FORMAT_FREE" val="2">
   <cmnt>It is assumed that the input file satisfies the free
                    MPS format. This implies that spaces
                    are not allowed in names. Otherwise
                    the format is free.</cmnt>
  </c>
 </sec>
 <sec id="MSKvariabletypee" type="enum">
  <c name="MSK_VAR_TYPE_INT" val="1">
   <cmnt>Is an integer variable.</cmnt>
  </c>
  <c name="MSK_VAR_TYPE_CONT" val="0">
   <cmnt>Is a continuous variable.</cmnt>
  </c>
 </sec>
 <sec id="MSKcheckconvexitytypee" type="constants">
  <c name="MSK_CHECK_CONVEXITY_SIMPLE" val="1">
   <cmnt>Perform simple and fast convexity check.</cmnt>
  </c>
  <c name="MSK_CHECK_CONVEXITY_NONE" val="0">
   <cmnt>No convexity check.</cmnt>
  </c>
  <c name="MSK_CHECK_CONVEXITY_FULL" val="2">
   <cmnt>Perform a full convexity check.</cmnt>
  </c>
 </sec>
 <sec id="MSKlanguagee" type="enum">
  <c name="MSK_LANG_DAN" val="1">
   <cmnt>Danish language selection</cmnt>
  </c>
  <c name="MSK_LANG_ENG" val="0">
   <cmnt>English language selection</cmnt>
  </c>
 </sec>
 <sec id="MSKstartpointtypee" type="constants">
  <c name="MSK_STARTING_POINT_GUESS" val="1">
   <cmnt>The optimizer guesses a starting point.</cmnt>
  </c>
  <c name="MSK_STARTING_POINT_SATISFY_BOUNDS" val="3">
   <cmnt>The starting point is choosen to satisfy all the simple bounds on nonlinear variables. If this starting point is employed,
                    then more care than usual should employed when choosing the bounds on the nonlinear variables. In particular very tight bounds 
                    should be avoided.</cmnt>
  </c>
  <c name="MSK_STARTING_POINT_CONSTANT" val="2">
   <cmnt>The optimizer constructs a starting point by assigning a constant value to all primal and dual variables.
                    This starting point is normally robust.</cmnt>
  </c>
  <c name="MSK_STARTING_POINT_FREE" val="0">
   <cmnt>The starting point is chosen automatically.</cmnt>
  </c>
 </sec>
 <sec id="MSKsoltypee" type="enum">
  <c name="MSK_SOL_ITG" val="2">
   <cmnt>The integer solution.</cmnt>
  </c>
  <c name="MSK_SOL_ITR" val="0">
   <cmnt>The interior solution.</cmnt>
  </c>
  <c name="MSK_SOL_BAS" val="1">
   <cmnt>The basic solution.</cmnt>
  </c>
 </sec>
 <sec id="MSKscalingmethode" type="constants">
  <c name="MSK_SCALING_METHOD_POW2" val="0">
   <cmnt>Scales only with power of 2 leaving the mantissa untouched.</cmnt>
  </c>
  <c name="MSK_SCALING_METHOD_FREE" val="1">
   <cmnt>The optimizer chooses the scaling heuristic.</cmnt>
  </c>
 </sec>
 <sec id="MSKvaluee" type="constants">
  <c name="MSK_MAX_STR_LEN" val="1024">
   <cmnt>Maximum string length allowed in \mosek.</cmnt>
  </c>
  <c name="MSK_LICENSE_BUFFER_LENGTH" val="20">
   <cmnt>The length of a license key buffer.</cmnt>
  </c>
 </sec>
 <sec id="MSKstakeye" type="enum">
  <c name="MSK_SK_SUPBAS" val="2">
   <cmnt>The constraint or variable is super basic.</cmnt>
  </c>
  <c name="MSK_SK_BAS" val="1">
   <cmnt>The constraint or variable is in the basis.</cmnt>
  </c>
  <c name="MSK_SK_FIX" val="5">
   <cmnt>The constraint or variable is fixed.</cmnt>
  </c>
  <c name="MSK_SK_LOW" val="3">
   <cmnt>The constraint or variable is at its lower bound.</cmnt>
  </c>
  <c name="MSK_SK_INF" val="6">
   <cmnt>The constraint or variable is infeasible in the bounds.</cmnt>
  </c>
  <c name="MSK_SK_UNK" val="0">
   <cmnt>The status for the constraint or variable is unknown.</cmnt>
  </c>
  <c name="MSK_SK_UPR" val="4">
   <cmnt>The constraint or variable is at its upper bound.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimreforme" type="enum">
  <c name="MSK_SIM_REFORMULATION_ON" val="1">
   <cmnt>Allow the simplex optimizer to reformulate the problem.</cmnt>
  </c>
  <c name="MSK_SIM_REFORMULATION_AGGRESSIVE" val="3">
   <cmnt>The simplex optimizer should use an aggressive reformulation strategy.</cmnt>
  </c>
  <c name="MSK_SIM_REFORMULATION_OFF" val="0">
   <cmnt>Disallow the simplex optimizer to reformulate the problem.</cmnt>
  </c>
  <c name="MSK_SIM_REFORMULATION_FREE" val="2">
   <cmnt>The simplex optimizer can choose freely.</cmnt>
  </c>
 </sec>
 <sec id="MSKiinfiteme" type="enum">
  <c name="MSK_IINF_RD_NUMINTVAR" val="57">
   <cmnt>Number of integer-constrained variables read.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_BAS_SOLSTA" val="90">
   <cmnt>Solution status of the basic solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_STO_NUM_A_TRANSPOSES" val="97">
   <cmnt>Number of times the $A$ matrix is transposed. A large number
                    implies that \comp{maxnumanz} is too small or an inefficient usage of \mosek{}.
                    This will occur in particular if the code alternate between accessing rows and columns
                    of $A$.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_OBJ_CUTS" val="48">
   <cmnt>Number of obj cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_SOLVE_DUAL" val="88">
   <cmnt>Is non-zero if dual problem is solved.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMCON" val="30">
   <cmnt>Number of constraints in the problem solved be the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_OPT_NUMVAR" val="53">
   <cmnt>Number of variables in the problem solved when the optimizer is called</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NUMVAR" val="77">
   <cmnt>Number of variables in the problem solved by the simplex optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_LATTICE_CUTS" val="46">
   <cmnt>Number of lattice cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_DEG_ITER" val="71">
   <cmnt>The number of primal network degenerate iterations.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMQ" val="58">
   <cmnt>Number of nonempty Q matrices read.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON" val="0">
   <cmnt>Number of constraints in the problem. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_FACTOR_NUM_OFFCOL" val="19">
   <cmnt>Number of columns  in the constraint
                    matrix (or Jacobian) that has an
                    offending structure.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_INT" val="11">
   <cmnt>Number of general integer variables. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_INF_ITER" val="69">
   <cmnt>The number of iterations taken with dual infeasibility in the network optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_CONT" val="8">
   <cmnt>Number of continuous variables. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_ITER" val="65">
   <cmnt>Number of dual simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_DEG_ITER" val="61">
   <cmnt>The number of dual degenerate iterations.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_ITER" val="20">
   <cmnt>Number of interior-point iterations
                    since invoking the interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_KNAPSUR_COVER_CUTS" val="45">
   <cmnt>Number of knapsack cover cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_BASIS_CUTS" val="33">
   <cmnt>Number of basis cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NUMCON" val="76">
   <cmnt>Number of constraints in the problem solved by the simplex optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_ITER" val="83">
   <cmnt>Number of primal dual simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_UP" val="5">
   <cmnt>Number of constraints with an upper bound and an infinite lower bound. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_CLIQUE_CUTS" val="36">
   <cmnt>Number of clique cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_HOTSTART" val="80">
   <cmnt>If 1 then the primal dual simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_SOLVE_DUAL" val="22">
   <cmnt>Non-zero if the interior-point optimizer is solving the dual problem.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_HOTSTART" val="67">
   <cmnt>If 1 then the dual network simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_OPTIMIZE_RESPONSE" val="54">
   <cmnt>The reponse code returned by optimize.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITR_PROSTA" val="93">
   <cmnt>Problem status of the interior-point solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_RD_PROTYPE" val="60">
   <cmnt>Problem type.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITR_SOLSTA" val="94">
   <cmnt>Solution status of the interior-point solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_FR" val="2">
   <cmnt>Number of unbounded constraints. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_HOTSTART_LU" val="81">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the primal dual simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMINT" val="31">
   <cmnt>Number of integer variables in the problem solved be the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_CARDGUB_CUTS" val="35">
   <cmnt>Number of cardgub cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_CONTRA_CUTS" val="38">
   <cmnt>Number of contra cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_PLAN_LOC_CUTS" val="49">
   <cmnt>Number of loc cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_INF_ITER" val="64">
   <cmnt>The number of iterations taken with dual infeasibility.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMVAR" val="32">
   <cmnt>Number of variables in the problem solved be the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_CUTS" val="27">
   <cmnt>Number of cuts generated by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_CONSTRUCT_SOLUTION" val="23">
   <cmnt>If this item has the value 0, then \mosek{} did not try to construct an initial integer feasible solution.
                    If the item has a positive value, then \mosek{} successfully constructed an initial integer feasible solution.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR" val="6">
   <cmnt>Number of variables in the problem. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_STO_NUM_A_CACHE_FLUSHES" val="95">
   <cmnt>Number of times the cache of $A$ elements is flushed. A large number
                    implies that \comp{maxnumanz} is too small as well as an inefficient usage of \mosek{}.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_INT_PROSTA" val="91">
   <cmnt>Problem status of the integer solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_DEG_ITER" val="66">
   <cmnt>The number of dual network degenerate iterations.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_INT_SOLSTA" val="92">
   <cmnt>Solution status of the integer solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_CACHE_SIZE_L1" val="15">
   <cmnt>L1 cache size used.</cmnt>
  </c>
  <c name="MSK_IINF_CACHE_SIZE_L2" val="16">
   <cmnt>L2 cache size used.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMVAR" val="59">
   <cmnt>Number of variables read.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_DEG_ITER" val="79">
   <cmnt>The number of degenerate major iterations taken by the primal dual simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_LO" val="12">
   <cmnt>Number of variables with a lower bound and an
                  infinite upper bound. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_LIFT_CUTS" val="47">
   <cmnt>Number of lift cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_BAS_PROSTA" val="89">
   <cmnt>Problem status of the basic solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_ITER" val="75">
   <cmnt>Number of primal network simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_LO" val="3">
   <cmnt>Number of constraints with a lower bound and an
                  infinite upper bound. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_GUB_COVER_CUTS" val="44">
   <cmnt>Number of GUB cover cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_HOTSTART_LU" val="68">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the dual network simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_INF_ITER" val="74">
   <cmnt>The number of iterations taken with primal infeasibility in the network optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_HOTSTART" val="84">
   <cmnt>If 1 then the primal simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_BRANCH" val="26">
   <cmnt>Number of branches performed during the optimization.</cmnt>
  </c>
  <c name="MSK_IINF_STO_NUM_A_REALLOC" val="96">
   <cmnt>Number of times the storage for storing $A$ has been changed.
                    A large value may indicates that memory fragmentation may occur.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_RELAX" val="29">
   <cmnt>Number of relaxations solved during the optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_BRANCH" val="34">
   <cmnt>Number of branches performed during the optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_GCD_CUTS" val="42">
   <cmnt>Number of gcd cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_FLOW_COVER_CUTS" val="41">
   <cmnt>Number of flow cover cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_INT_SOLUTIONS" val="28">
   <cmnt>Number of integer feasible solutions that has been found.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_HOTSTART_LU" val="85">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the primal simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_CPU_TYPE" val="18">
   <cmnt>The type of cpu detected.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_EQ" val="1">
   <cmnt>Number of equality constraints. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_RA" val="13">
   <cmnt>Number of variables with finite lower and upper bounds. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_INF_ITER" val="86">
   <cmnt>The number of iterations taken with primal infeasibility.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMCON" val="55">
   <cmnt>Number of constraints read.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMCONE" val="56">
   <cmnt>Number of conic constraints read.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_FR" val="10">
   <cmnt>Number of free variables. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_ACTIVE_NODES" val="25">
   <cmnt>Number of active nodes in the branch and bound tree.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_RELAX" val="50">
   <cmnt>Number of relaxations solved during the optimization.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_BIN" val="7">
   <cmnt>Number of binary (0-1) variables. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_HOTSTART_LU" val="73">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the primal network simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_ITER" val="87">
   <cmnt>Number of primal simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_HOTSTART" val="62">
   <cmnt>If 1 then the dual simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_INITIAL_SOLUTION" val="24">
   <cmnt>Is non-zero if an initial integer solution is specified.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_NUM_THREADS" val="21">
   <cmnt>Number of threads that the interior-point optimizer is using.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_HOTSTART_LU" val="63">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the dual simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_UP" val="14">
   <cmnt>Number of variables with an upper bound and an infinite lower bound. This value is set by 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_ITER" val="70">
   <cmnt>Number of dual network simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_EQ" val="9">
   <cmnt>Number of fixed variables. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_CONCURRENT_FASTEST_OPTIMIZER" val="17">
   <cmnt>The type of the optimizer that finished first in a concurrent optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_USER_OBJ_CUT" val="51">
   <cmnt>If it is non-zero, then the objective cut is used.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_GOMORY_CUTS" val="43">
   <cmnt>Number of Gomory cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_HOTSTART" val="72">
   <cmnt>If 1 then the primal network simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_DISAGG_CUTS" val="40">
   <cmnt>Number of diasagg cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_COEF_REDC_CUTS" val="37">
   <cmnt>Number of coef. redc. cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_INF_ITER" val="82">
   <cmnt>The number of master iterations with dual infeasibility taken by the primal dual simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_RA" val="4">
   <cmnt>Number of constraints with finite lower and upper bounds. 
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \MSKfunctex{mosek:task:analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_CUTS" val="39">
   <cmnt>Total number of cuts generated by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_OPT_NUMCON" val="52">
   <cmnt>Number of constraints in the problem solved when the optimizer is called.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DEG_ITER" val="78">
   <cmnt>The number of primal degenerate iterations.</cmnt>
  </c>
 </sec>
 <sec id="MSKxmlwriteroutputtypee" type="enum">
  <c name="MSK_WRITE_XML_MODE_COL" val="1">
   <cmnt>Write in column order.</cmnt>
  </c>
  <c name="MSK_WRITE_XML_MODE_ROW" val="0">
   <cmnt>Write in row order.</cmnt>
  </c>
 </sec>
 <sec id="MSKoptimizertypee" type="constants">
  <c name="MSK_OPTIMIZER_INTPNT" val="1">
   <cmnt>The interior-point optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_CONCURRENT" val="10">
   <cmnt>The optimizer for nonconvex nonlinear problems.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_MIXED_INT" val="8">
   <cmnt>The mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_DUAL_SIMPLEX" val="5">
   <cmnt>The dual simplex optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_FREE" val="0">
   <cmnt>The optimizer is chosen automatically.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX" val="6">
   <cmnt>The primal dual simplex optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_CONIC" val="2">
   <cmnt>The optimizer for problems having conic constraints.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_NONCONVEX" val="9">
   <cmnt>The optimizer for nonconvex nonlinear problems.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_QCONE" val="3">
   <cmnt>For internal use only.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_PRIMAL_SIMPLEX" val="4">
   <cmnt>The primal simplex optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_FREE_SIMPLEX" val="7">
   <cmnt>One of the simplex optimizers is used.</cmnt>
  </c>
 </sec>
 <sec id="MSKcputypee" type="constants">
  <c name="MSK_CPU_POWERPC_G5" val="8">
   <cmnt>A G5 PowerPC CPU.</cmnt>
  </c>
  <c name="MSK_CPU_INTEL_PM" val="9">
   <cmnt>An Intel PM cpu.</cmnt>
  </c>
  <c name="MSK_CPU_GENERIC" val="1">
   <cmnt>An generic CPU type for the platform</cmnt>
  </c>
  <c name="MSK_CPU_UNKNOWN" val="0">
   <cmnt>An unknown CPU.</cmnt>
  </c>
  <c name="MSK_CPU_AMD_OPTERON" val="7">
   <cmnt>An AMD Opteron (64 bit).</cmnt>
  </c>
  <c name="MSK_CPU_INTEL_ITANIUM2" val="6">
   <cmnt>An Intel Itanium2.</cmnt>
  </c>
  <c name="MSK_CPU_AMD_ATHLON" val="4">
   <cmnt>An AMD Athlon.</cmnt>
  </c>
  <c name="MSK_CPU_HP_PARISC20" val="5">
   <cmnt>An HP PA RISC version 2.0 CPU.</cmnt>
  </c>
  <c name="MSK_CPU_INTEL_P4" val="3">
   <cmnt>An Intel Pentium P4 or Intel Xeon.</cmnt>
  </c>
  <c name="MSK_CPU_INTEL_P3" val="2">
   <cmnt>An Intel Pentium P3.</cmnt>
  </c>
  <c name="MSK_CPU_INTEL_CORE2" val="10">
   <cmnt>An Intel CORE2 cpu.</cmnt>
  </c>
 </sec>
 <sec id="MSKmiocontsoltypee" type="constants">
  <c name="MSK_MIO_CONT_SOL_ITG" val="2">
   <cmnt>The reported interior-point and basic solutions are
                    a solution to the problem with all integer variables
                    fixed at the value they have in the integer solution.
                    A solution is only reported in case the
                    problem has a primal feasible solution.</cmnt>
  </c>
  <c name="MSK_MIO_CONT_SOL_NONE" val="0">
   <cmnt>No interior-point or basic solution are reported when the mixed-integer optimizer is used.</cmnt>
  </c>
  <c name="MSK_MIO_CONT_SOL_ROOT" val="1">
   <cmnt>The reported interior-point and basic solutions are a solution to the root node problem
                    when mixed-integer optimizer is used.</cmnt>
  </c>
  <c name="MSK_MIO_CONT_SOL_ITG_REL" val="3">
   <cmnt>In case the problem is primal feasible
                    then the reported interior-point and basic solutions
                    are a solution to the problem with all integer variables
                    fixed at the value they have in the integer solution.
                    If the problem is primal infeasible, then the solution to the root node problem is reported.</cmnt>
  </c>
 </sec>
</constlist>
</mosekvalues>
