<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>15. API reference</title>
<!-- pyLaTeX: XHTML.lib.Sectioning.chapter -->
<link href="styles/style.css" rel="stylesheet"/>
<link href="styles/gstyles.css" rel="stylesheet"/>
<link href="graphics/favicon.png" rel="shortcut icon"/>
</head>
<body>
<div class="navigationarea">
<table class="navigation" width="100%" cellpadding="0" cellspacing="2">
<tbody><tr>
<td><a href="node016.html" target="_self"><img src="graphics/previous.png" class="navbutton-previous" alt="Previous : 14. Using MOSEK from Microsoft Solver Foundation" border="0"/></a></td>
<td><a href="index.html" target="_self"><img src="graphics/up.png" class="navbutton-up" alt="Up:  The MOSEK .NET API manual. 
Version 6.0 (Revision 137)." border="0"/></a></td>
<td><a href="node018.html" target="_self"><img src="graphics/next.png" class="navbutton-next" alt="Next:  16. Parameter reference" border="0"/></a></td>
<td align="center" class="navtitle">The MOSEK .NET API manual. 
<br/>Version 6.0 (Revision 137).</td>
<td><a href="index.html"><img src="graphics/contents.png" class="navbutton-contents" alt="" border="0"/></a></td>
<td><a href="node030.html"><img src="graphics/index.png" class="navbutton-index" alt="" border="0"/></a></td></tr>
</tbody>
</table>


<table class="trail"><tr>
<td valign="top"><b>Previous : </b><a href="node016.html" target="_self">14. Using MOSEK from Microsoft Solver Foundation</a></td>
<td valign="top"><b>Up : </b><a href="index.html" target="_self">The MOSEK .NET API manual. 
<br/>Version 6.0 (Revision 137).</a></td>
<td valign="top"><b>Next : </b><a href="node018.html" target="_self">16. Parameter reference</a></td>
<td valign="top"><a href="index.html" target="_self"><b>Contents</b></a></td>
<td valign="top"><a href="node030.html"><b>Index</b></a></td></tr></table>

<hr/>
</div>

<div>
<h1><a name="238807520">15. API reference</a></h1>

<div class="contents">
<ul class="toc-level-1">
<li><a href="node017.html#238805792" target="_self">15.1. API Functionality</a>
<ul class="toc-level-2">
<li><a href="node017.html#238807952" target="_self">15.1.1. Analyzing the problem and associated data</a></li>
<li><a href="node017.html#238810320" target="_self">15.1.2. Reading and writing data files</a></li>
<li><a href="node017.html#238812696" target="_self">15.1.3. Solutions</a></li>
<li><a href="node017.html#238819088" target="_self">15.1.4. Memory allocation and deallocation</a></li>
<li><a href="node017.html#238820168" target="_self">15.1.5. Changing problem specification</a></li>
<li><a href="node017.html#238826560" target="_self">15.1.6. Delete problem elements (variables,constraints,cones)</a></li>
<li><a href="node017.html#238827640" target="_self">15.1.7. Add problem elements (variables,constraints,cones)</a></li>
<li><a href="node017.html#238828720" target="_self">15.1.8. Problem inspection</a></li>
<li><a href="node017.html#238841368" target="_self">15.1.9. Conic constraints</a></li>
<li><a href="node017.html#238831088" target="_self">15.1.10. Bounds</a></li>
<li><a href="node017.html#238833032" target="_self">15.1.11. Error handling</a></li>
<li><a href="node017.html#238842368" target="_self">15.1.12. Output stream functions</a></li>
<li><a href="node017.html#238844528" target="_self">15.1.13. Objective function</a></li>
<li><a href="node017.html#238849128" target="_self">15.1.14. Optimizer statistics</a></li>
<li><a href="node017.html#238854800" target="_self">15.1.15. Parameters (set/get)</a></li>
<li><a href="node017.html#238850560" target="_self">15.1.16. Naming</a></li>
<li><a href="node017.html#238853584" target="_self">15.1.17. Preallocating space for problem data</a></li>
<li><a href="node017.html#238860984" target="_self">15.1.18. Integer variables</a></li>
<li><a href="node017.html#238867736" target="_self">15.1.19. Quadratic terms</a></li>
<li><a href="node017.html#238870328" target="_self">15.1.20. Diagnosing infeasibility</a></li>
<li><a href="node017.html#238863280" target="_self">15.1.21. Optimization</a></li>
<li><a href="node017.html#238864792" target="_self">15.1.22. Network optimization</a></li>
<li><a href="node017.html#238865872" target="_self">15.1.23. Sensitivity analysis</a></li>
<li><a href="node017.html#238871328" target="_self">15.1.24. Testing data validity</a></li>
<li><a href="node017.html#238872192" target="_self">15.1.25. Solving with the basis</a></li>
<li><a href="node017.html#238873488" target="_self">15.1.26. Initialization of environment</a></li>
<li><a href="node017.html#238878944" target="_self">15.1.27. Change <span class="math"><span class="mi">A</span></span></a></li>
</ul>
</li>
<li><a href="node017.html#238881608" target="_self">15.2. Class <tt class="tt">mosek.ArrayLengthException</tt></a></li>
<li><a href="node017.html#238882760" target="_self">15.3. Class <tt class="tt">mosek.Callback</tt></a></li>
<li><a href="node017.html#238875496" target="_self">15.4. Class <tt class="tt">mosek.Env</tt></a>
<ul class="toc-level-2">
<li><a href="node017.html#238875856" target="_self">15.4.1. Constructors</a></li>
<li><a href="node017.html#238883760" target="_self">15.4.2. Methods</a></li>
</ul>
</li>
<li><a href="node017.html#241012608" target="_self">15.5. Class <tt class="tt">mosek.Error</tt></a>
<ul class="toc-level-2">
<li><a href="node017.html#238883976" target="_self">15.5.1. Constructors</a></li>
</ul>
</li>
<li><a href="node017.html#238888144" target="_self">15.6. Class <tt class="tt">mosek.Exception</tt></a>
<ul class="toc-level-2">
<li><a href="node017.html#238888576" target="_self">15.6.1. Constructors</a></li>
</ul>
</li>
<li><a href="node017.html#241017488" target="_self">15.7. Class <tt class="tt">mosek.Progress</tt></a>
<ul class="toc-level-2">
<li><a href="node017.html#241017920" target="_self">15.7.1. Constructors</a></li>
<li><a href="node017.html#241020800" target="_self">15.7.2. Methods</a></li>
</ul>
</li>
<li><a href="node017.html#241027768" target="_self">15.8. Class <tt class="tt">mosek.Stream</tt></a>
<ul class="toc-level-2">
<li><a href="node017.html#241025176" target="_self">15.8.1. Constructors</a></li>
<li><a href="node017.html#241022232" target="_self">15.8.2. Methods</a></li>
</ul>
</li>
<li><a href="node017.html#241033296" target="_self">15.9. Class <tt class="tt">mosek.Task</tt></a>
<ul class="toc-level-2">
<li><a href="node017.html#241022448" target="_self">15.9.1. Constructors</a></li>
<li><a href="node017.html#241036752" target="_self">15.9.2. Attributes</a></li>
<li><a href="node017.html#241037536" target="_self">15.9.3. Methods</a></li>
</ul>
</li>
<li><a href="node017.html#247092288" target="_self">15.10. Class <tt class="tt">mosek.Warning</tt></a>
<ul class="toc-level-2">
<li><a href="node017.html#241037896" target="_self">15.10.1. Constructors</a></li>
</ul>
</li>
</ul>

<hr width="100%" class="tocseparator"/>
</div>

<p> <a name="chap-apiref">&#09;</a></p>

<p>This chapter lists all functionality in the MOSEK .NET API.</p>

<div>
<h1><a name="238805792">15.1. API Functionality</a></h1>

<p> Functions in the interface grouped by functionality.</p>

<div>
<h2><a name="238807952">15.1.1. Analyzing the problem and associated data</a></h2>

<p> Analyzing the problem and associated data. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*analyzeproblem"><b>mosek.Task.analyzeproblem</b></a>
<br/>Analyze the data of a task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*analyzesolution"><b>mosek.Task.analyzesolution</b></a>
<br/>Print information related to the quality of the solution. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238810320">15.1.2. Reading and writing data files</a></h2>

<p> Reading and writing data files. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readbranchpriorities"><b>mosek.Task.readbranchpriorities</b></a>
<br/>Reads branching priority data from a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readdata"><b>mosek.Task.readdata</b></a>
<br/>Reads problem data from a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readparamfile"><b>mosek.Task.readparamfile</b></a>
<br/>Reads a parameter file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readsolution"><b>mosek.Task.readsolution</b></a>
<br/>Reads a solution from a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*writebranchpriorities"><b>mosek.Task.writebranchpriorities</b></a>
<br/>Writes branching priority data to a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*writedata"><b>mosek.Task.writedata</b></a>
<br/>Writes problem data to a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*writeparamfile"><b>mosek.Task.writeparamfile</b></a>
<br/>Writes all the parameters to a parameter file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*writesolution"><b>mosek.Task.writesolution</b></a>
<br/>Write a solution to a file. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238812696">15.1.3. Solutions</a></h2>

<p> Obtain or define a solution. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*deletesolution"><b>mosek.Task.deletesolution</b></a>
<br/>Undefines a solution and frees the memory it uses. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdbi"><b>mosek.Task.getdbi</b></a>
<br/>Obtains the dual bound infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdcni"><b>mosek.Task.getdcni</b></a>
<br/>Obtains the dual cone infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdeqi"><b>mosek.Task.getdeqi</b></a>
<br/>Optains the dual equation infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdualobj"><b>mosek.Task.getdualobj</b></a>
<br/>Obtains the dual objective value. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getinti"><b>mosek.Task.getinti</b></a>
<br/>Obtains the primal equation infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getpbi"><b>mosek.Task.getpbi</b></a>
<br/>Obtains the primal bound infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getpcni"><b>mosek.Task.getpcni</b></a>
<br/>Obtains the primal cone infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getpeqi"><b>mosek.Task.getpeqi</b></a>
<br/>Obtains the primal equation infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getprimalobj"><b>mosek.Task.getprimalobj</b></a>
<br/>Obtains the primal objective value. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getreducedcosts"><b>mosek.Task.getreducedcosts</b></a>
<br/>Obtains the difference of (slx-sux) for a sequence of variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolution"><b>mosek.Task.getsolution</b></a>
<br/>Obtains the complete solution. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutioni"><b>mosek.Task.getsolutioni</b></a>
<br/>Obtains the solution for a single constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutioninf"><b>mosek.Task.getsolutioninf</b></a>
<br/>Obtains information about a solution. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutionslice"><b>mosek.Task.getsolutionslice</b></a>
<br/>Obtains a slice of the solution. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutionstatus"><b>mosek.Task.getsolutionstatus</b></a>
<br/>Obtains information about the problem and solution statuses. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutionstatuskeyslice"><b>mosek.Task.getsolutionstatuskeyslice</b></a>
<br/>Obtains a slice of the solution status keys. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><b>mosek.Task.makesolutionstatusunknown</b></a>
<br/>Sets the solution status to unknown. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*optimizersummary"><b>mosek.Task.optimizersummary</b></a>
<br/>Prints a short summary with optimizer statistics for last optimization. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putsolution"><b>mosek.Task.putsolution</b></a>
<br/>Inserts a solution. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putsolutioni"><b>mosek.Task.putsolutioni</b></a>
<br/>Sets the primal and dual solution information for a single constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readsolution"><b>mosek.Task.readsolution</b></a>
<br/>Reads a solution from a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solstatostr"><b>mosek.Task.solstatostr</b></a>
<br/>Obtains a solution status string. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solutiondef"><b>mosek.Task.solutiondef</b></a>
<br/>Checks whether a solution is defined. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solutionsummary"><b>mosek.Task.solutionsummary</b></a>
<br/>Prints a short summary of the current solutions. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*undefsolution"><b>mosek.Task.undefsolution</b></a>
<br/>Undefines a solution. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238819088">15.1.4. Memory allocation and deallocation</a></h2>

<p> Memory allocation and deallocation. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*checkmemtask"><b>mosek.Task.checkmem</b></a>
<br/>Checks the memory allocated by the task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmemusagetask64"><b>mosek.Task.getmemusage</b></a>
<br/>Obtains information about the amount of memory used by a task. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238820168">15.1.5. Changing problem specification</a></h2>

<p> Input or change problem specification. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*append"><b>mosek.Task.append</b></a>
<br/>Appends a number of variables or constraints to the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*appendcone"><b>mosek.Task.appendcone</b></a>
<br/>Appends a new cone constraint to the problem. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*checkoutlicense"><b>mosek.Env.checkoutlicense</b></a>
<br/>Check out a license feature from the license server ahead of time. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*chgbound"><b>mosek.Task.chgbound</b></a>
<br/>Changes the bounds for one constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*commitchanges"><b>mosek.Task.commitchanges</b></a>
<br/>Commits all cached problem changes. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*inputdata"><b>mosek.Task.inputdata</b></a>
<br/>Input the linear part of an optimization task in one function call. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*inputdata64"><b>mosek.Task.inputdata</b></a>
<br/>Input the linear part of an optimization task in one function call. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaij"><b>mosek.Task.putaij</b></a>
<br/>Changes a single value in the linear coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaijlist"><b>mosek.Task.putaijlist</b></a>
<br/>Changes one or more coefficients in the linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putavec"><b>mosek.Task.putavec</b></a>
<br/>Replaces all elements in one row or column of the linear coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaveclist"><b>mosek.Task.putaveclist</b></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaveclist64"><b>mosek.Task.putaveclist</b></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putbound"><b>mosek.Task.putbound</b></a>
<br/>Changes the bound for either one constraint or one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putboundlist"><b>mosek.Task.putboundlist</b></a>
<br/>Changes the bounds of constraints or variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putboundslice"><b>mosek.Task.putboundslice</b></a>
<br/>Modifies bounds. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcfix"><b>mosek.Task.putcfix</b></a>
<br/>Replaces the fixed term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcj"><b>mosek.Task.putcj</b></a>
<br/>Modifies one linear coefficient in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putclist"><b>mosek.Task.putclist</b></a>
<br/>Modifies a part of the linear objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcone"><b>mosek.Task.putcone</b></a>
<br/>Replaces a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putobjsense"><b>mosek.Task.putobjsense</b></a>
<br/>Sets the objective sense. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqcon"><b>mosek.Task.putqcon</b></a>
<br/>Replaces all quadratic terms in constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqconk"><b>mosek.Task.putqconk</b></a>
<br/>Replaces all quadratic terms in a single constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobj"><b>mosek.Task.putqobj</b></a>
<br/>Replaces all quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobjij"><b>mosek.Task.putqobjij</b></a>
<br/>Replaces one coefficient in the quadratic term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvartype"><b>mosek.Task.putvartype</b></a>
<br/>Sets the variable type of one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvartypelist"><b>mosek.Task.putvartypelist</b></a>
<br/>Sets the variable type for one or more variables. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238826560">15.1.6. Delete problem elements (variables,constraints,cones)</a></h2>

<p> Functionality for deleting problem elements such as variables, constraints or cones. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*remove"><b>mosek.Task.remove</b></a>
<br/>The function removes a number of constraints or variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*removecone"><b>mosek.Task.removecone</b></a>
<br/>Removes a conic constraint from the problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238827640">15.1.7. Add problem elements (variables,constraints,cones)</a></h2>

<p> Functionality for adding problem elements such as variables, constraints or cones. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*append"><b>mosek.Task.append</b></a>
<br/>Appends a number of variables or constraints to the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*appendcone"><b>mosek.Task.appendcone</b></a>
<br/>Appends a new cone constraint to the problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238828720">15.1.8. Problem inspection</a></h2>

<p> Functionality for inspecting the problem specification (<span class="math"><span class="mi">A</span></span>,<span class="math"><span class="mi">Q</span></span>, bounds, objective e.t.c). </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getaij"><b>mosek.Task.getaij</b></a>
<br/>Obtains a single coefficient in linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getaslice"><b>mosek.Task.getaslice</b></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getaslice64"><b>mosek.Task.getaslice</b></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getaslicetrip"><b>mosek.Task.getaslicetrip</b></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix in triplet format. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getavec"><b>mosek.Task.getavec</b></a>
<br/>Obtains one row or column of the linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getavecnumnz"><b>mosek.Task.getavecnumnz</b></a>
<br/>Obtains the number of non-zero elements in one row or column of the linear constraint matrix </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getbound"><b>mosek.Task.getbound</b></a>
<br/>Obtains bound information for one constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getboundslice"><b>mosek.Task.getboundslice</b></a>
<br/>Obtains bounds information for a sequence of variables or constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getc"><b>mosek.Task.getc</b></a>
<br/>Obtains all objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcfix"><b>mosek.Task.getcfix</b></a>
<br/>Obtains the fixed term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcone"><b>mosek.Task.getcone</b></a>
<br/>Obtains a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getconeinfo"><b>mosek.Task.getconeinfo</b></a>
<br/>Obtains information about a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcslice"><b>mosek.Task.getcslice</b></a>
<br/>Obtains a sequence of coefficients from the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getintpntnumthreads"><b>mosek.Task.getintpntnumthreads</b></a>
<br/>Obtains the number of threads used by the interior-point optimizer. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumanz"><b>mosek.Task.getnumanz</b></a>
<br/>Obtains the number of non-zeros in the coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumanz64"><b>mosek.Task.getnumanz64</b></a>
<br/>Obtains the number of non-zeros in the coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumcon"><b>mosek.Task.getnumcon</b></a>
<br/>Obtains the number of constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumcone"><b>mosek.Task.getnumcone</b></a>
<br/>Obtains the number of cones. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumconemem"><b>mosek.Task.getnumconemem</b></a>
<br/>Obtains the number of members in a cone. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumintvar"><b>mosek.Task.getnumintvar</b></a>
<br/>Obtains the number of integer-constrained variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqconknz"><b>mosek.Task.getnumqconknz</b></a>
<br/>Obtains the number of non-zero quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqconknz64"><b>mosek.Task.getnumqconknz64</b></a>
<br/>Obtains the number of non-zero quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqobjnz"><b>mosek.Task.getnumqobjnz</b></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqobjnz64"><b>mosek.Task.getnumqobjnz64</b></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumvar"><b>mosek.Task.getnumvar</b></a>
<br/>Obtains the number of variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjsense"><b>mosek.Task.getobjsense</b></a>
<br/>Gets the objective sense. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getprobtype"><b>mosek.Task.getprobtype</b></a>
<br/>Obtains the problem type. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqconk"><b>mosek.Task.getqconk</b></a>
<br/>Obtains all the quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqconk64"><b>mosek.Task.getqconk64</b></a>
<br/>Obtains all the quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj"><b>mosek.Task.getqobj</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj64"><b>mosek.Task.getqobj64</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobjij"><b>mosek.Task.getqobjij</b></a>
<br/>Obtains one coefficient from the quadratic term of the objective </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvartype"><b>mosek.Task.getvartype</b></a>
<br/>Gets the variable type of one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvartypelist"><b>mosek.Task.getvartypelist</b></a>
<br/>Obtains the variable type for one or more variables. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238841368">15.1.9. Conic constraints</a></h2>

<p> Functionality related to conic terms in the problem. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*appendcone"><b>mosek.Task.appendcone</b></a>
<br/>Appends a new cone constraint to the problem. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcone"><b>mosek.Task.getcone</b></a>
<br/>Obtains a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getconeinfo"><b>mosek.Task.getconeinfo</b></a>
<br/>Obtains information about a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumcone"><b>mosek.Task.getnumcone</b></a>
<br/>Obtains the number of cones. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcone"><b>mosek.Task.putcone</b></a>
<br/>Replaces a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*removecone"><b>mosek.Task.removecone</b></a>
<br/>Removes a conic constraint from the problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238831088">15.1.10. Bounds</a></h2>

<p> Functionality related to changing or inspecting bounds on variables or constraints. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*chgbound"><b>mosek.Task.chgbound</b></a>
<br/>Changes the bounds for one constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getbound"><b>mosek.Task.getbound</b></a>
<br/>Obtains bound information for one constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getboundslice"><b>mosek.Task.getboundslice</b></a>
<br/>Obtains bounds information for a sequence of variables or constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putbound"><b>mosek.Task.putbound</b></a>
<br/>Changes the bound for either one constraint or one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putboundlist"><b>mosek.Task.putboundlist</b></a>
<br/>Changes the bounds of constraints or variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putboundslice"><b>mosek.Task.putboundslice</b></a>
<br/>Modifies bounds. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238833032">15.1.11. Error handling</a></h2>

<p> Error handling. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*getcodedesc"><b>mosek.Env.getcodedesc</b></a>
<br/>Obtains a short description of a response code. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*getcodedisc"><b>mosek.Env.getcodedisc</b></a>
<br/>Obtains a short description of a response code. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238842368">15.1.12. Output stream functions</a></h2>

<p> Output stream functions. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*echointro"><b>mosek.Env.echointro</b></a>
<br/>Prints an intro to message stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*linkfiletoenvstream"><b>mosek.Env.linkfiletostream</b></a>
<br/>Directs all output from a stream to a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*linkfiletotaskstream"><b>mosek.Task.linkfiletostream</b></a>
<br/>Directs all output from a task stream to a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*optimizersummary"><b>mosek.Task.optimizersummary</b></a>
<br/>Prints a short summary with optimizer statistics for last optimization. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*printdata"><b>mosek.Task.printdata</b></a>
<br/>Prints a part of the problem data to a stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readsummary"><b>mosek.Task.readsummary</b></a>
<br/>Prints information about last file read. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solutionsummary"><b>mosek.Task.solutionsummary</b></a>
<br/>Prints a short summary of the current solutions. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238844528">15.1.13. Objective function</a></h2>

<p> Change or inspect objective function. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getc"><b>mosek.Task.getc</b></a>
<br/>Obtains all objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcfix"><b>mosek.Task.getcfix</b></a>
<br/>Obtains the fixed term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcslice"><b>mosek.Task.getcslice</b></a>
<br/>Obtains a sequence of coefficients from the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdualobj"><b>mosek.Task.getdualobj</b></a>
<br/>Obtains the dual objective value. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqobjnz"><b>mosek.Task.getnumqobjnz</b></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqobjnz64"><b>mosek.Task.getnumqobjnz64</b></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjname64"><b>mosek.Task.getobjname</b></a>
<br/>Obtains the name assigned to the objective function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjsense"><b>mosek.Task.getobjsense</b></a>
<br/>Gets the objective sense. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getprimalobj"><b>mosek.Task.getprimalobj</b></a>
<br/>Obtains the primal objective value. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj"><b>mosek.Task.getqobj</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj64"><b>mosek.Task.getqobj64</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobjij"><b>mosek.Task.getqobjij</b></a>
<br/>Obtains one coefficient from the quadratic term of the objective </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcfix"><b>mosek.Task.putcfix</b></a>
<br/>Replaces the fixed term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcj"><b>mosek.Task.putcj</b></a>
<br/>Modifies one linear coefficient in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putclist"><b>mosek.Task.putclist</b></a>
<br/>Modifies a part of the linear objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putobjsense"><b>mosek.Task.putobjsense</b></a>
<br/>Sets the objective sense. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobj"><b>mosek.Task.putqobj</b></a>
<br/>Replaces all quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobjij"><b>mosek.Task.putqobjij</b></a>
<br/>Replaces one coefficient in the quadratic term in the objective. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238849128">15.1.14. Optimizer statistics</a></h2>

<p> Inspect statistics from the optimizer. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdouinf"><b>mosek.Task.getdouinf</b></a>
<br/>Obtains a double information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getinfindex"><b>mosek.Task.getinfindex</b></a>
<br/>Obtains the index of a named information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getintinf"><b>mosek.Task.getintinf</b></a>
<br/>Obtains an integer information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getlintinf"><b>mosek.Task.getlintinf</b></a>
<br/>Obtains an integer information item. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238854800">15.1.15. Parameters (set/get)</a></h2>

<p> Setting and inspecting solver parameters. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdouparam"><b>mosek.Task.getdouparam</b></a>
<br/>Obtains a double parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getintparam"><b>mosek.Task.getintparam</b></a>
<br/>Obtains an integer parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumparam"><b>mosek.Task.getnumparam</b></a>
<br/>Obtains the number of parameters of a given type. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*iparvaltosymnam"><b>mosek.Env.iparvaltosymnam</b></a>
<br/>Obtains the symbolic name corresponding to a value that can be assigned to an integer parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*isdouparname"><b>mosek.Task.isdouparname</b></a>
<br/>Checks a double parameter name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*isintparname"><b>mosek.Task.isintparname</b></a>
<br/>Checks an integer parameter name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*isstrparname"><b>mosek.Task.isstrparname</b></a>
<br/>Checks a string parameter name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putdouparam"><b>mosek.Task.putdouparam</b></a>
<br/>Sets a double parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putintparam"><b>mosek.Task.putintparam</b></a>
<br/>Sets an integer parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putnadouparam"><b>mosek.Task.putnadouparam</b></a>
<br/>Sets a double parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putnaintparam"><b>mosek.Task.putnaintparam</b></a>
<br/>Sets an integer parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putnastrparam"><b>mosek.Task.putnastrparam</b></a>
<br/>Sets a string parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putparam"><b>mosek.Task.putparam</b></a>
<br/>Modifies the value of parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putstrparam"><b>mosek.Task.putstrparam</b></a>
<br/>Sets a string parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*setdefaults"><b>mosek.Task.setdefaults</b></a>
<br/>Resets all parameters values. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238850560">15.1.16. Naming</a></h2>

<p> Functionality related to naming. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getconname64"><b>mosek.Task.getconname</b></a>
<br/>Obtains a name of a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getname64"><b>mosek.Task.getname</b></a>
<br/>Obtains the name of a cone, a variable or a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnameapi64"><b>mosek.Task.getname</b></a>
<br/>Obtains the name of a cone, a variable or a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnameindex"><b>mosek.Task.getnameindex</b></a>
<br/>Checks whether a name has been assigned and returns the index corresponding to the name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnamelen64"><b>mosek.Task.getnamelen</b></a>
<br/>Obtains the length of a problem item name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjname64"><b>mosek.Task.getobjname</b></a>
<br/>Obtains the name assigned to the objective function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*gettaskname64"><b>mosek.Task.gettaskname64</b></a>
<br/>Obtains the task name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvarname64"><b>mosek.Task.getvarname</b></a>
<br/>Obtains a name of a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putname"><b>mosek.Task.putname</b></a>
<br/>Assigns a name to a problem item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putobjname"><b>mosek.Task.putobjname</b></a>
<br/>Assigns a new name to the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*puttaskname"><b>mosek.Task.puttaskname</b></a>
<br/>Assigns a new name to the task. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238853584">15.1.17. Preallocating space for problem data</a></h2>

<p> Functionality related to preallocating space for problem data. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumanz64"><b>mosek.Task.getmaxnumanz</b></a>
<br/>Obtains number of preallocated non-zeros in the linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumcon"><b>mosek.Task.getmaxnumcon</b></a>
<br/>Obtains the number of preallocated constraints in the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumcone"><b>mosek.Task.getmaxnumcone</b></a>
<br/>Obtains the number of preallocated cones in the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumqnz64"><b>mosek.Task.getmaxnumqnz</b></a>
<br/>Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumvar"><b>mosek.Task.getmaxnumvar</b></a>
<br/>Obtains the maximum number variables allowed. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumanz"><b>mosek.Task.putmaxnumanz</b></a>
<br/>The function changes the size of the preallocated storage for linear coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumanz64"><b>mosek.Task.putmaxnumanz</b></a>
<br/>The function changes the size of the preallocated storage for linear coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumcon"><b>mosek.Task.putmaxnumcon</b></a>
<br/>Sets the number of preallocated constraints in the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumcone"><b>mosek.Task.putmaxnumcone</b></a>
<br/>Sets the number of preallocated conic constraints in the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><b>mosek.Task.putmaxnumqnz</b></a>
<br/>Changes the size of the preallocated storage for quadratic terms. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumqnz64"><b>mosek.Task.putmaxnumqnz</b></a>
<br/>Changes the size of the preallocated storage for quadratic terms. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumvar"><b>mosek.Task.putmaxnumvar</b></a>
<br/>Sets the number of preallocated variables in the optimization task. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238860984">15.1.18. Integer variables</a></h2>

<p> Functionality related to integer variables. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumintvar"><b>mosek.Task.getnumintvar</b></a>
<br/>Obtains the number of integer-constrained variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvarbranchdir"><b>mosek.Task.getvarbranchdir</b></a>
<br/>Obtains the branching direction for a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvarbranchorder"><b>mosek.Task.getvarbranchorder</b></a>
<br/>Obtains the branching priority for a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvarbranchpri"><b>mosek.Task.getvarbranchpri</b></a>
<br/>Obtains the branching priority for a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvartype"><b>mosek.Task.getvartype</b></a>
<br/>Gets the variable type of one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvartypelist"><b>mosek.Task.getvartypelist</b></a>
<br/>Obtains the variable type for one or more variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvarbranchorder"><b>mosek.Task.putvarbranchorder</b></a>
<br/>Assigns a branching priority and direction to a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvartype"><b>mosek.Task.putvartype</b></a>
<br/>Sets the variable type of one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvartypelist"><b>mosek.Task.putvartypelist</b></a>
<br/>Sets the variable type for one or more variables. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238867736">15.1.19. Quadratic terms</a></h2>

<p> Functionality related to quadratic terms. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqconk"><b>mosek.Task.getqconk</b></a>
<br/>Obtains all the quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqconk64"><b>mosek.Task.getqconk64</b></a>
<br/>Obtains all the quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj"><b>mosek.Task.getqobj</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj64"><b>mosek.Task.getqobj64</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobjij"><b>mosek.Task.getqobjij</b></a>
<br/>Obtains one coefficient from the quadratic term of the objective </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqcon"><b>mosek.Task.putqcon</b></a>
<br/>Replaces all quadratic terms in constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqconk"><b>mosek.Task.putqconk</b></a>
<br/>Replaces all quadratic terms in a single constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobj"><b>mosek.Task.putqobj</b></a>
<br/>Replaces all quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobjij"><b>mosek.Task.putqobjij</b></a>
<br/>Replaces one coefficient in the quadratic term in the objective. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238870328">15.1.20. Diagnosing infeasibility</a></h2>

<p> Functions for diagnosing infeasibility. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getinfeasiblesubproblem"><b>mosek.Task.getinfeasiblesubproblem</b></a>
<br/>Obtains an infeasible sub problem. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*relaxprimal"><b>mosek.Task.relaxprimal</b></a>
<br/>Creates a problem that finds the minimal change to the bounds that makes an infeasible problem feasible. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238863280">15.1.21. Optimization</a></h2>

<p> Functions for optimization. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*checkdata"><b>mosek.Task.checkdata</b></a>
<br/>Checks data of the task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*netoptimize"><b>mosek.Task.netoptimize</b></a>
<br/>Optimizes a pure network flow problem. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*optimizeconcurrent"><b>mosek.Task.optimizeconcurrent</b></a>
<br/>Optimize a given task with several optimizers concurrently. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*optimizetrm"><b>mosek.Task.optimize</b></a>
<br/>Optimizes the problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238864792">15.1.22. Network optimization</a></h2>

<p> Functions for network optimization. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*netextraction"><b>mosek.Task.netextraction</b></a>
<br/>Finds embedded network structure. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*netoptimize"><b>mosek.Task.netoptimize</b></a>
<br/>Optimizes a pure network flow problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238865872">15.1.23. Sensitivity analysis</a></h2>

<p> Functions for sensitivity analysis. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*dualsensitivity"><b>mosek.Task.dualsensitivity</b></a>
<br/>Performs sensitivity analysis on objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*primalsensitivity"><b>mosek.Task.primalsensitivity</b></a>
<br/>Perform sensitivity analysis on bounds. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*sensitivityreport"><b>mosek.Task.sensitivityreport</b></a>
<br/>Creates a sensitivity report. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238871328">15.1.24. Testing data validity</a></h2>

<p> Functions for testing data validity. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*checkconvexity"><b>mosek.Task.checkconvexity</b></a>
<br/>Checks if a quadratic optimization problem is convex. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238872192">15.1.25. Solving with the basis</a></h2>

<p> Functions for solving linear systems with the basis matrix. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*basiscond"><b>mosek.Task.basiscond</b></a>
<br/>Computes conditioning information for the basis matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*initbasissolve"><b>mosek.Task.initbasissolve</b></a>
<br/>Prepare a task for basis solver. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solvewithbasis"><b>mosek.Task.solvewithbasis</b></a>
<br/>Solve a linear equation system involving a basis matrix. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238873488">15.1.26. Initialization of environment</a></h2>

<p> Creation and initialization of environment. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*checkinlicense"><b>mosek.Env.checkinlicense</b></a>
<br/>Check in a license feature from the license server ahead of time. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*initenv"><b>mosek.Env.init</b></a>
<br/>Initialize a MOSEK environment. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*putlicensedefaults"><b>mosek.Env.putlicensedefaults</b></a>
<br/>Set defaults used by the license manager. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="238878944">15.1.27. Change <span class="math"><span class="mi">A</span></span></a></h2>

<p> Change elements in the coefficient (<span class="math"><span class="mi">A</span></span>) matrix. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*checkoutlicense"><b>mosek.Env.checkoutlicense</b></a>
<br/>Check out a license feature from the license server ahead of time. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*commitchanges"><b>mosek.Task.commitchanges</b></a>
<br/>Commits all cached problem changes. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaij"><b>mosek.Task.putaij</b></a>
<br/>Changes a single value in the linear coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaijlist"><b>mosek.Task.putaijlist</b></a>
<br/>Changes one or more coefficients in the linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putavec"><b>mosek.Task.putavec</b></a>
<br/>Replaces all elements in one row or column of the linear coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaveclist"><b>mosek.Task.putaveclist</b></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaveclist64"><b>mosek.Task.putaveclist</b></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </p>
</dd>
</dl>

</div>

</div>

<div>
<h1><a name="238881608">15.2. Class <tt class="tt">mosek.ArrayLengthException</tt></a></h1>

<p><a name="apiclass*mosek*arraylengthexception">&#09;</a><a name="common-apiclass*mosek*arraylengthexception"></a> </p>

<dl class="description">
<dt>Derived from:</dt>
<dd>
<p><tt class="tt">System.Exception</tt> </p>
</dd>
<dt>Description:</dt>
<dd>
<p>This exception is raised is an input or output array was shorter than required.</p>
</dd>
</dl>

</div>

<div>
<h1><a name="238882760">15.3. Class <tt class="tt">mosek.Callback</tt></a></h1>

<p><a name="apiclass*mosek*callback">&#09;</a><a name="common-apiclass*mosek*callback"></a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>Base class for all call-back objects used in MOSEK</p>
</dd>
</dl>

</div>

<div>
<h1><a name="238875496">15.4. Class <tt class="tt">mosek.Env</tt></a></h1>

<p><a name="apiclass*mosek*env">&#09;</a><a name="common-apiclass*mosek*env"></a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A Mosek Environment</p>
</dd>
</dl>

<div>
<h2><a name="238875856">15.4.1. Constructors</a></h2>

<p> <a name="idx-98194712">&#09;</a> <a name="idx-98188680">&#09;</a> </p>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Env</tt></span>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Env ()
</pre>
</dd>
<dt>Description:</dt>
<dd>Create a MOSEK environment object.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env</tt></span>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Env (string dbgfile)
</pre>
</dd>
<dt>Description:</dt>
<dd>Create a MOSEK environment object.</dd>
<dt>Arguments:</dt>
<dd>
<p>&nbsp;</p>

<dl class="funcargsdesc">
<dt><tt class="tt">dbgfile</tt></dt>
<dd>A file which will be used to log memory debugging information from MOSEK</dd>
</dl>
</dd>
</dl>
</li>
</ul>

</div>

<div>
<h2><a name="238883760">15.4.2. Methods</a></h2>

<ul class="itemize">
<li><a href="node017.html#common-func*mosek*env*checkinlicense"><tt class="tt">mosek.Env.checkinlicense</tt></a>
<br/>Check in a license feature from the license server ahead of time. </li>
<li><a href="node017.html#common-func*mosek*env*checkoutlicense"><tt class="tt">mosek.Env.checkoutlicense</tt></a>
<br/>Check out a license feature from the license server ahead of time. </li>
<li><a href="node017.html#common-func*mosek*env*echointro"><tt class="tt">mosek.Env.echointro</tt></a>
<br/>Prints an intro to message stream. </li>
<li><a href="node017.html#common-func*mosek*env*getbuildinfo"><tt class="tt">mosek.Env.getbuildinfo</tt></a>
<br/>Obtains build information. </li>
<li><a href="node017.html#common-func*mosek*env*getcodedesc"><tt class="tt">mosek.Env.getcodedesc</tt></a>
<br/>Obtains a short description of a response code. </li>
<li><a href="node017.html#common-func*mosek*env*getcodedisc"><tt class="tt">mosek.Env.getcodedisc</tt></a>
<br/>Obtains a short description of a response code. </li>
<li><a href="node017.html#common-func*mosek*env*getversion"><tt class="tt">mosek.Env.getversion</tt></a>
<br/>Obtains MOSEK version information. </li>
<li><a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">mosek.Env.init</tt></a>
<br/>Initialize a MOSEK environment. </li>
<li><a href="node017.html#common-func*mosek*env*iparvaltosymnam"><tt class="tt">mosek.Env.iparvaltosymnam</tt></a>
<br/>Obtains the symbolic name corresponding to a value that can be assigned to an integer parameter. </li>
<li><a href="node017.html#common-func*mosek*env*linkfiletoenvstream"><tt class="tt">mosek.Env.linkfiletostream</tt></a>
<br/>Directs all output from a stream to a file. </li>
<li><a href="node017.html#common-func*mosek*env*putcpudefaults"><tt class="tt">mosek.Env.putcpudefaults</tt></a>
<br/>Set defaults default CPU type and cache sizes. </li>
<li><a href="node017.html#common-func*mosek*env*putdllpath"><tt class="tt">mosek.Env.putdllpath</tt></a>
<br/>Sets the path to the DLL/shared libraries that MOSEK is loading. </li>
<li><a href="node017.html#common-func*mosek*env*putkeepdlls"><tt class="tt">mosek.Env.putkeepdlls</tt></a>
<br/>Controls whether explicitly loaded DLLs should be kept. </li>
<li><a href="node017.html#common-func*mosek*env*putlicensedefaults"><tt class="tt">mosek.Env.putlicensedefaults</tt></a>
<br/>Set defaults used by the license manager. </li>
<li><a href="node017.html#common-func*mosek*env*set-stream"><tt class="tt">mosek.Env.set_Stream</tt></a>
<br/>Attach a stream call-back handler. </li>
</ul>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Env.checkinlicense</tt></span>

<p> <a name="func*mosek*env*checkinlicense">&#09;</a><a name="common-func*mosek*env*checkinlicense"></a> <a name="idx-99605896">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void checkinlicense (feature feature)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*feature"><tt class="tt">feature</tt></a> (input)</dt>
<dd>Feature to check in to the license system.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Check in a license feature to the license server. By default all licenses consumed by functions using a single environment is kept checked out for the lifetime of the MOSEK environment. This function checks in a given license feature to the license server immidiatly.</p>

<p>If the given license feature is not checked out or is in use by a call to <a href="node017.html#common-func*mosek*task*optimizetrm"><tt class="tt">mosek.Task.optimizetrm</tt></a> calling this function has no effect.</p>

<p>Please note that returning a license to the license server incurs a small overhead, so frequent calls to this function should be avoided.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.checkoutlicense</tt></span>

<p> <a name="func*mosek*env*checkoutlicense">&#09;</a><a name="common-func*mosek*env*checkoutlicense"></a> <a name="idx-99646712">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void checkoutlicense (feature feature)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*feature"><tt class="tt">feature</tt></a> (input)</dt>
<dd>Feature to check out from the license system.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Check out a license feature from the license server. Normally the required license features will be automatically checked out the first time it is needed by the function <a href="node017.html#common-func*mosek*task*optimizetrm"><tt class="tt">mosek.Task.optimizetrm</tt></a>. This function can be used to check out one or more features ahead of time.</p>

<p>The license will remain checked out for the lifetime of the MOSEK environment or until the function <a href="node017.html#common-func*mosek*env*checkinlicense"><tt class="tt">mosek.Env.checkinlicense</tt></a> is called.</p>

<p>If a given feature is already checked out when this function is called, only one feature will be checked out from the license server.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.echointro</tt></span>

<p> <a name="func*mosek*env*echointro">&#09;</a><a name="common-func*mosek*env*echointro"></a> <a name="idx-99654184">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void echointro (int longver)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">longver</tt> (input)</dt>
<dd>If non-zero, then the intro is slightly longer.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints an intro to message stream.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.getbuildinfo</tt></span>

<p> <a name="func*mosek*env*getbuildinfo">&#09;</a><a name="common-func*mosek*env*getbuildinfo"></a> <a name="idx-99665320">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getbuildinfo (
    StringBuilder buildstate,
    StringBuilder builddate,
    StringBuilder buildtool);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">buildstate</tt> (output)</dt>
<dd>State of binaries, i.e. a debug, release candidate or final release.</dd>
<dt><tt class="tt">builddate</tt> (output)</dt>
<dd>Date when the binaries were build.</dd>
<dt><tt class="tt">buildtool</tt> (output)</dt>
<dd>Tool(s) used to build the binaries.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains build information.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.getcodedesc</tt></span>

<p> <a name="func*mosek*env*getcodedesc">&#09;</a><a name="common-func*mosek*env*getcodedesc"></a> <a name="idx-99667336">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getcodedesc (
    rescode code,
    StringBuilder symname,
    StringBuilder str);
</pre>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">code</tt></a> (input)</dt>
<dd>A valid MOSEK response code.</dd>
<dt><tt class="tt">symname</tt> (output)</dt>
<dd>Symbolic name corresponding to <tt class="tt">code</tt>.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>Obtains a short description of a response code.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a short description of the meaning of the response code given by <tt class="tt">code</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.getcodedisc</tt></span>

<p> <a name="func*mosek*env*getcodedisc">&#09;</a><a name="common-func*mosek*env*getcodedisc"></a> <a name="idx-99682208">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getcodedisc (
    rescode code,
    StringBuilder symname,
    StringBuilder str);
</pre>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">code</tt></a> (input)</dt>
<dd>A valid MOSEK response code.</dd>
<dt><tt class="tt">symname</tt> (output)</dt>
<dd>Symbolic name corresponding to <tt class="tt">code</tt>.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>Obtains a short description of a response code.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a short description of the meaning of the response code given by <tt class="tt">code</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.getversion</tt></span>

<p> <a name="func*mosek*env*getversion">&#09;</a><a name="common-func*mosek*env*getversion"></a> <a name="idx-99695936">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getversion (
    out int major,
    out int minor,
    out int build,
    out int revision);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">major</tt> (output)</dt>
<dd>Major version number.</dd>
<dt><tt class="tt">minor</tt> (output)</dt>
<dd>Minor version number.</dd>
<dt><tt class="tt">build</tt> (output)</dt>
<dd>Build number.</dd>
<dt><tt class="tt">revision</tt> (output)</dt>
<dd>Revision number.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains MOSEK version information.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.init</tt></span>

<p> <a name="func*mosek*env*initenv">&#09;</a><a name="common-func*mosek*env*initenv"></a> <a name="idx-99693416">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void init ()
</pre>
</dd>
<dt>Description:</dt>
<dd>This function initializes the MOSEK environment.  Among other things the license server will be contacted. Error messages from the license manager can be captured by linking to the environment message stream before calling this function.    </dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.iparvaltosymnam</tt></span>

<p> <a name="func*mosek*env*iparvaltosymnam">&#09;</a><a name="common-func*mosek*env*iparvaltosymnam"></a> <a name="idx-99712464">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void iparvaltosymnam (
    iparam whichparam,
    int whichvalue,
    StringBuilder symbolicname);
</pre>

<dl class="funcargsdesc">
<dt><a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">whichparam</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">whichvalue</tt> (input)</dt>
<dd>Which value.</dd>
<dt><tt class="tt">symbolicname</tt> (output)</dt>
<dd>The symbolic name corresponding to <tt class="tt">whichvalue</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the symbolic name corresponding to a value that can be assigned to an integer parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.linkfiletostream</tt></span>

<p> <a name="func*mosek*env*linkfiletoenvstream">&#09;</a><a name="common-func*mosek*env*linkfiletoenvstream"></a> <a name="idx-99731864">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void linkfiletostream (
    streamtype whichstream,
    string filename,
    int append);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Sends all output from the stream defined by <tt class="tt">whichstream</tt> to the file given by <tt class="tt">filename</tt>.</dd>
<dt><tt class="tt">append</tt> (input)</dt>
<dd>If this argument is non-zero, the output is appended to the file.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Directs all output from a stream to a file.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.putcpudefaults</tt></span>

<p> <a name="func*mosek*env*putcpudefaults">&#09;</a><a name="common-func*mosek*env*putcpudefaults"></a> <a name="idx-99743504">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putcpudefaults (
    int cputype,
    int sizel1,
    int sizel2);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*cputype"><tt class="tt">cputype</tt></a> (input)</dt>
<dd>The CPU ID.</dd>
<dt><tt class="tt">sizel1</tt> (input)</dt>
<dd>Size of the L1 cache.</dd>
<dt><tt class="tt">sizel2</tt> (input)</dt>
<dd>Size of the L2 cache.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets default CPU type and cache sizes. This function should be called before <a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">mosek.Env.initenv</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.putdllpath</tt></span>

<p> <a name="func*mosek*env*putdllpath">&#09;</a><a name="common-func*mosek*env*putdllpath"></a> <a name="idx-99735312">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putdllpath (string dllpath)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">dllpath</tt> (input)</dt>
<dd>A path to where the MOSEK dynamic link/shared libraries are located. If <tt class="tt">dllpath</tt> is <tt class="tt">NULL</tt>, then MOSEK assumes that the operating system can locate the libraries.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the path to the DLL/shared libraries that MOSEK are loading. If needed, then it should normally be called before <a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">mosek.Env.initenv</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.putkeepdlls</tt></span>

<p> <a name="func*mosek*env*putkeepdlls">&#09;</a><a name="common-func*mosek*env*putkeepdlls"></a> <a name="idx-99769664">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putkeepdlls (int keepdlls)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">keepdlls</tt> (input)</dt>
<dd>Controls whether explicitly loaded DLLs should be kept.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Controls whether explicitly loaded DLLs should be kept when they no longer are in use.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.putlicensedefaults</tt></span>

<p> <a name="func*mosek*env*putlicensedefaults">&#09;</a><a name="common-func*mosek*env*putlicensedefaults"></a> <a name="idx-99767504">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putlicensedefaults (
    string licensefile,
    int[] licensebuf,
    int licwait,
    int licdebug);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">licensefile</tt> (input)</dt>
<dd>Either <tt class="tt">NULL</tt> or the path to a valid MOSEK license file.</dd>
<dt><tt class="tt">licensebuf</tt> (input)</dt>
<dd>This is the license string authorizing the use of MOSEK in the runtime version of MOSEK. Therefore, most frequently this string is a NULL pointer.</dd>
<dt><tt class="tt">licwait</tt> (input)</dt>
<dd>If this argument is non-zero, then MOSEK will wait for a license if no license is available. Moreover, <tt class="tt">licwait-1</tt> is the number of milliseconds to wait between each check for an available license.</dd>
<dt><tt class="tt">licdebug</tt> (input)</dt>
<dd>If this argument is non-zero, then MOSEK will print debug info regarding the license checkout.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets default values for the license manager. This function should be called before <a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">mosek.Env.initenv</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Env.set_Stream</tt></span>

<p> <a name="func*mosek*env*set-stream">&#09;</a><a name="common-func*mosek*env*set-stream"></a> <a name="idx-99794384">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void set_Stream (
    streamtype whichstream,
    Stream stream);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> </dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">stream</tt> </dt>
<dd>The stream object to attach. To detach all objects, let this be null.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Attach a stream call-back handler.</dd>
</dl>
</li>
</ul>

</div>

</div>

<div>
<h1><a name="241012608">15.5. Class <tt class="tt">mosek.Error</tt></a></h1>

<p><a name="apiclass*mosek*error">&#09;</a><a name="common-apiclass*mosek*error"></a> </p>

<dl class="description">
<dt>Derived from:</dt>
<dd>
<p><tt class="tt">mosek.Exception</tt> </p>
</dd>
<dt>Description:</dt>
<dd>
<p>This is an exception class representing MOSEK errors.</p>
</dd>
</dl>

<div>
<h2><a name="238883976">15.5.1. Constructors</a></h2>

<p> <a name="idx-99802936">&#09;</a> <a name="idx-99803936">&#09;</a> </p>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Error</tt></span>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Error (rescode code)
</pre>
</dd>
<dt>Description:</dt>
<dd>Construct an error from a MOSEK error code.</dd>
<dt>Arguments:</dt>
<dd>
<p>&nbsp;</p>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">code</tt></a></dt>
<dd>The MOSEK response code to create the exception from.</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Error</tt></span>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Error (
    rescode code,
    string msg);
</pre>
</dd>
<dt>Description:</dt>
<dd>Construct an error from a MOSEK error code and a message.</dd>
<dt>Arguments:</dt>
<dd>
<p>&nbsp;</p>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">code</tt></a></dt>
<dd>The MOSEK response code to create the exception from.</dd>
<dt><tt class="tt">msg</tt></dt>
<dd>A message describing the error situation.</dd>
</dl>
</dd>
</dl>
</li>
</ul>

</div>

</div>

<div>
<h1><a name="238888144">15.6. Class <tt class="tt">mosek.Exception</tt></a></h1>

<p><a name="apiclass*mosek*exception">&#09;</a><a name="common-apiclass*mosek*exception"></a> </p>

<dl class="description">
<dt>Derived from:</dt>
<dd>
<p><tt class="tt">System.Exception</tt> </p>
</dd>
<dt>Description:</dt>
<dd>
<p>This is the base class for exceptions based on MOSEK response codes.</p>
</dd>
</dl>

<div>
<h2><a name="238888576">15.6.1. Constructors</a></h2>

<p> <a name="idx-99829016">&#09;</a> <a name="idx-99829952">&#09;</a> </p>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Exception</tt></span>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Exception (rescode code)
</pre>
</dd>
<dt>Description:</dt>
<dd>Construct an exception from a MOSEK error code.</dd>
<dt>Arguments:</dt>
<dd>
<p>&nbsp;</p>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">code</tt></a></dt>
<dd>The MOSEK response code to create the exception from.</dd>
</dl>
</dd>
</dl>
</li>
</ul>

</div>

</div>

<div>
<h1><a name="241017488">15.7. Class <tt class="tt">mosek.Progress</tt></a></h1>

<p><a name="apiclass*mosek*progress">&#09;</a><a name="common-apiclass*mosek*progress"></a> </p>

<dl class="description">
<dt>Derived from:</dt>
<dd>
<p><tt class="tt">mosek.Callback</tt> </p>
</dd>
<dt>Description:</dt>
<dd>
<p>This is the base class for user-defined progress call-back objects. An object of this type can be attached to a MOSEK task in order to receive frequent calls with a progress indicator during long optimizations. The calls are received by overriding a certain member of this class.</p>

<p>The call-back method is called at the beginning of each iteration in the interior-point optimizer. For the simplex optimizers the parameter <a href="node018.html#common-const*mosek*iparam*log-sim-freq"><tt class="tt">mosek.iparam.log_sim_freq</tt></a> controls how frequent the call-backs are.</p>

<p>Typically, the user-defined call-back method displays information about the solution process. The call-back function can also be used to terminate the optimization process: If the method returns a non-zero value when called, MOSEK will abort optimization and perform proper cleanup of the task.</p>

<p><b>It is important that the user-defined call-back function does not modify the optimization task, this will lead to undefined behavior and incorrect results</b>. The only MOSEK functions that can be called safely from within the user-defined call-back function are <a href="node017.html#common-func*mosek*task*getdouinf"><tt class="tt">mosek.Task.getdouinf</tt></a> and <a href="node017.html#common-func*mosek*task*getintinf"><tt class="tt">mosek.Task.getintinf</tt></a> which access the task information database. The items in task information database are updated during the optimization process.</p>
</dd>
</dl>

<div>
<h2><a name="241017920">15.7.1. Constructors</a></h2>

<p> <a name="idx-99830456">&#09;</a> <a name="idx-99856536">&#09;</a> </p>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Progress</tt></span>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Progress ()
</pre>
</dd>
<dt>Description:</dt>
<dd>Construct a Progress object.</dd>
</dl>
</li>
</ul>

</div>

<div>
<h2><a name="241020800">15.7.2. Methods</a></h2>

<ul class="itemize">
<li><a href="node017.html#common-func*mosek*progress*progress"><tt class="tt">mosek.Progress.progress</tt></a>
<br/>The method called during optimization. </li>
</ul>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Progress.progress</tt></span>

<p> <a name="func*mosek*progress*progress">&#09;</a><a name="common-func*mosek*progress*progress"></a> <a name="idx-99852656">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public CType(int) progress (callbackcode caller)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*callbackcode"><tt class="tt">caller</tt></a> </dt>
<dd>A value indicating the point from where the function was called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The method called during optimization. Override this function to receive the progress indicators.</dd>
</dl>
</li>
</ul>

</div>

</div>

<div>
<h1><a name="241027768">15.8. Class <tt class="tt">mosek.Stream</tt></a></h1>

<p><a name="apiclass*mosek*stream">&#09;</a><a name="common-apiclass*mosek*stream"></a> </p>

<dl class="description">
<dt>Derived from:</dt>
<dd>
<p><tt class="tt">mosek.Callback</tt> </p>
</dd>
<dt>Description:</dt>
<dd>
<p>Base class for stream printer classes which can be attached to MOSEK tasks and environments to intercept output.</p>
</dd>
</dl>

<div>
<h2><a name="241025176">15.8.1. Constructors</a></h2>

<p> <a name="idx-101389304">&#09;</a> <a name="idx-101390240">&#09;</a> </p>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Stream</tt></span>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Stream ()
</pre>
</dd>
<dt>Description:</dt>
<dd>Construct a MOSEK Stream printer object.</dd>
</dl>
</li>
</ul>

</div>

<div>
<h2><a name="241022232">15.8.2. Methods</a></h2>

<ul class="itemize">
<li><a href="node017.html#common-func*mosek*stream*stream"><tt class="tt">mosek.Stream.stream</tt></a>
<br/>The method which receives output strings from MOSEK. </li>
</ul>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Stream.stream</tt></span>

<p> <a name="func*mosek*stream*stream">&#09;</a><a name="common-func*mosek*stream*stream"></a> <a name="idx-101401592">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void stream (string str)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">str</tt> </dt>
<dd>A string to be outputted.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The method which receives output strings from MOSEK.</dd>
</dl>
</li>
</ul>

</div>

</div>

<div>
<h1><a name="241033296">15.9. Class <tt class="tt">mosek.Task</tt></a></h1>

<p><a name="apiclass*mosek*task">&#09;</a><a name="common-apiclass*mosek*task"></a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A Mosek Optimization task</p>
</dd>
</dl>

<div>
<h2><a name="241022448">15.9.1. Constructors</a></h2>

<p> <a name="idx-101415320">&#09;</a> <a name="idx-101416112">&#09;</a> </p>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Task</tt></span>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Task (
    Env env,
    int maxnumcon,
    int maxnumvar);
</pre>
</dd>
<dt>Description:</dt>
<dd>Create a new MOSEK task and reserve space for constraints and variables. Please note that it is perfectly legal to specify 0 constraint or 0 variables: The values may be specified later with <a href="node017.html#common-func*mosek*task*putmaxnumcon"><tt class="tt">mosek.Task.putmaxnumcon</tt></a> and <a href="node017.html#common-func*mosek*task*putmaxnumvar"><tt class="tt">mosek.Task.putmaxnumvar</tt></a>. Even without doing so, the task will automatically resize when exceeding the maximum, but if this happens often, there will be some overhead when resizing.</dd>
<dt>Arguments:</dt>
<dd>
<p>&nbsp;</p>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt></dt>
<dd>The environment the task should belong to.</dd>
<dt><tt class="tt">maxnumcon</tt></dt>
<dd>Initially reserve space for this many constraints.</dd>
<dt><tt class="tt">maxnumvar</tt></dt>
<dd>Initially reserve space for this many variables.</dd>
</dl>
</dd>
</dl>
</li>
</ul>

</div>

<div>
<h2><a name="241036752">15.9.2. Attributes</a></h2>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Progress ProgressCB</tt></span>
 (write only) Progress call-back object </li>
</ul>

</div>

<div>
<h2><a name="241037536">15.9.3. Methods</a></h2>

<ul class="itemize">
<li><a href="node017.html#common-func*mosek*task*analyzeproblem"><tt class="tt">mosek.Task.analyzeproblem</tt></a>
<br/>Analyze the data of a task. </li>
<li><a href="node017.html#common-func*mosek*task*analyzesolution"><tt class="tt">mosek.Task.analyzesolution</tt></a>
<br/>Print information related to the quality of the solution. </li>
<li><a href="node017.html#common-func*mosek*task*append"><tt class="tt">mosek.Task.append</tt></a>
<br/>Appends a number of variables or constraints to the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*appendcone"><tt class="tt">mosek.Task.appendcone</tt></a>
<br/>Appends a new cone constraint to the problem. </li>
<li><a href="node017.html#common-func*mosek*task*basiscond"><tt class="tt">mosek.Task.basiscond</tt></a>
<br/>Computes conditioning information for the basis matrix. </li>
<li><a href="node017.html#common-func*mosek*task*checkconvexity"><tt class="tt">mosek.Task.checkconvexity</tt></a>
<br/>Checks if a quadratic optimization problem is convex. </li>
<li><a href="node017.html#common-func*mosek*task*checkdata"><tt class="tt">mosek.Task.checkdata</tt></a>
<br/>Checks data of the task. </li>
<li><a href="node017.html#common-func*mosek*task*checkmemtask"><tt class="tt">mosek.Task.checkmem</tt></a>
<br/>Checks the memory allocated by the task. </li>
<li><a href="node017.html#common-func*mosek*task*chgbound"><tt class="tt">mosek.Task.chgbound</tt></a>
<br/>Changes the bounds for one constraint or variable. </li>
<li><a href="node017.html#common-func*mosek*task*commitchanges"><tt class="tt">mosek.Task.commitchanges</tt></a>
<br/>Commits all cached problem changes. </li>
<li><a href="node017.html#common-func*mosek*task*deletesolution"><tt class="tt">mosek.Task.deletesolution</tt></a>
<br/>Undefines a solution and frees the memory it uses. </li>
<li><a href="node017.html#common-func*mosek*task*dualsensitivity"><tt class="tt">mosek.Task.dualsensitivity</tt></a>
<br/>Performs sensitivity analysis on objective coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*getaij"><tt class="tt">mosek.Task.getaij</tt></a>
<br/>Obtains a single coefficient in linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getapiecenumnz"><tt class="tt">mosek.Task.getapiecenumnz</tt></a>
<br/>Obtains the number non-zeros in a rectangular piece of the linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslice"><tt class="tt">mosek.Task.getaslice</tt></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslice64"><tt class="tt">mosek.Task.getaslice</tt></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslicenumnz"><tt class="tt">mosek.Task.getaslicenumnz</tt></a>
<br/>Obtains the number of non-zeros in a row or column slice of the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslicenumnz64"><tt class="tt">mosek.Task.getaslicenumnz</tt></a>
<br/>Obtains the number of non-zeros in a slice of rows or columns of the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslicetrip"><tt class="tt">mosek.Task.getaslicetrip</tt></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix in triplet format. </li>
<li><a href="node017.html#common-func*mosek*task*getavec"><tt class="tt">mosek.Task.getavec</tt></a>
<br/>Obtains one row or column of the linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getavecnumnz"><tt class="tt">mosek.Task.getavecnumnz</tt></a>
<br/>Obtains the number of non-zero elements in one row or column of the linear constraint matrix </li>
<li><a href="node017.html#common-func*mosek*task*getbound"><tt class="tt">mosek.Task.getbound</tt></a>
<br/>Obtains bound information for one constraint or variable. </li>
<li><a href="node017.html#common-func*mosek*task*getboundslice"><tt class="tt">mosek.Task.getboundslice</tt></a>
<br/>Obtains bounds information for a sequence of variables or constraints. </li>
<li><a href="node017.html#common-func*mosek*task*getc"><tt class="tt">mosek.Task.getc</tt></a>
<br/>Obtains all objective coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*getcfix"><tt class="tt">mosek.Task.getcfix</tt></a>
<br/>Obtains the fixed term in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getcone"><tt class="tt">mosek.Task.getcone</tt></a>
<br/>Obtains a conic constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getconeinfo"><tt class="tt">mosek.Task.getconeinfo</tt></a>
<br/>Obtains information about a conic constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getconname64"><tt class="tt">mosek.Task.getconname</tt></a>
<br/>Obtains a name of a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getcslice"><tt class="tt">mosek.Task.getcslice</tt></a>
<br/>Obtains a sequence of coefficients from the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getdbi"><tt class="tt">mosek.Task.getdbi</tt></a>
<br/>Obtains the dual bound infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getdcni"><tt class="tt">mosek.Task.getdcni</tt></a>
<br/>Obtains the dual cone infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getdeqi"><tt class="tt">mosek.Task.getdeqi</tt></a>
<br/>Optains the dual equation infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getdouinf"><tt class="tt">mosek.Task.getdouinf</tt></a>
<br/>Obtains a double information item. </li>
<li><a href="node017.html#common-func*mosek*task*getdouparam"><tt class="tt">mosek.Task.getdouparam</tt></a>
<br/>Obtains a double parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getdualobj"><tt class="tt">mosek.Task.getdualobj</tt></a>
<br/>Obtains the dual objective value. </li>
<li><a href="node017.html#common-func*mosek*task*getinfeasiblesubproblem"><tt class="tt">mosek.Task.getinfeasiblesubproblem</tt></a>
<br/>Obtains an infeasible sub problem. </li>
<li><a href="node017.html#common-func*mosek*task*getinfindex"><tt class="tt">mosek.Task.getinfindex</tt></a>
<br/>Obtains the index of a named information item. </li>
<li><a href="node017.html#common-func*mosek*task*getinti"><tt class="tt">mosek.Task.getinti</tt></a>
<br/>Obtains the primal equation infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getintinf"><tt class="tt">mosek.Task.getintinf</tt></a>
<br/>Obtains an integer information item. </li>
<li><a href="node017.html#common-func*mosek*task*getintparam"><tt class="tt">mosek.Task.getintparam</tt></a>
<br/>Obtains an integer parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getintpntnumthreads"><tt class="tt">mosek.Task.getintpntnumthreads</tt></a>
<br/>Obtains the number of threads used by the interior-point optimizer. </li>
<li><a href="node017.html#common-func*mosek*task*getlintinf"><tt class="tt">mosek.Task.getlintinf</tt></a>
<br/>Obtains an integer information item. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumanz64"><tt class="tt">mosek.Task.getmaxnumanz</tt></a>
<br/>Obtains number of preallocated non-zeros in the linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumcon"><tt class="tt">mosek.Task.getmaxnumcon</tt></a>
<br/>Obtains the number of preallocated constraints in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumcone"><tt class="tt">mosek.Task.getmaxnumcone</tt></a>
<br/>Obtains the number of preallocated cones in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumqnz64"><tt class="tt">mosek.Task.getmaxnumqnz</tt></a>
<br/>Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumvar"><tt class="tt">mosek.Task.getmaxnumvar</tt></a>
<br/>Obtains the maximum number variables allowed. </li>
<li><a href="node017.html#common-func*mosek*task*getmemusagetask64"><tt class="tt">mosek.Task.getmemusage</tt></a>
<br/>Obtains information about the amount of memory used by a task. </li>
<li><a href="node017.html#common-func*mosek*task*getname64"><tt class="tt">mosek.Task.getname</tt></a>
<br/>Obtains the name of a cone, a variable or a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getnameapi64"><tt class="tt">mosek.Task.getname</tt></a>
<br/>Obtains the name of a cone, a variable or a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getnameindex"><tt class="tt">mosek.Task.getnameindex</tt></a>
<br/>Checks whether a name has been assigned and returns the index corresponding to the name. </li>
<li><a href="node017.html#common-func*mosek*task*getnamelen64"><tt class="tt">mosek.Task.getnamelen</tt></a>
<br/>Obtains the length of a problem item name. </li>
<li><a href="node017.html#common-func*mosek*task*getnumanz"><tt class="tt">mosek.Task.getnumanz</tt></a>
<br/>Obtains the number of non-zeros in the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getnumanz64"><tt class="tt">mosek.Task.getnumanz64</tt></a>
<br/>Obtains the number of non-zeros in the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getnumcon"><tt class="tt">mosek.Task.getnumcon</tt></a>
<br/>Obtains the number of constraints. </li>
<li><a href="node017.html#common-func*mosek*task*getnumcone"><tt class="tt">mosek.Task.getnumcone</tt></a>
<br/>Obtains the number of cones. </li>
<li><a href="node017.html#common-func*mosek*task*getnumconemem"><tt class="tt">mosek.Task.getnumconemem</tt></a>
<br/>Obtains the number of members in a cone. </li>
<li><a href="node017.html#common-func*mosek*task*getnumintvar"><tt class="tt">mosek.Task.getnumintvar</tt></a>
<br/>Obtains the number of integer-constrained variables. </li>
<li><a href="node017.html#common-func*mosek*task*getnumparam"><tt class="tt">mosek.Task.getnumparam</tt></a>
<br/>Obtains the number of parameters of a given type. </li>
<li><a href="node017.html#common-func*mosek*task*getnumqconknz"><tt class="tt">mosek.Task.getnumqconknz</tt></a>
<br/>Obtains the number of non-zero quadratic terms in a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getnumqconknz64"><tt class="tt">mosek.Task.getnumqconknz64</tt></a>
<br/>Obtains the number of non-zero quadratic terms in a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getnumqobjnz"><tt class="tt">mosek.Task.getnumqobjnz</tt></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getnumqobjnz64"><tt class="tt">mosek.Task.getnumqobjnz64</tt></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getnumvar"><tt class="tt">mosek.Task.getnumvar</tt></a>
<br/>Obtains the number of variables. </li>
<li><a href="node017.html#common-func*mosek*task*getobjname64"><tt class="tt">mosek.Task.getobjname</tt></a>
<br/>Obtains the name assigned to the objective function. </li>
<li><a href="node017.html#common-func*mosek*task*getobjsense"><tt class="tt">mosek.Task.getobjsense</tt></a>
<br/>Gets the objective sense. </li>
<li><a href="node017.html#common-func*mosek*task*getpbi"><tt class="tt">mosek.Task.getpbi</tt></a>
<br/>Obtains the primal bound infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getpcni"><tt class="tt">mosek.Task.getpcni</tt></a>
<br/>Obtains the primal cone infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getpeqi"><tt class="tt">mosek.Task.getpeqi</tt></a>
<br/>Obtains the primal equation infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getprimalobj"><tt class="tt">mosek.Task.getprimalobj</tt></a>
<br/>Obtains the primal objective value. </li>
<li><a href="node017.html#common-func*mosek*task*getprobtype"><tt class="tt">mosek.Task.getprobtype</tt></a>
<br/>Obtains the problem type. </li>
<li><a href="node017.html#common-func*mosek*task*getqconk"><tt class="tt">mosek.Task.getqconk</tt></a>
<br/>Obtains all the quadratic terms in a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getqconk64"><tt class="tt">mosek.Task.getqconk64</tt></a>
<br/>Obtains all the quadratic terms in a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getqobj"><tt class="tt">mosek.Task.getqobj</tt></a>
<br/>Obtains all the quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getqobj64"><tt class="tt">mosek.Task.getqobj64</tt></a>
<br/>Obtains all the quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getqobjij"><tt class="tt">mosek.Task.getqobjij</tt></a>
<br/>Obtains one coefficient from the quadratic term of the objective </li>
<li><a href="node017.html#common-func*mosek*task*getreducedcosts"><tt class="tt">mosek.Task.getreducedcosts</tt></a>
<br/>Obtains the difference of (slx-sux) for a sequence of variables. </li>
<li><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">mosek.Task.getsolution</tt></a>
<br/>Obtains the complete solution. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">mosek.Task.getsolutioni</tt></a>
<br/>Obtains the solution for a single constraint or variable. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a>
<br/>Obtains information about a solution. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutionslice"><tt class="tt">mosek.Task.getsolutionslice</tt></a>
<br/>Obtains a slice of the solution. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">mosek.Task.getsolutionstatus</tt></a>
<br/>Obtains information about the problem and solution statuses. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutionstatuskeyslice"><tt class="tt">mosek.Task.getsolutionstatuskeyslice</tt></a>
<br/>Obtains a slice of the solution status keys. </li>
<li><a href="node017.html#common-func*mosek*task*gettaskname64"><tt class="tt">mosek.Task.gettaskname64</tt></a>
<br/>Obtains the task name. </li>
<li><a href="node017.html#common-func*mosek*task*getvarbranchdir"><tt class="tt">mosek.Task.getvarbranchdir</tt></a>
<br/>Obtains the branching direction for a variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvarbranchorder"><tt class="tt">mosek.Task.getvarbranchorder</tt></a>
<br/>Obtains the branching priority for a variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvarbranchpri"><tt class="tt">mosek.Task.getvarbranchpri</tt></a>
<br/>Obtains the branching priority for a variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvarname64"><tt class="tt">mosek.Task.getvarname</tt></a>
<br/>Obtains a name of a variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvartype"><tt class="tt">mosek.Task.getvartype</tt></a>
<br/>Gets the variable type of one variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvartypelist"><tt class="tt">mosek.Task.getvartypelist</tt></a>
<br/>Obtains the variable type for one or more variables. </li>
<li><a href="node017.html#common-func*mosek*task*initbasissolve"><tt class="tt">mosek.Task.initbasissolve</tt></a>
<br/>Prepare a task for basis solver. </li>
<li><a href="node017.html#common-func*mosek*task*inputdata"><tt class="tt">mosek.Task.inputdata</tt></a>
<br/>Input the linear part of an optimization task in one function call. </li>
<li><a href="node017.html#common-func*mosek*task*inputdata64"><tt class="tt">mosek.Task.inputdata</tt></a>
<br/>Input the linear part of an optimization task in one function call. </li>
<li><a href="node017.html#common-func*mosek*task*isdouparname"><tt class="tt">mosek.Task.isdouparname</tt></a>
<br/>Checks a double parameter name. </li>
<li><a href="node017.html#common-func*mosek*task*isintparname"><tt class="tt">mosek.Task.isintparname</tt></a>
<br/>Checks an integer parameter name. </li>
<li><a href="node017.html#common-func*mosek*task*isstrparname"><tt class="tt">mosek.Task.isstrparname</tt></a>
<br/>Checks a string parameter name. </li>
<li><a href="node017.html#common-func*mosek*task*linkfiletotaskstream"><tt class="tt">mosek.Task.linkfiletostream</tt></a>
<br/>Directs all output from a task stream to a file. </li>
<li><a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><tt class="tt">mosek.Task.makesolutionstatusunknown</tt></a>
<br/>Sets the solution status to unknown. </li>
<li><a href="node017.html#common-func*mosek*task*netextraction"><tt class="tt">mosek.Task.netextraction</tt></a>
<br/>Finds embedded network structure. </li>
<li><a href="node017.html#common-func*mosek*task*netoptimize"><tt class="tt">mosek.Task.netoptimize</tt></a>
<br/>Optimizes a pure network flow problem. </li>
<li><a href="node017.html#common-func*mosek*task*optimizeconcurrent"><tt class="tt">mosek.Task.optimizeconcurrent</tt></a>
<br/>Optimize a given task with several optimizers concurrently. </li>
<li><a href="node017.html#common-func*mosek*task*optimizersummary"><tt class="tt">mosek.Task.optimizersummary</tt></a>
<br/>Prints a short summary with optimizer statistics for last optimization. </li>
<li><a href="node017.html#common-func*mosek*task*optimizetrm"><tt class="tt">mosek.Task.optimize</tt></a>
<br/>Optimizes the problem. </li>
<li><a href="node017.html#common-func*mosek*task*primalsensitivity"><tt class="tt">mosek.Task.primalsensitivity</tt></a>
<br/>Perform sensitivity analysis on bounds. </li>
<li><a href="node017.html#common-func*mosek*task*printdata"><tt class="tt">mosek.Task.printdata</tt></a>
<br/>Prints a part of the problem data to a stream. </li>
<li><a href="node017.html#common-func*mosek*task*probtypetostr"><tt class="tt">mosek.Task.probtypetostr</tt></a>
<br/>Obtains a string containing the name of a problem type given. </li>
<li><a href="node017.html#common-func*mosek*task*prostatostr"><tt class="tt">mosek.Task.prostatostr</tt></a>
<br/>Obtains a string containing the name of a problem status given. </li>
<li><a href="node017.html#common-func*mosek*task*putaij"><tt class="tt">mosek.Task.putaij</tt></a>
<br/>Changes a single value in the linear coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*putaijlist"><tt class="tt">mosek.Task.putaijlist</tt></a>
<br/>Changes one or more coefficients in the linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">mosek.Task.putavec</tt></a>
<br/>Replaces all elements in one row or column of the linear coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*putaveclist"><tt class="tt">mosek.Task.putaveclist</tt></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </li>
<li><a href="node017.html#common-func*mosek*task*putaveclist64"><tt class="tt">mosek.Task.putaveclist</tt></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </li>
<li><a href="node017.html#common-func*mosek*task*putbound"><tt class="tt">mosek.Task.putbound</tt></a>
<br/>Changes the bound for either one constraint or one variable. </li>
<li><a href="node017.html#common-func*mosek*task*putboundlist"><tt class="tt">mosek.Task.putboundlist</tt></a>
<br/>Changes the bounds of constraints or variables. </li>
<li><a href="node017.html#common-func*mosek*task*putboundslice"><tt class="tt">mosek.Task.putboundslice</tt></a>
<br/>Modifies bounds. </li>
<li><a href="node017.html#common-func*mosek*task*putcfix"><tt class="tt">mosek.Task.putcfix</tt></a>
<br/>Replaces the fixed term in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putcj"><tt class="tt">mosek.Task.putcj</tt></a>
<br/>Modifies one linear coefficient in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putclist"><tt class="tt">mosek.Task.putclist</tt></a>
<br/>Modifies a part of the linear objective coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*putcone"><tt class="tt">mosek.Task.putcone</tt></a>
<br/>Replaces a conic constraint. </li>
<li><a href="node017.html#common-func*mosek*task*putdouparam"><tt class="tt">mosek.Task.putdouparam</tt></a>
<br/>Sets a double parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putintparam"><tt class="tt">mosek.Task.putintparam</tt></a>
<br/>Sets an integer parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">mosek.Task.putmaxnumanz</tt></a>
<br/>The function changes the size of the preallocated storage for linear coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumanz64"><tt class="tt">mosek.Task.putmaxnumanz</tt></a>
<br/>The function changes the size of the preallocated storage for linear coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumcon"><tt class="tt">mosek.Task.putmaxnumcon</tt></a>
<br/>Sets the number of preallocated constraints in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumcone"><tt class="tt">mosek.Task.putmaxnumcone</tt></a>
<br/>Sets the number of preallocated conic constraints in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><tt class="tt">mosek.Task.putmaxnumqnz</tt></a>
<br/>Changes the size of the preallocated storage for quadratic terms. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumqnz64"><tt class="tt">mosek.Task.putmaxnumqnz</tt></a>
<br/>Changes the size of the preallocated storage for quadratic terms. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumvar"><tt class="tt">mosek.Task.putmaxnumvar</tt></a>
<br/>Sets the number of preallocated variables in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*putnadouparam"><tt class="tt">mosek.Task.putnadouparam</tt></a>
<br/>Sets a double parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putnaintparam"><tt class="tt">mosek.Task.putnaintparam</tt></a>
<br/>Sets an integer parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putname"><tt class="tt">mosek.Task.putname</tt></a>
<br/>Assigns a name to a problem item. </li>
<li><a href="node017.html#common-func*mosek*task*putnastrparam"><tt class="tt">mosek.Task.putnastrparam</tt></a>
<br/>Sets a string parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putobjname"><tt class="tt">mosek.Task.putobjname</tt></a>
<br/>Assigns a new name to the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putobjsense"><tt class="tt">mosek.Task.putobjsense</tt></a>
<br/>Sets the objective sense. </li>
<li><a href="node017.html#common-func*mosek*task*putparam"><tt class="tt">mosek.Task.putparam</tt></a>
<br/>Modifies the value of parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putqcon"><tt class="tt">mosek.Task.putqcon</tt></a>
<br/>Replaces all quadratic terms in constraints. </li>
<li><a href="node017.html#common-func*mosek*task*putqconk"><tt class="tt">mosek.Task.putqconk</tt></a>
<br/>Replaces all quadratic terms in a single constraint. </li>
<li><a href="node017.html#common-func*mosek*task*putqobj"><tt class="tt">mosek.Task.putqobj</tt></a>
<br/>Replaces all quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putqobjij"><tt class="tt">mosek.Task.putqobjij</tt></a>
<br/>Replaces one coefficient in the quadratic term in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putsolution"><tt class="tt">mosek.Task.putsolution</tt></a>
<br/>Inserts a solution. </li>
<li><a href="node017.html#common-func*mosek*task*putsolutioni"><tt class="tt">mosek.Task.putsolutioni</tt></a>
<br/>Sets the primal and dual solution information for a single constraint or variable. </li>
<li><a href="node017.html#common-func*mosek*task*putsolutionyi"><tt class="tt">mosek.Task.putsolutionyi</tt></a>
<br/>Inputs the dual variable of a solution. </li>
<li><a href="node017.html#common-func*mosek*task*putstrparam"><tt class="tt">mosek.Task.putstrparam</tt></a>
<br/>Sets a string parameter. </li>
<li><a href="node017.html#common-func*mosek*task*puttaskname"><tt class="tt">mosek.Task.puttaskname</tt></a>
<br/>Assigns a new name to the task. </li>
<li><a href="node017.html#common-func*mosek*task*putvarbranchorder"><tt class="tt">mosek.Task.putvarbranchorder</tt></a>
<br/>Assigns a branching priority and direction to a variable. </li>
<li><a href="node017.html#common-func*mosek*task*putvartype"><tt class="tt">mosek.Task.putvartype</tt></a>
<br/>Sets the variable type of one variable. </li>
<li><a href="node017.html#common-func*mosek*task*putvartypelist"><tt class="tt">mosek.Task.putvartypelist</tt></a>
<br/>Sets the variable type for one or more variables. </li>
<li><a href="node017.html#common-func*mosek*task*readbranchpriorities"><tt class="tt">mosek.Task.readbranchpriorities</tt></a>
<br/>Reads branching priority data from a file. </li>
<li><a href="node017.html#common-func*mosek*task*readdata"><tt class="tt">mosek.Task.readdata</tt></a>
<br/>Reads problem data from a file. </li>
<li><a href="node017.html#common-func*mosek*task*readparamfile"><tt class="tt">mosek.Task.readparamfile</tt></a>
<br/>Reads a parameter file. </li>
<li><a href="node017.html#common-func*mosek*task*readsolution"><tt class="tt">mosek.Task.readsolution</tt></a>
<br/>Reads a solution from a file. </li>
<li><a href="node017.html#common-func*mosek*task*readsummary"><tt class="tt">mosek.Task.readsummary</tt></a>
<br/>Prints information about last file read. </li>
<li><a href="node017.html#common-func*mosek*task*relaxprimal"><tt class="tt">mosek.Task.relaxprimal</tt></a>
<br/>Creates a problem that finds the minimal change to the bounds that makes an infeasible problem feasible. </li>
<li><a href="node017.html#common-func*mosek*task*remove"><tt class="tt">mosek.Task.remove</tt></a>
<br/>The function removes a number of constraints or variables. </li>
<li><a href="node017.html#common-func*mosek*task*removecone"><tt class="tt">mosek.Task.removecone</tt></a>
<br/>Removes a conic constraint from the problem. </li>
<li><a href="node017.html#common-func*mosek*task*resizetask"><tt class="tt">mosek.Task.resizetask</tt></a>
<br/>Resizes an optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*sensitivityreport"><tt class="tt">mosek.Task.sensitivityreport</tt></a>
<br/>Creates a sensitivity report. </li>
<li><a href="node017.html#common-func*mosek*task*set-stream"><tt class="tt">mosek.Task.set_Stream</tt></a>
<br/>Attach a stream call-back handler. </li>
<li><a href="node017.html#common-func*mosek*task*setdefaults"><tt class="tt">mosek.Task.setdefaults</tt></a>
<br/>Resets all parameters values. </li>
<li><a href="node017.html#common-func*mosek*task*sktostr"><tt class="tt">mosek.Task.sktostr</tt></a>
<br/>Obtains a status key string. </li>
<li><a href="node017.html#common-func*mosek*task*solstatostr"><tt class="tt">mosek.Task.solstatostr</tt></a>
<br/>Obtains a solution status string. </li>
<li><a href="node017.html#common-func*mosek*task*solutiondef"><tt class="tt">mosek.Task.solutiondef</tt></a>
<br/>Checks whether a solution is defined. </li>
<li><a href="node017.html#common-func*mosek*task*solutionsummary"><tt class="tt">mosek.Task.solutionsummary</tt></a>
<br/>Prints a short summary of the current solutions. </li>
<li><a href="node017.html#common-func*mosek*task*solvewithbasis"><tt class="tt">mosek.Task.solvewithbasis</tt></a>
<br/>Solve a linear equation system involving a basis matrix. </li>
<li><a href="node017.html#common-func*mosek*task*strtoconetype"><tt class="tt">mosek.Task.strtoconetype</tt></a>
<br/>Obtains a cone type code. </li>
<li><a href="node017.html#common-func*mosek*task*strtosk"><tt class="tt">mosek.Task.strtosk</tt></a>
<br/>Obtains a status key. </li>
<li><a href="node017.html#common-func*mosek*task*undefsolution"><tt class="tt">mosek.Task.undefsolution</tt></a>
<br/>Undefines a solution. </li>
<li><a href="node017.html#common-func*mosek*task*writebranchpriorities"><tt class="tt">mosek.Task.writebranchpriorities</tt></a>
<br/>Writes branching priority data to a file. </li>
<li><a href="node017.html#common-func*mosek*task*writedata"><tt class="tt">mosek.Task.writedata</tt></a>
<br/>Writes problem data to a file. </li>
<li><a href="node017.html#common-func*mosek*task*writeparamfile"><tt class="tt">mosek.Task.writeparamfile</tt></a>
<br/>Writes all the parameters to a parameter file. </li>
<li><a href="node017.html#common-func*mosek*task*writesolution"><tt class="tt">mosek.Task.writesolution</tt></a>
<br/>Write a solution to a file. </li>
</ul>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Task.analyzeproblem</tt></span>

<p> <a name="func*mosek*task*analyzeproblem">&#09;</a><a name="common-func*mosek*task*analyzeproblem"></a> <a name="idx-103068592">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void analyzeproblem (streamtype whichstream)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The function analyze the data of task and writes out a report.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.analyzesolution</tt></span>

<p> <a name="func*mosek*task*analyzesolution">&#09;</a><a name="common-func*mosek*task*analyzesolution"></a> <a name="idx-103035392">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void analyzesolution (
    streamtype whichstream,
    soltype whichsol);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Print information related to the quality of the solution and other solution statistics.</p>

<p>By default this function prints information about the largest infeasibilites in the solution, the primal (and possibly dual) objective value and the solution status.</p>

<p>Following parameters can be used to configure the printed statistics: </p>

<ul class="itemize">
<li><a href="node018.html#common-const*mosek*iparam*ana-sol-basis"><tt class="tt">mosek.iparam.ana_sol_basis</tt></a>. Enables or disables printing of statistics specific to the basis solution (condition number, number of basic variables etc.). Default is on. </li>
<li><a href="node018.html#common-const*mosek*iparam*ana-sol-print-violated"><tt class="tt">mosek.iparam.ana_sol_print_violated</tt></a>. Enables or disables listing names of all constraints (both primal and dual) which are violated by the solution. Default is off. </li>
<li><a href="node018.html#common-const*mosek*dparam*ana-sol-infeas-tol"><tt class="tt">mosek.dparam.ana_sol_infeas_tol</tt></a>. The tolerance defining when a constraint is considered violated. If a constraint is violated more than this, it will be listed in the summary. </li>
</ul>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getpeqi"><tt class="tt">mosek.Task.getpeqi</tt></a></dt>
<dd>
<p> Obtains the primal equation infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdeqi"><tt class="tt">mosek.Task.getdeqi</tt></a></dt>
<dd>
<p> Optains the dual equation infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getpbi"><tt class="tt">mosek.Task.getpbi</tt></a></dt>
<dd>
<p> Obtains the primal bound infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdbi"><tt class="tt">mosek.Task.getdbi</tt></a></dt>
<dd>
<p> Obtains the dual bound infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdcni"><tt class="tt">mosek.Task.getdcni</tt></a></dt>
<dd>
<p> Obtains the dual cone infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getpcni"><tt class="tt">mosek.Task.getpcni</tt></a></dt>
<dd>
<p> Obtains the primal cone infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">mosek.Task.getsolutionstatus</tt></a></dt>
<dd>
<p> Obtains information about the problem and solution statuses.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.append</tt></span>

<p> <a name="func*mosek*task*append">&#09;</a><a name="common-func*mosek*task*append"></a> <a name="idx-103099136">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void append (
    accmode accmode,
    int num);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of constraints or variables which should be appended.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Appends a number of constraints or variables to the model. Appended constraints will be declared free and appended variables will be fixed at the level zero. Please note that MOSEK will automatically expand the problem dimension to accommodate the additional constraints and variables.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*remove"><tt class="tt">mosek.Task.remove</tt></a></dt>
<dd>
<p> The function removes a number of constraints or variables.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.appendcone</tt></span>

<p> <a name="func*mosek*task*appendcone">&#09;</a><a name="common-func*mosek*task*appendcone"></a> <a name="idx-103116024">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void appendcone (
    conetype conetype,
    double conepar,
    int[] submem);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (input)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (input)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">submem</tt> (input)</dt>
<dd>Variable subscripts of the members in the cone.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void appendcone (
    conetype conetype,
    double conepar,
    int nummem,
    int[] submem);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (input)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (input)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">nummem</tt> (input)</dt>
<dd>Number of member variables in the cone.</dd>
<dt><tt class="tt">submem</tt> (input)</dt>
<dd>Variable subscripts of the members in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Appends a new conic constraint to the problem. Hence, add a constraint  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math695.png" alt="\begin{displaymath}\nonumber{}\bar{x}\in{}\mathcal{C}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  to the problem where <span class="math"><img src="math/math57.png" alt="[[MathCmd 57]]"/></span> is a convex cone. <span class="math"><img src="math/math420.png" alt="[[MathCmd 420]]"/></span> is a subset of the variables which will be specified by the argument <tt class="tt">submem</tt>.</p>

<p>Depending on the value of <tt class="tt">conetype</tt> this function appends a normal (<a href="node020.html#common-const*mosek*conetype*quad"><tt class="tt">mosek.conetype.quad</tt></a>) or rotated quadratic cone (<a href="node020.html#common-const*mosek*conetype*rquad"><tt class="tt">mosek.conetype.rquad</tt></a>). Define </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math698.png" alt="\begin{displaymath}\nonumber{}\bar{x}=x_{{\mathtt{submem}[0]}},\ldots ,x_{{\mathtt{submem}[\mathtt{nummem}-1]}}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>. Depending on the value of <tt class="tt">conetype</tt> this function appends one of the constraints: </p>

<ul class="itemize">
<li>
<p>Quadratic cone (<a href="node020.html#common-const*mosek*conetype*quad"><tt class="tt">mosek.conetype.quad</tt></a>) : </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math699.png" alt="\begin{displaymath}\nonumber{}\bar{x}_{0}\geq{}\sqrt{\sum _{{i=1}}^{{i<\mathtt{nummem}}}\bar{x}_{i}^{2}}\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
<li>
<p>Rotated quadratic cone (<a href="node020.html#common-const*mosek*conetype*rquad"><tt class="tt">mosek.conetype.rquad</tt></a>) : </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math700.png" alt="\begin{displaymath}\nonumber{}2\bar{x}_{0}\bar{x}_{1}\geq{}\sum _{{i=2}}^{{i<\mathtt{nummem}}}\bar{x}^{2}_{i},\quad{}\bar{x}_{{0}},\bar{x}_{1}\geq{}0\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
</ul>

<p>Please note that the sets of variables appearing in different conic constraints must be disjoint.</p>

<p>For an explained code example see Section <a title="5.4. Conic optimization" href="node007.html#sec:conic-opt">5.4</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.basiscond</tt></span>

<p> <a name="func*mosek*task*basiscond">&#09;</a><a name="common-func*mosek*task*basiscond"></a> <a name="idx-103150944">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void basiscond (
    out double nrmbasis,
    out double nrminvbasis);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">nrmbasis</tt> (output)</dt>
<dd>An estimate for the 1 norm of the basis.</dd>
<dt><tt class="tt">nrminvbasis</tt> (output)</dt>
<dd>An estimate for the 1 norm of the inverse of the basis.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>If a basic solution is available and it defines a nonsingular basis, then this function computes the 1-norm estimate of the basis matrix and an 1-norm estimate for the inverse of the basis matrix. The 1-norm estimates are computed using the method outlined in [<a href="node029.html#STEWART:98:A" class="citation">9</a>, pp. 388-391].</p>

<p>By defintion the 1-norm condition number of a matrix <span class="math"><span class="mi">B</span></span> is defined as  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math701.png" alt="\begin{displaymath}\nonumber{}\kappa _{1}(B):=\left\|B\right\|_{1}\left\|B^{{-1}}\right\|.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Moreover, the larger the condition number is the harder it is to solve linear equation systems involving <span class="math"><span class="mi">B</span></span>. Given estimates for <span class="math"><img src="math/math702.png" alt="[[MathCmd 702]]"/></span> and <span class="math"><img src="math/math703.png" alt="[[MathCmd 703]]"/></span> it is also possible to estimate <span class="math"><img src="math/math704.png" alt="[[MathCmd 704]]"/></span>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.checkconvexity</tt></span>

<p> <a name="func*mosek*task*checkconvexity">&#09;</a><a name="common-func*mosek*task*checkconvexity"></a> <a name="idx-103172864">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void checkconvexity ()
</pre>
</dd>
<dt>Description:</dt>
<dd>
<p>This function checks if a quadratic optimization problem is convex. The amount of checking is controlled by <a href="node018.html#common-const*mosek*iparam*check-convexity"><tt class="tt">mosek.iparam.check_convexity</tt></a>.</p>

<p>The function throws an exception if the problem is not convex. </p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node018.html#common-const*mosek*iparam*check-convexity"><tt class="tt">mosek.iparam.check_convexity</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.checkdata</tt></span>

<p> <a name="func*mosek*task*checkdata">&#09;</a><a name="common-func*mosek*task*checkdata"></a> <a name="idx-103181056">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void checkdata ()
</pre>
</dd>
<dt>Description:</dt>
<dd>Checks the data of the optimization task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.checkmem</tt></span>

<p> <a name="func*mosek*task*checkmemtask">&#09;</a><a name="common-func*mosek*task*checkmemtask"></a> <a name="idx-103189464">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void checkmem (
    string file,
    int line);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">file</tt> (input)</dt>
<dd>File from which the function is called.</dd>
<dt><tt class="tt">line</tt> (input)</dt>
<dd>Line in the file from which the function is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks the memory allocated by the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.chgbound</tt></span>

<p> <a name="func*mosek*task*chgbound">&#09;</a><a name="common-func*mosek*task*chgbound"></a> <a name="idx-103196000">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void chgbound (
    accmode accmode,
    int i,
    int lower,
    int finite,
    double value);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable for which the bounds should be changed.</dd>
<dt><tt class="tt">lower</tt> (input)</dt>
<dd>If non-zero, then the lower bound is changed, otherwise the upper bound is changed.</dd>
<dt><tt class="tt">finite</tt> (input)</dt>
<dd>If non-zero, then <tt class="tt">value</tt> is assumed to be finite.</dd>
<dt><tt class="tt">value</tt> (input)</dt>
<dd>New value for the bound.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Changes a bound for one constraint or variable. If <tt class="tt">accmode</tt> equals <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, a constraint bound is changed, otherwise a variable bound is changed.</p>

<p>If <tt class="tt">lower</tt> is non-zero, then the lower bound is changed as follows:  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math705.png" alt="\begin{displaymath}\nonumber{}\mbox{new lower bound}=\left\lbrace{}\begin{array}{ll}\nonumber{}-\infty , & \mathtt{finite}=0,\\\nonumber{}\mathtt{value} & \mbox{otherwise}.\end{array}\right.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Otherwise if <tt class="tt">lower</tt> is zero, then </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math706.png" alt="\begin{displaymath}\nonumber{}\mbox{new upper bound}=\left\lbrace{}\begin{array}{ll}\nonumber{}\infty , & \mathtt{finite}=0,\\\nonumber{}\mathtt{value} & \mbox{otherwise}.\end{array}\right.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> Please note that this function automatically updates the bound key for bound, in particular, if the lower and upper bounds are identical, the bound key is changed to <tt class="tt">fixed</tt>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putbound"><tt class="tt">mosek.Task.putbound</tt></a></dt>
<dd>
<p> Changes the bound for either one constraint or one variable.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-inf"><tt class="tt">mosek.dparam.data_tol_bound_inf</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-wrn"><tt class="tt">mosek.dparam.data_tol_bound_wrn</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.commitchanges</tt></span>

<p> <a name="func*mosek*task*commitchanges">&#09;</a><a name="common-func*mosek*task*commitchanges"></a> <a name="idx-99047400">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void commitchanges ()
</pre>
</dd>
<dt>Description:</dt>
<dd>Commits all cached problem changes to the task. It is usually not necessary explicitly to call this function since changes will be committed automatically when required.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.deletesolution</tt></span>

<p> <a name="func*mosek*task*deletesolution">&#09;</a><a name="common-func*mosek*task*deletesolution"></a> <a name="idx-99038776">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void deletesolution (soltype whichsol)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Undefines a solution and frees the memory it uses.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.dualsensitivity</tt></span>

<p> <a name="func*mosek*task*dualsensitivity">&#09;</a><a name="common-func*mosek*task*dualsensitivity"></a> <a name="idx-99056456">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void dualsensitivity (
    int[] subj,
    double[] leftpricej,
    double[] rightpricej,
    double[] leftrangej,
    double[] rightrangej);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Index of objective coefficients to analyze.</dd>
<dt><tt class="tt">leftpricej</tt> (output)</dt>
<dd><span class="math"><img src="math/math707.png" alt="[[MathCmd 707]]"/></span> is the left shadow price for the coefficients with index <span class="math"><img src="math/math708.png" alt="[[MathCmd 708]]"/></span>.</dd>
<dt><tt class="tt">rightpricej</tt> (output)</dt>
<dd><span class="math"><img src="math/math709.png" alt="[[MathCmd 709]]"/></span> is the right shadow price for the coefficients with index <span class="math"><img src="math/math708.png" alt="[[MathCmd 708]]"/></span>.</dd>
<dt><tt class="tt">leftrangej</tt> (output)</dt>
<dd><span class="math"><img src="math/math711.png" alt="[[MathCmd 711]]"/></span> is the left range <span class="math"><img src="math/math633.png" alt="[[MathCmd 633]]"/></span> for the coefficient with index <span class="math"><img src="math/math708.png" alt="[[MathCmd 708]]"/></span>.</dd>
<dt><tt class="tt">rightrangej</tt> (output)</dt>
<dd><span class="math"><img src="math/math714.png" alt="[[MathCmd 714]]"/></span> is the right range <span class="math"><img src="math/math634.png" alt="[[MathCmd 634]]"/></span> for the coefficient with index <span class="math"><img src="math/math708.png" alt="[[MathCmd 708]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Calculates sensitivity information for objective coefficients. The indexes of the coefficients to analyze are </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math717.png" alt="\begin{displaymath}\nonumber{}\lbrace{}\mathtt{subj}[i]|i\in{}0,\ldots ,\mathtt{numj}-1\rbrace{}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> The results are returned so that e.g <span class="math"><img src="math/math718.png" alt="[[MathCmd 718]]"/></span> is the left shadow price of the objective coefficient with index <span class="math"><img src="math/math719.png" alt="[[MathCmd 719]]"/></span>.</p>

<p>The type of sensitivity analysis to perform (basis or optimal partition) is controlled by the parameter <a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">mosek.iparam.sensitivity_type</tt></a>.</p>

<p>For an example, please see Section <a title="12.5. Sensitivity analysis from the MOSEK API" href="node014.html#chap-sensitivity-sec-apiex">12.5</a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*primalsensitivity"><tt class="tt">mosek.Task.primalsensitivity</tt></a></dt>
<dd>
<p> Perform sensitivity analysis on bounds.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*sensitivityreport"><tt class="tt">mosek.Task.sensitivityreport</tt></a></dt>
<dd>
<p> Creates a sensitivity report.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">mosek.iparam.sensitivity_type</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity"><tt class="tt">mosek.iparam.log_sensitivity</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity-opt"><tt class="tt">mosek.iparam.log_sensitivity_opt</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getaij</tt></span>

<p> <a name="func*mosek*task*getaij">&#09;</a><a name="common-func*mosek*task*getaij"></a> <a name="idx-99109416">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public double getaij (
    int i,
    int j);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Row index of the coefficient to be returned.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Column index of the coefficient to be returned.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getaij (
    int i,
    int j,
    out double aij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Row index of the coefficient to be returned.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Column index of the coefficient to be returned.</dd>
<dt><tt class="tt">aij</tt> (output)</dt>
<dd>The required coefficient <span class="math"><img src="math/math720.png" alt="[[MathCmd 720]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a single coefficient in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getapiecenumnz</tt></span>

<p> <a name="func*mosek*task*getapiecenumnz">&#09;</a><a name="common-func*mosek*task*getapiecenumnz"></a> <a name="idx-99116960">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getapiecenumnz (
    int firsti,
    int lasti,
    int firstj,
    int lastj);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">firsti</tt> (input)</dt>
<dd>Index of the first row in the rectangular piece.</dd>
<dt><tt class="tt">lasti</tt> (input)</dt>
<dd>Index of the last row plus one in the rectangular piece.</dd>
<dt><tt class="tt">firstj</tt> (input)</dt>
<dd>Index of the first column in the rectangular piece.</dd>
<dt><tt class="tt">lastj</tt> (input)</dt>
<dd>Index of the last column plus one in the rectangular piece.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getapiecenumnz (
    int firsti,
    int lasti,
    int firstj,
    int lastj,
    out int numnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">firsti</tt> (input)</dt>
<dd>Index of the first row in the rectangular piece.</dd>
<dt><tt class="tt">lasti</tt> (input)</dt>
<dd>Index of the last row plus one in the rectangular piece.</dd>
<dt><tt class="tt">firstj</tt> (input)</dt>
<dd>Index of the first column in the rectangular piece.</dd>
<dt><tt class="tt">lastj</tt> (input)</dt>
<dd>Index of the last column plus one in the rectangular piece.</dd>
<dt><tt class="tt">numnz</tt> (output)</dt>
<dd>Number of non-zero <span class="math"><span class="mi">A</span></span> elements in the rectangular piece.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the number non-zeros in a rectangular piece of <span class="math"><span class="mi">A</span></span>, i.e. the number  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math721.png" alt="\begin{displaymath}\nonumber{}\left|\lbrace{}(i,j):~a_{{i,j}}\not=0,~\mathtt{firsti}\leq{}i\leq{}\mathtt{lasti}-1,~\mathtt{firstj}\leq{}j\leq{}\mathtt{lastj}-1\rbrace{}\right|\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  where <span class="math"><img src="math/math722.png" alt="[[MathCmd 722]]"/></span> means the number of elements in the set <span class="math"><img src="math/math723.png" alt="[[MathCmd 723]]"/></span>.</p>

<p>This function is not an efficient way to obtain the number of non-zeros in one row or column. In that case use the function <a href="node017.html#common-func*mosek*task*getavecnumnz"><tt class="tt">mosek.Task.getavecnumnz</tt></a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getavecnumnz"><tt class="tt">mosek.Task.getavecnumnz</tt></a></dt>
<dd>
<p> Obtains the number of non-zero elements in one row or column of the linear constraint matrix</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getaslicenumnz"><tt class="tt">mosek.Task.getaslicenumnz</tt></a></dt>
<dd>
<p> Obtains the number of non-zeros in a row or column slice of the coefficient matrix.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getaslice</tt></span>

<p> <a name="func*mosek*task*getaslice">&#09;</a><a name="common-func*mosek*task*getaslice"></a> <a name="idx-99113512">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getaslice (
    accmode accmode,
    int first,
    int last,
    ref int surp,
    int[] ptrb,
    int[] ptre,
    int[] sub,
    double[] val);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether a column-slice or a row-slice is requested.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column in the sequence <b>plus one</b>.</dd>
<dt><tt class="tt">surp</tt> (input/output)</dt>
<dd>The required rows and columns are stored sequentially in <tt class="tt">sub</tt> and <tt class="tt">val</tt> starting from position <tt class="tt">maxnumnz-surp[0]</tt>. Upon return <tt class="tt">surp</tt> has been decremented by the total number of non-zero elements in the rows and columns obtained.</dd>
<dt><tt class="tt">ptrb</tt> (output)</dt>
<dd><tt class="tt">ptrb[t]</tt> is an index pointing to the first element in the <span class="math"><span class="mi">t</span></span>th row or column obtained.</dd>
<dt><tt class="tt">ptre</tt> (output)</dt>
<dd><tt class="tt">ptre[t]</tt> is an index pointing to the last element plus one in the <span class="math"><span class="mi">t</span></span>th row or column obtained.</dd>
<dt><tt class="tt">sub</tt> (output)</dt>
<dd>Contains the row or column subscripts.</dd>
<dt><tt class="tt">val</tt> (output)</dt>
<dd>Contains the coefficient values.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a sequence of rows or columns from <span class="math"><span class="mi">A</span></span> in sparse format.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getaslicenumnz"><tt class="tt">mosek.Task.getaslicenumnz</tt></a></dt>
<dd>
<p> Obtains the number of non-zeros in a row or column slice of the coefficient matrix.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getaslice</tt></span>

<p> <a name="func*mosek*task*getaslice64">&#09;</a><a name="common-func*mosek*task*getaslice64"></a> <a name="idx-99178472">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getaslice (
    accmode accmode,
    int first,
    int last,
    ref long surp,
    long[] ptrb,
    long[] ptre,
    int[] sub,
    double[] val);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether a column slice or a row slice is requested.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column in the sequence <b>plus one</b>.</dd>
<dt><tt class="tt">surp</tt> (input/output)</dt>
<dd>The required rows and columns are stored sequentially in <tt class="tt">sub</tt> and <tt class="tt">val</tt> starting from position <tt class="tt">maxnumnz-surp[0]</tt>. Upon return <tt class="tt">surp</tt> has been decremented by the total number of non-zero elements in the rows and columns obtained.</dd>
<dt><tt class="tt">ptrb</tt> (output)</dt>
<dd><tt class="tt">ptrb[t]</tt> is an index pointing to the first element in the <span class="math"><span class="mi">t</span></span>th row or column obtained.</dd>
<dt><tt class="tt">ptre</tt> (output)</dt>
<dd><tt class="tt">ptre[t]</tt> is an index pointing to the last element plus one in the <span class="math"><span class="mi">t</span></span>th row or column obtained.</dd>
<dt><tt class="tt">sub</tt> (output)</dt>
<dd>Contains the row or column subscripts.</dd>
<dt><tt class="tt">val</tt> (output)</dt>
<dd>Contains the coefficient values.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a sequence of rows or columns from <span class="math"><span class="mi">A</span></span> in sparse format.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getaslicenumnz64"><tt class="tt">mosek.Task.getaslicenumnz64</tt></a></dt>
<dd>
<p> Obtains the number of non-zeros in a slice of rows or columns of the coefficient matrix.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getaslicenumnz</tt></span>

<p> <a name="func*mosek*task*getaslicenumnz">&#09;</a><a name="common-func*mosek*task*getaslicenumnz"></a> <a name="idx-99208800">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getaslicenumnz (
    accmode accmode,
    int first,
    int last,
    out int numnz);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether non-zeros are counted in a column-slice or a row-slice.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column <b>plus one</b> in the sequence.</dd>
<dt><tt class="tt">numnz</tt> (output)</dt>
<dd>Number of non-zeros in the slice.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zeros in a row or column slice of <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getaslicenumnz</tt></span>

<p> <a name="func*mosek*task*getaslicenumnz64">&#09;</a><a name="common-func*mosek*task*getaslicenumnz64"></a> <a name="idx-99222448">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public long getaslicenumnz (
    accmode accmode,
    int first,
    int last);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether non-zeros are counted in a column slice or a row slice.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column <b>plus one</b> in the sequence.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getaslicenumnz (
    accmode accmode,
    int first,
    int last,
    out long numnz);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether non-zeros are counted in a column slice or a row slice.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column <b>plus one</b> in the sequence.</dd>
<dt><tt class="tt">numnz</tt> (output)</dt>
<dd>Number of non-zeros in the slice.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zeros in a slice of rows or columns of <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getaslicetrip</tt></span>

<p> <a name="func*mosek*task*getaslicetrip">&#09;</a><a name="common-func*mosek*task*getaslicetrip"></a> <a name="idx-99244008">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getaslicetrip (
    accmode accmode,
    int first,
    int last,
    ref int surp,
    int[] subi,
    int[] subj,
    double[] val);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether a column-slice or a row-slice is requested.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column in the sequence <b>plus one</b>.</dd>
<dt><tt class="tt">surp</tt> (input/output)</dt>
<dd>The required rows and columns are stored sequentially in <tt class="tt">subi</tt> and <tt class="tt">val</tt> starting from position <tt class="tt">maxnumnz-surp[0]</tt>. On return <tt class="tt">surp</tt> has been decremented by the total number of non-zero elements in the rows and columns obtained.</dd>
<dt><tt class="tt">subi</tt> (output)</dt>
<dd>Constraint subscripts.</dd>
<dt><tt class="tt">subj</tt> (output)</dt>
<dd>Variable subscripts.</dd>
<dt><tt class="tt">val</tt> (output)</dt>
<dd>Values.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a sequence of rows or columns from <span class="math"><span class="mi">A</span></span> in a sparse triplet format. </dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getaslicenumnz"><tt class="tt">mosek.Task.getaslicenumnz</tt></a></dt>
<dd>
<p> Obtains the number of non-zeros in a row or column slice of the coefficient matrix.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getavec</tt></span>

<p> <a name="func*mosek*task*getavec">&#09;</a><a name="common-func*mosek*task*getavec"></a> <a name="idx-99269808">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getavec (
    accmode accmode,
    int i,
    out int nzi,
    int[] subi,
    double[] vali);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the row or column.</dd>
<dt><tt class="tt">nzi</tt> (output)</dt>
<dd>Number of non-zeros in the vector obtained.</dd>
<dt><tt class="tt">subi</tt> (output)</dt>
<dd>Index of the non-zeros in the vector obtained.</dd>
<dt><tt class="tt">vali</tt> (output)</dt>
<dd>Numerical values of the vector to be obtained.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains one row or column of <span class="math"><span class="mi">A</span></span> in a sparse format. If <tt class="tt">accmode</tt> equals <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a> a row is returned and hence:  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math724.png" alt="\begin{displaymath}\nonumber{}\mathtt{vali}[k]=a_{{i,\mathtt{subi}[k]}},\quad{}k=0,\ldots ,\mathtt{nzi[0]}-1\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  If <tt class="tt">accmode</tt> equals <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a> a column is returned, that is:  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math725.png" alt="\begin{displaymath}\nonumber{}\mathtt{vali}[k]=a_{{\mathtt{subi}[k],i}},\quad{}k=0,\ldots ,\mathtt{nzi[0]}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getavecnumnz</tt></span>

<p> <a name="func*mosek*task*getavecnumnz">&#09;</a><a name="common-func*mosek*task*getavecnumnz"></a> <a name="idx-106612352">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getavecnumnz (
    accmode accmode,
    int i);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether non-zeros are counted by columns or by rows.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the row or column.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getavecnumnz (
    accmode accmode,
    int i,
    out int nzj);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether non-zeros are counted by columns or by rows.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the row or column.</dd>
<dt><tt class="tt">nzj</tt> (output)</dt>
<dd>Number of non-zeros in the <span class="math"><span class="mi">i</span></span>th row or column of <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero elements in one row or column of <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getbound</tt></span>

<p> <a name="func*mosek*task*getbound">&#09;</a><a name="common-func*mosek*task*getbound"></a> <a name="idx-106630536">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getbound (
    accmode accmode,
    int i,
    out boundkey bk,
    out double bl,
    out double bu);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable for which the bound information should be obtained.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (output)</dt>
<dd>Bound keys.</dd>
<dt><tt class="tt">bl</tt> (output)</dt>
<dd>Values for lower bounds.</dd>
<dt><tt class="tt">bu</tt> (output)</dt>
<dd>Values for upper bounds.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains bound information for one constraint or variable.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getboundslice</tt></span>

<p> <a name="func*mosek*task*getboundslice">&#09;</a><a name="common-func*mosek*task*getboundslice"></a> <a name="idx-106642248">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getboundslice (
    accmode accmode,
    int first,
    int last,
    boundkey[] bk,
    double[] bl,
    double[] bu);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>First index in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Last index plus 1 in the sequence.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (output)</dt>
<dd>Bound keys.</dd>
<dt><tt class="tt">bl</tt> (output)</dt>
<dd>Values for lower bounds.</dd>
<dt><tt class="tt">bu</tt> (output)</dt>
<dd>Values for upper bounds.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains bounds information for a sequence of variables or constraints.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getc</tt></span>

<p> <a name="func*mosek*task*getc">&#09;</a><a name="common-func*mosek*task*getc"></a> <a name="idx-106647632">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getc (double[] c)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">c</tt> (output)</dt>
<dd>Linear terms of the objective as a dense vector. The lengths is the number of variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains all objective coefficients <span class="math"><span class="mi">c</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getcfix</tt></span>

<p> <a name="func*mosek*task*getcfix">&#09;</a><a name="common-func*mosek*task*getcfix"></a> <a name="idx-106666680">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public double getcfix ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getcfix (out double cfix)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">cfix</tt> (output)</dt>
<dd>Fixed term in the objective.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the fixed term in the objective.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getcone</tt></span>

<p> <a name="func*mosek*task*getcone">&#09;</a><a name="common-func*mosek*task*getcone"></a> <a name="idx-106679544">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getcone (
    int k,
    out conetype conetype,
    out double conepar,
    out int nummem,
    int[] submem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the cone constraint.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (output)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (output)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">nummem</tt> (output)</dt>
<dd>Number of member variables in the cone.</dd>
<dt><tt class="tt">submem</tt> (output)</dt>
<dd>Variable subscripts of the members in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a conic constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getconeinfo</tt></span>

<p> <a name="func*mosek*task*getconeinfo">&#09;</a><a name="common-func*mosek*task*getconeinfo"></a> <a name="idx-106695424">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getconeinfo (
    int k,
    out conetype conetype,
    out double conepar,
    out int nummem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the conic constraint.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (output)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (output)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">nummem</tt> (output)</dt>
<dd>Number of member variables in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains information about a conic constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getconname</tt></span>

<p> <a name="func*mosek*task*getconname64">&#09;</a><a name="common-func*mosek*task*getconname64"></a> <a name="idx-106689024">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public string getconname (int i)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getconname (
    int i,
    StringBuilder name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getcslice</tt></span>

<p> <a name="func*mosek*task*getcslice">&#09;</a><a name="common-func*mosek*task*getcslice"></a> <a name="idx-106720432">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getcslice (
    int first,
    int last,
    double[] c);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">first</tt> (input)</dt>
<dd>First index in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Last index plus 1 in the sequence.</dd>
<dt><tt class="tt">c</tt> (output)</dt>
<dd>Linear terms of the objective as a dense vector. The lengths is the number of variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a sequence of elements in <span class="math"><span class="mi">c</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getdbi</tt></span>

<p> <a name="func*mosek*task*getdbi">&#09;</a><a name="common-func*mosek*task*getdbi"></a> <a name="idx-106717336">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getdbi (
    soltype whichsol,
    accmode accmode,
    int[] sub,
    double[] dbi);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a> then <tt class="tt">sub</tt> contains constraint indexes, otherwise variable indexes.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of constraints or variables.</dd>
<dt><tt class="tt">dbi</tt> (output)</dt>
<dd>
<p>Dual bound infeasibility. If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math726.png" alt="\begin{math}\nonumber{}{dbi}[i]=\max (-(s_{l}^{c})_{{{sub}[i]}},-(s_{u}^{c})_{{{sub}[i]}},0)\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.9.1)</td></tr>
</tbody>
</table>

<p> else </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math727.png" alt="\begin{math}\nonumber{}{dbi}[i]=\max (-(s_{l}^{x})_{{{sub}[i]}},-(s_{u}^{x})_{{{sub}[i]}},0)\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}.\end{math}"/></td>
<td>(15.9.2)</td></tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the dual bound infeasibility.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getdcni</tt></span>

<p> <a name="func*mosek*task*getdcni">&#09;</a><a name="common-func*mosek*task*getdcni"></a> <a name="idx-106758088">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getdcni (
    soltype whichsol,
    int[] sub,
    double[] dcni);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Constraint indexes to calculate equation infeasibility for.</dd>
<dt><tt class="tt">dcni</tt> (output)</dt>
<dd><tt class="tt">dcni[i]</tt> contains dual cone infeasibility for the cone with index <tt class="tt">sub[i]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the dual cone infeasibility.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getdeqi</tt></span>

<p> <a name="func*mosek*task*getdeqi">&#09;</a><a name="common-func*mosek*task*getdeqi"></a> <a name="idx-106772096">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getdeqi (
    soltype whichsol,
    accmode accmode,
    int[] sub,
    double[] deqi,
    int normalize);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a> the dual equation infeasibilitys corresponding to constraints are retrieved. Otherwise for a variables.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of constraints or variables.</dd>
<dt><tt class="tt">deqi</tt> (output)</dt>
<dd>Dual equation infeasibilitys corresponding to constraints or variables.</dd>
<dt><tt class="tt">normalize</tt> (input)</dt>
<dd>If non-zero, normalize with largest absolute value of the input data used to compute the individual infeasibility.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Optains the dual equation infeasibility. If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math728.png" alt="\begin{math}\nonumber{}{pbi}[i]=\left|(-y+s_{l}^{c}-s_{u}^{c})_{{{sub}[i]}}\right|\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.9.3)</td></tr>
</tbody>
</table>

<p> If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math729.png" alt="\begin{math}\nonumber{}{pbi}[i]=\left|(A^{T}y+s_{l}^{x}-s_{u}^{x}-c)_{{{sub}[i]}}\right|\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.9.4)</td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getdouinf</tt></span>

<p> <a name="func*mosek*task*getdouinf">&#09;</a><a name="common-func*mosek*task*getdouinf"></a> <a name="idx-106807880">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public double getdouinf (dinfitem whichdinf)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*dinfitem"><tt class="tt">whichdinf</tt></a> (input)</dt>
<dd>A <tt class="tt">double</tt> information item. See section <a title="18.13. Double information items" href="node020.html#constclass*mosek*dinfitem">18.13</a> for the possible values.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getdouinf (
    dinfitem whichdinf,
    out double dvalue);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*dinfitem"><tt class="tt">whichdinf</tt></a> (input)</dt>
<dd>A <tt class="tt">double</tt> information item. See section <a title="18.13. Double information items" href="node020.html#constclass*mosek*dinfitem">18.13</a> for the possible values.</dd>
<dt><tt class="tt">dvalue</tt> (output)</dt>
<dd>The value of the required double information item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a double information item from the task information database.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getdouparam</tt></span>

<p> <a name="func*mosek*task*getdouparam">&#09;</a><a name="common-func*mosek*task*getdouparam"></a> <a name="idx-106826352">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public double getdouparam (dparam param)
</pre>

<dl class="funcargsdesc">
<dt><a href="node018.html#common-constclass*mosek*dparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getdouparam (
    dparam param,
    out double parvalue);
</pre>

<dl class="funcargsdesc">
<dt><a href="node018.html#common-constclass*mosek*dparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (output)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of a double parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getdualobj</tt></span>

<p> <a name="func*mosek*task*getdualobj">&#09;</a><a name="common-func*mosek*task*getdualobj"></a> <a name="idx-106841152">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getdualobj (
    soltype whichsol,
    out double dualobj);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">dualobj</tt> (output)</dt>
<dd>Objective value corresponding to the dual solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the current objective value of the dual problem for <tt class="tt">whichsol</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getinfeasiblesubproblem</tt></span>

<p> <a name="func*mosek*task*getinfeasiblesubproblem">&#09;</a><a name="common-func*mosek*task*getinfeasiblesubproblem"></a> <a name="idx-108342160">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Task getinfeasiblesubproblem (soltype whichsol)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Which solution to use when determining the infeasible subproblem.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getinfeasiblesubproblem (
    soltype whichsol,
    out Task inftask);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Which solution to use when determining the infeasible subproblem.</dd>
<dt><tt class="tt">inftask</tt> (output)</dt>
<dd>A new task containing the infeasible subproblem.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an infeasible subproblem. The infeasible subproblem is a problem consisting of a subset of the original constraints such that the problem is still infeasible. For more information see Section <a title="10.2. Analyzing infeasible problems" href="node012.html#sec-analysing-infeasible-problems">10.2</a>.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node018.html#common-const*mosek*iparam*infeas-prefer-primal"><tt class="tt">mosek.iparam.infeas_prefer_primal</tt></a></dt>
<dd></dd>
<dt><a href="node017.html#common-func*mosek*task*relaxprimal"><tt class="tt">mosek.Task.relaxprimal</tt></a></dt>
<dd>
<p> Creates a problem that finds the minimal change to the bounds that makes an infeasible problem feasible.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getinfindex</tt></span>

<p> <a name="func*mosek*task*getinfindex">&#09;</a><a name="common-func*mosek*task*getinfindex"></a> <a name="idx-108367096">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getinfindex (
    inftype inftype,
    string infname,
    out int infindex);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*inftype"><tt class="tt">inftype</tt></a> (input)</dt>
<dd>Type of the information item.</dd>
<dt><tt class="tt">infname</tt> (input)</dt>
<dd>Name of the information item.</dd>
<dt><tt class="tt">infindex</tt> (output)</dt>
<dd>The item index.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the index of a named information item.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getinti</tt></span>

<p> <a name="func*mosek*task*getinti">&#09;</a><a name="common-func*mosek*task*getinti"></a> <a name="idx-108373848">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getinti (
    soltype whichsol,
    int[] sub,
    double[] inti);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Variable indexes for which to calculate the integer infeasibility.</dd>
<dt><tt class="tt">inti</tt> (output)</dt>
<dd><tt class="tt">inti[i]</tt> contains integer infeasibility of variable <tt class="tt">sub[i]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the primal equation infeasibility. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math730.png" alt="\begin{math}\nonumber{}{peqi}[i]=\left|(\right|(Ax-x^{c})_{{{sub}[i]}})\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len}-1.\end{math}"/></td>
<td>(15.9.5)</td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getintinf</tt></span>

<p> <a name="func*mosek*task*getintinf">&#09;</a><a name="common-func*mosek*task*getintinf"></a> <a name="idx-108398208">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getintinf (iinfitem whichiinf)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*iinfitem"><tt class="tt">whichiinf</tt></a> (input)</dt>
<dd>Specifies an information item.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getintinf (
    iinfitem whichiinf,
    out int ivalue);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*iinfitem"><tt class="tt">whichiinf</tt></a> (input)</dt>
<dd>Specifies an information item.</dd>
<dt><tt class="tt">ivalue</tt> (output)</dt>
<dd>The value of the required integer information item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an integer information item from the task information database.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getintparam</tt></span>

<p> <a name="func*mosek*task*getintparam">&#09;</a><a name="common-func*mosek*task*getintparam"></a> <a name="idx-108402016">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getintparam (iparam param)
</pre>

<dl class="funcargsdesc">
<dt><a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getintparam (
    iparam param,
    out int parvalue);
</pre>

<dl class="funcargsdesc">
<dt><a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (output)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of an integer parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getintpntnumthreads</tt></span>

<p> <a name="func*mosek*task*getintpntnumthreads">&#09;</a><a name="common-func*mosek*task*getintpntnumthreads"></a> <a name="idx-108430760">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getintpntnumthreads ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getintpntnumthreads (out int numthreads)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numthreads</tt> (output)</dt>
<dd>The number of threads.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of threads used by the interior-point optimizer. If <a href="node018.html#common-const*mosek*iparam*intpnt-num-threads"><tt class="tt">mosek.iparam.intpnt_num_threads</tt></a> is set to zero this function will return the number of cores on the system. Otherwise it return the value of <a href="node018.html#common-const*mosek*iparam*intpnt-num-threads"><tt class="tt">mosek.iparam.intpnt_num_threads</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getlintinf</tt></span>

<p> <a name="func*mosek*task*getlintinf">&#09;</a><a name="common-func*mosek*task*getlintinf"></a> <a name="idx-108439600">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public long getlintinf (liinfitem whichliinf)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*liinfitem"><tt class="tt">whichliinf</tt></a> (input)</dt>
<dd>Specifies an information item.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getlintinf (
    liinfitem whichliinf,
    out long ivalue);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*liinfitem"><tt class="tt">whichliinf</tt></a> (input)</dt>
<dd>Specifies an information item.</dd>
<dt><tt class="tt">ivalue</tt> (output)</dt>
<dd>The value of the required integer information item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an integer information item from the task information database.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getmaxnumanz</tt></span>

<p> <a name="func*mosek*task*getmaxnumanz64">&#09;</a><a name="common-func*mosek*task*getmaxnumanz64"></a> <a name="idx-108438448">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public long getmaxnumanz ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getmaxnumanz (out long maxnumanz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumanz</tt> (output)</dt>
<dd>Number of preallocated non-zero elements in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains number of preallocated non-zeros in <span class="math"><span class="mi">A</span></span>. When this number of non-zeros is reached MOSEK will automatically allocate more space for <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getmaxnumcon</tt></span>

<p> <a name="func*mosek*task*getmaxnumcon">&#09;</a><a name="common-func*mosek*task*getmaxnumcon"></a> <a name="idx-108468632">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getmaxnumcon (out int maxnumcon)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumcon</tt> (output)</dt>
<dd>Number of preallocated constraints in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of preallocated constraints in the optimization task. When this number of constraints is reached MOSEK will automatically allocate more space for constraints.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getmaxnumcone</tt></span>

<p> <a name="func*mosek*task*getmaxnumcone">&#09;</a><a name="common-func*mosek*task*getmaxnumcone"></a> <a name="idx-108476896">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getmaxnumcone (out int maxnumcone)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumcone</tt> (output)</dt>
<dd>Number of preallocated conic constraints in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of preallocated cones in the optimization task. When this number of cones is reached MOSEK will automatically allocate space for more cones.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getmaxnumqnz</tt></span>

<p> <a name="func*mosek*task*getmaxnumqnz64">&#09;</a><a name="common-func*mosek*task*getmaxnumqnz64"></a> <a name="idx-108452968">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getmaxnumqnz (out long maxnumqnz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumqnz</tt> (output)</dt>
<dd>Number of non-zero elements preallocated in quadratic coefficient matrices.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of preallocated non-zeros for <span class="math"><span class="mi">Q</span></span> (both objective and constraints). When this number of non-zeros is reached MOSEK will automatically allocate more space for <span class="math"><span class="mi">Q</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getmaxnumvar</tt></span>

<p> <a name="func*mosek*task*getmaxnumvar">&#09;</a><a name="common-func*mosek*task*getmaxnumvar"></a> <a name="idx-108489976">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getmaxnumvar (out int maxnumvar)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumvar</tt> (output)</dt>
<dd>Number of preallocated variables in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of preallocated variables in the optimization task. When this number of variables is reached MOSEK will automatically allocate more space for constraints.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getmemusage</tt></span>

<p> <a name="func*mosek*task*getmemusagetask64">&#09;</a><a name="common-func*mosek*task*getmemusagetask64"></a> <a name="idx-108491336">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getmemusage (
    out long meminuse,
    out long maxmemuse);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">meminuse</tt> (output)</dt>
<dd>Amount of memory currently used by the <tt class="tt">task</tt>.</dd>
<dt><tt class="tt">maxmemuse</tt> (output)</dt>
<dd>Maximum amount of memory used by the <tt class="tt">task</tt> until now.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains information about the amount of memory used by a task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getname</tt></span>

<p> <a name="func*mosek*task*getname64">&#09;</a><a name="common-func*mosek*task*getname64"></a> <a name="idx-108506576">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public string getname (
    problemitem whichitem,
    int i,
    out long len);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the required name.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getname (
    problemitem whichitem,
    int i,
    out long len,
    StringBuilder name);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the required name.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a problem item, i.e. a cone, a variable or a constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getname</tt></span>

<p> <a name="func*mosek*task*getnameapi64">&#09;</a><a name="common-func*mosek*task*getnameapi64"></a> <a name="idx-108526912">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public string getname (
    problemitem whichitem,
    int i);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getname (
    problemitem whichitem,
    int i,
    StringBuilder name);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a problem item, i.e. a cone, a variable or a constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnameindex</tt></span>

<p> <a name="func*mosek*task*getnameindex">&#09;</a><a name="common-func*mosek*task*getnameindex"></a> <a name="idx-108527840">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getnameindex (
    problemitem whichitem,
    string name,
    out int asgn);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">name</tt> (input)</dt>
<dd>The name which should be checked.</dd>
<dt><tt class="tt">asgn</tt> (output)</dt>
<dd>Is non-zero if <tt class="tt">name</tt> is assigned.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnameindex (
    problemitem whichitem,
    string name,
    out int asgn,
    out int index);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">name</tt> (input)</dt>
<dd>The name which should be checked.</dd>
<dt><tt class="tt">asgn</tt> (output)</dt>
<dd>Is non-zero if <tt class="tt">name</tt> is assigned.</dd>
<dt><tt class="tt">index</tt> (output)</dt>
<dd>If the <tt class="tt">name</tt> identifies an item in the task, then <tt class="tt">index</tt> is assigned the index of that item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks if a given name identifies a cone, a constraint or a variable in the <tt class="tt">task</tt>. If it does, the index of that item is assigned to <tt class="tt">index</tt>, and a non-zero value is assigned to <tt class="tt">asgn</tt>. If the name does not identify a problem item, <tt class="tt">asgn</tt> is assigned a zero.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnamelen</tt></span>

<p> <a name="func*mosek*task*getnamelen64">&#09;</a><a name="common-func*mosek*task*getnamelen64"></a> <a name="idx-108568160">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public long getnamelen (
    problemitem whichitem,
    int i);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnamelen (
    problemitem whichitem,
    int i,
    out long len);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the length of a problem item name.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getname64"><tt class="tt">mosek.Task.getname64</tt></a></dt>
<dd>
<p> Obtains the name of a cone, a variable or a constraint.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumanz</tt></span>

<p> <a name="func*mosek*task*getnumanz">&#09;</a><a name="common-func*mosek*task*getnumanz"></a> <a name="idx-108588640">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getnumanz ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumanz (out int numanz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numanz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zeros in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumanz64</tt></span>

<p> <a name="func*mosek*task*getnumanz64">&#09;</a><a name="common-func*mosek*task*getnumanz64"></a> <a name="idx-110118816">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public long getnumanz64 ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumanz64 (out long numanz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numanz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zeros in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumcon</tt></span>

<p> <a name="func*mosek*task*getnumcon">&#09;</a><a name="common-func*mosek*task*getnumcon"></a> <a name="idx-108588280">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getnumcon ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumcon (out int numcon)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numcon</tt> (output)</dt>
<dd>Number of constraints.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of constraints.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumcone</tt></span>

<p> <a name="func*mosek*task*getnumcone">&#09;</a><a name="common-func*mosek*task*getnumcone"></a> <a name="idx-110135848">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getnumcone ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumcone (out int numcone)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numcone</tt> (output)</dt>
<dd>Number conic constraints.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of cones.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumconemem</tt></span>

<p> <a name="func*mosek*task*getnumconemem">&#09;</a><a name="common-func*mosek*task*getnumconemem"></a> <a name="idx-110145408">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumconemem (
    int k,
    out int nummem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the cone.</dd>
<dt><tt class="tt">nummem</tt> (output)</dt>
<dd>Number of member variables in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of members in a cone.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumintvar</tt></span>

<p> <a name="func*mosek*task*getnumintvar">&#09;</a><a name="common-func*mosek*task*getnumintvar"></a> <a name="idx-110153096">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumintvar (out int numintvar)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numintvar</tt> (output)</dt>
<dd>Number of integer variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of integer-constrained variables.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumparam</tt></span>

<p> <a name="func*mosek*task*getnumparam">&#09;</a><a name="common-func*mosek*task*getnumparam"></a> <a name="idx-110164232">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumparam (
    parametertype partype,
    out int numparam);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*parametertype"><tt class="tt">partype</tt></a> (input)</dt>
<dd>Parameter type.</dd>
<dt><tt class="tt">numparam</tt> (output)</dt>
<dd>Identical to the number of parameters of the type <tt class="tt">partype</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of parameters of a given type.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumqconknz</tt></span>

<p> <a name="func*mosek*task*getnumqconknz">&#09;</a><a name="common-func*mosek*task*getnumqconknz"></a> <a name="idx-110144760">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getnumqconknz (int k)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the constraint for which the number of non-zero quadratic terms should be obtained.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumqconknz (
    int k,
    out int numqcnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the constraint for which the number of non-zero quadratic terms should be obtained.</dd>
<dt><tt class="tt">numqcnz</tt> (output)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero quadratic terms in a constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumqconknz64</tt></span>

<p> <a name="func*mosek*task*getnumqconknz64">&#09;</a><a name="common-func*mosek*task*getnumqconknz64"></a> <a name="idx-110190536">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public long getnumqconknz64 (int k)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the constraint for which the number quadratic terms should be obtained.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumqconknz64 (
    int k,
    out long numqcnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the constraint for which the number quadratic terms should be obtained.</dd>
<dt><tt class="tt">numqcnz</tt> (output)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero quadratic terms in a constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumqobjnz</tt></span>

<p> <a name="func*mosek*task*getnumqobjnz">&#09;</a><a name="common-func*mosek*task*getnumqobjnz"></a> <a name="idx-110208712">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getnumqobjnz ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumqobjnz (out int numqonz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numqonz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math31.png" alt="[[MathCmd 31]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero quadratic terms in the objective.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumqobjnz64</tt></span>

<p> <a name="func*mosek*task*getnumqobjnz64">&#09;</a><a name="common-func*mosek*task*getnumqobjnz64"></a> <a name="idx-110222080">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public long getnumqobjnz64 ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumqobjnz64 (out long numqonz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numqonz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math31.png" alt="[[MathCmd 31]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero quadratic terms in the objective.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getnumvar</tt></span>

<p> <a name="func*mosek*task*getnumvar">&#09;</a><a name="common-func*mosek*task*getnumvar"></a> <a name="idx-110226896">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getnumvar ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getnumvar (out int numvar)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numvar</tt> (output)</dt>
<dd>Number of variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of variables.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getobjname</tt></span>

<p> <a name="func*mosek*task*getobjname64">&#09;</a><a name="common-func*mosek*task*getobjname64"></a> <a name="idx-110238968">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public string getobjname (out long len)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Assigned the length of the objective name.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getobjname (
    out long len,
    StringBuilder objname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Assigned the length of the objective name.</dd>
<dt><tt class="tt">objname</tt> (output)</dt>
<dd>Assigned the objective name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name assigned to the objective function.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getobjsense</tt></span>

<p> <a name="func*mosek*task*getobjsense">&#09;</a><a name="common-func*mosek*task*getobjsense"></a> <a name="idx-110249312">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public objsense getobjsense ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getobjsense (out objsense sense)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*objsense"><tt class="tt">sense</tt></a> (output)</dt>
<dd>The returned objective sense.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Gets the objective sense of the task.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putobjsense"><tt class="tt">mosek.Task.putobjsense</tt></a></dt>
<dd>
<p> Sets the objective sense.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getpbi</tt></span>

<p> <a name="func*mosek*task*getpbi">&#09;</a><a name="common-func*mosek*task*getpbi"></a> <a name="idx-110262464">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getpbi (
    soltype whichsol,
    accmode accmode,
    int[] sub,
    double[] pbi,
    int normalize);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a> return bound infeasibility for <span class="math"><span class="mi">x</span></span> otherwise for <span class="math"><img src="math/math200.png" alt="[[MathCmd 200]]"/></span>.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>An array of constraint or variable indexes.</dd>
<dt><tt class="tt">pbi</tt> (output)</dt>
<dd>Bound infeasibility for <span class="math"><span class="mi">x</span></span> or <span class="math"><img src="math/math200.png" alt="[[MathCmd 200]]"/></span>.</dd>
<dt><tt class="tt">normalize</tt> (input)</dt>
<dd>If non-zero, normalize with largest absolute value of the input data used to compute the individual infeasibility.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the primal bound infeasibility. If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math735.png" alt="\begin{math}\nonumber{}{pbi}[i]=\max (x^{c}_{{{sub[i]}}}-u^{c}_{{{sub[i]}}},l^{c}_{{{sub[i]}}}-x^{c}_{{{sub[i]}}},0)\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.9.6)</td></tr>
</tbody>
</table>

<p> If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math736.png" alt="\begin{math}\nonumber{}{pbi}[i]=\max (x_{{{sub[i]}}}-u^{x}_{{{sub[i]}}},l^{x}_{{{sub[i]}}}-x_{{{sub[i]}}},0)\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.9.7)</td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getpcni</tt></span>

<p> <a name="func*mosek*task*getpcni">&#09;</a><a name="common-func*mosek*task*getpcni"></a> <a name="idx-110310896">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getpcni (
    soltype whichsol,
    int[] sub,
    double[] pcni);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Constraint indexes for which to calculate the equation infeasibility.</dd>
<dt><tt class="tt">pcni</tt> (output)</dt>
<dd><tt class="tt">pcni[i]</tt> contains primal cone infeasibility for the cone with index <tt class="tt">sub[i]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the primal cone infeasibility.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getpeqi</tt></span>

<p> <a name="func*mosek*task*getpeqi">&#09;</a><a name="common-func*mosek*task*getpeqi"></a> <a name="idx-110323976">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getpeqi (
    soltype whichsol,
    int[] sub,
    double[] peqi,
    int normalize);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Constraint indexes for which to calculate the equation infeasibility.</dd>
<dt><tt class="tt">peqi</tt> (output)</dt>
<dd><tt class="tt">peqi[i]</tt> contains equation infeasibility of constraint <tt class="tt">sub[i]</tt>.</dd>
<dt><tt class="tt">normalize</tt> (input)</dt>
<dd>If non-zero, normalize with largest absolute value of the input data used to compute the individual infeasibility.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the primal equation infeasibility. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math730.png" alt="\begin{math}\nonumber{}{peqi}[i]=\left|(\right|(Ax-x^{c})_{{{sub}[i]}})\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len}-1.\end{math}"/></td>
<td>(15.9.8)</td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getprimalobj</tt></span>

<p> <a name="func*mosek*task*getprimalobj">&#09;</a><a name="common-func*mosek*task*getprimalobj"></a> <a name="idx-110345104">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public double getprimalobj (soltype whichsol)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getprimalobj (
    soltype whichsol,
    out double primalobj);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">primalobj</tt> (output)</dt>
<dd>Objective value corresponding to the primal solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the primal objective value for a solution.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getprobtype</tt></span>

<p> <a name="func*mosek*task*getprobtype">&#09;</a><a name="common-func*mosek*task*getprobtype"></a> <a name="idx-110320960">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public problemtype getprobtype ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getprobtype (out problemtype probtype)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemtype"><tt class="tt">probtype</tt></a> (output)</dt>
<dd>The problem type.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the problem type.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getqconk</tt></span>

<p> <a name="func*mosek*task*getqconk">&#09;</a><a name="common-func*mosek*task*getqconk"></a> <a name="idx-111730344">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getqconk (
    int k,
    ref int qcsurp,
    int[] qcsubi,
    int[] qcsubj,
    double[] qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Which constraint.</dd>
<dt><tt class="tt">qcsurp</tt> (input/output)</dt>
<dd>When entering the function it is assumed that the last <tt class="tt">qcsurp[0]</tt> positions in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt> are free. Hence, the quadratic terms are stored in this area, and upon return <tt class="tt">qcsurp</tt> is number of free positions left in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
<dt><tt class="tt">qcsubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getqconk (
    int k,
    ref int qcsurp,
    out int numqcnz,
    int[] qcsubi,
    int[] qcsubj,
    double[] qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Which constraint.</dd>
<dt><tt class="tt">qcsurp</tt> (input/output)</dt>
<dd>When entering the function it is assumed that the last <tt class="tt">qcsurp[0]</tt> positions in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt> are free. Hence, the quadratic terms are stored in this area, and upon return <tt class="tt">qcsurp</tt> is number of free positions left in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
<dt><tt class="tt">numqcnz</tt> (output)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains all the quadratic terms in a constraint. The quadratic terms are stored sequentially <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getqconk64</tt></span>

<p> <a name="func*mosek*task*getqconk64">&#09;</a><a name="common-func*mosek*task*getqconk64"></a> <a name="idx-111786968">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public long getqconk64 (
    int k,
    ref long qcsurp,
    int[] qcsubi,
    int[] qcsubj,
    double[] qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Which constraint.</dd>
<dt><tt class="tt">qcsurp</tt> (input/output)</dt>
<dd>When entering the function it is assumed that the last <tt class="tt">qcsurp[0]</tt> positions in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt> are free. Hence, the quadratic terms are stored in this area, and upon return <tt class="tt">qcsurp</tt> is number of free positions left in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
<dt><tt class="tt">qcsubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getqconk64 (
    int k,
    ref long qcsurp,
    out long numqcnz,
    int[] qcsubi,
    int[] qcsubj,
    double[] qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Which constraint.</dd>
<dt><tt class="tt">qcsurp</tt> (input/output)</dt>
<dd>When entering the function it is assumed that the last <tt class="tt">qcsurp[0]</tt> positions in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt> are free. Hence, the quadratic terms are stored in this area, and upon return <tt class="tt">qcsurp</tt> is number of free positions left in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
<dt><tt class="tt">numqcnz</tt> (output)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains all the quadratic terms in a constraint. The quadratic terms are stored sequentially <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getqobj</tt></span>

<p> <a name="func*mosek*task*getqobj">&#09;</a><a name="common-func*mosek*task*getqobj"></a> <a name="idx-111839712">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getqobj (
    ref int qosurp,
    out int numqonz,
    int[] qosubi,
    int[] qosubj,
    double[] qoval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">qosurp</tt> (input/output)</dt>
<dd>When entering the function <tt class="tt">qosurp[0]</tt> is the number of free positions at the end of the arrays <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>, and upon return <tt class="tt">qosurp</tt> is the updated number of free positions left in those arrays.</dd>
<dt><tt class="tt">numqonz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math31.png" alt="[[MathCmd 31]]"/></span>.</dd>
<dt><tt class="tt">qosubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscript for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
<dt><tt class="tt">qosubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscript for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
<dt><tt class="tt">qoval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the quadratic terms in the objective. The required quadratic terms are stored sequentially in <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getqobj64</tt></span>

<p> <a name="func*mosek*task*getqobj64">&#09;</a><a name="common-func*mosek*task*getqobj64"></a> <a name="idx-111868384">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getqobj64 (
    ref long qosurp,
    out long numqonz,
    int[] qosubi,
    int[] qosubj,
    double[] qoval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">qosurp</tt> (input/output)</dt>
<dd>When entering the function <tt class="tt">qosurp[0]</tt> is the number of free positions at the end of the arrays <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>, and upon return <tt class="tt">qosurp</tt> is the updated number of free positions left in those arrays.</dd>
<dt><tt class="tt">numqonz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math31.png" alt="[[MathCmd 31]]"/></span>.</dd>
<dt><tt class="tt">qosubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscript for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
<dt><tt class="tt">qosubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscript for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
<dt><tt class="tt">qoval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the quadratic terms in the objective. The required quadratic terms are stored sequentially in <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getqobjij</tt></span>

<p> <a name="func*mosek*task*getqobjij">&#09;</a><a name="common-func*mosek*task*getqobjij"></a> <a name="idx-111889296">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getqobjij (
    int i,
    int j,
    out double qoij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Row index of the coefficient.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Column index of coefficient.</dd>
<dt><tt class="tt">qoij</tt> (output)</dt>
<dd>The required coefficient.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains one coefficient <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span> in the quadratic term of the objective.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getreducedcosts</tt></span>

<p> <a name="func*mosek*task*getreducedcosts">&#09;</a><a name="common-func*mosek*task*getreducedcosts"></a> <a name="idx-111895616">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getreducedcosts (
    soltype whichsol,
    int first,
    int last,
    double[] redcosts);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>See formula (<a href="node017.html#ais-eq-redcost">15.9.9</a>) for the definition.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>See formula (<a href="node017.html#ais-eq-redcost">15.9.9</a>) for the definition.</dd>
<dt><tt class="tt">redcosts</tt> (output)</dt>
<dd>The reduced costs in the required sequence of variables are stored sequentially in <tt class="tt">redcosts</tt> starting at <tt class="tt">redcosts[0]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Computes the reduced costs for a sequence of variables and return them in the variable <tt class="tt">redcosts</tt> i.e. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math759.png" alt="\begin{math}\nonumber{}\mathtt{redcosts}[j-\mathtt{first}]=(s_{l}^{x})_{j}-(s_{u}^{x})_{j},~j=\mathtt{first},\ldots ,\mathtt{last}-1.\end{math}"/></td>
<td><a name="ais-eq-redcost">&#09;</a>(15.9.9)</td></tr>
</tbody>
</table>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getsolution</tt></span>

<p> <a name="func*mosek*task*getsolution">&#09;</a><a name="common-func*mosek*task*getsolution"></a> <a name="idx-111715608">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getsolution (
    soltype whichsol,
    out prosta prosta,
    out solsta solsta,
    stakey[] skc,
    stakey[] skx,
    stakey[] skn,
    double[] xc,
    double[] xx,
    double[] y,
    double[] slc,
    double[] suc,
    double[] slx,
    double[] sux,
    double[] snx);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skc</tt></a> (output)</dt>
<dd>Status keys for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skx</tt></a> (output)</dt>
<dd>Status keys for the variables.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skn</tt></a> (output)</dt>
<dd>Status keys for the conic constraints.</dd>
<dt><tt class="tt">xc</tt> (output)</dt>
<dd>Primal constraint solution.</dd>
<dt><tt class="tt">xx</tt> (output)</dt>
<dd>Primal variable solution (<span class="math"><span class="mi">x</span></span>).</dd>
<dt><tt class="tt">y</tt> (output)</dt>
<dd>Vector of dual variables corresponding to the constraints.</dd>
<dt><tt class="tt">slc</tt> (output)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (<span class="math"><img src="math/math760.png" alt="[[MathCmd 760]]"/></span>).</dd>
<dt><tt class="tt">suc</tt> (output)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (<span class="math"><img src="math/math761.png" alt="[[MathCmd 761]]"/></span>).</dd>
<dt><tt class="tt">slx</tt> (output)</dt>
<dd>Dual variables corresponding to the lower bounds on the variables (<span class="math"><img src="math/math762.png" alt="[[MathCmd 762]]"/></span>).</dd>
<dt><tt class="tt">sux</tt> (output)</dt>
<dd>Dual variables corresponding to the upper bounds on the variables (appears as <span class="math"><img src="math/math763.png" alt="[[MathCmd 763]]"/></span>).</dd>
<dt><tt class="tt">snx</tt> (output)</dt>
<dd>Dual variables corresponding to the conic constraints on the variables (<span class="math"><img src="math/math764.png" alt="[[MathCmd 764]]"/></span>).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the complete solution.</p>

<p>Consider the case of linear programming. The primal problem is given by </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math765.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x+c^{f} &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x & \leq{} & u^{x}.\end{array}\end{math}"/></td>
<td>(15.9.10)</td></tr>
</tbody>
</table>

<p> and the corresponding dual problem is </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math191.png" alt="\begin{math}\nonumber{}\begin{array}{lccl}\nonumber{}\mbox{maximize} & (l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c} &  & \\\nonumber{} & +(l^{x})^{T}s_{l}^{x}-(u^{x})^{T}s_{u}^{x}+c^{f} &  & \\\nonumber{}\mbox{subject to} & A^{T}y+s_{l}^{x}-s_{u}^{x} & = & c,\\\nonumber{} & -y+s_{l}^{c}-s_{u}^{c} & = & 0,\\\nonumber{} & s_{l}^{c},s_{u}^{c},s_{l}^{x},s_{u}^{x}\geq{}0. &  &\end{array}\end{math}"/></td>
<td>(15.9.11)</td></tr>
</tbody>
</table>

<p> In this case the mapping between variables and arguments to the function is as follows: </p>

<dl class="description">
<dt></dt>
<dd>
<p><tt class="tt">xx</tt>: Corresponds to variable <span class="math"><span class="mi">x</span></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">y</tt>: Corresponds to variable <span class="math"><span class="mi">y</span></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">slc</tt>: Corresponds to variable <span class="math"><img src="math/math760.png" alt="[[MathCmd 760]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">suc</tt>: Corresponds to variable <span class="math"><img src="math/math761.png" alt="[[MathCmd 761]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">slx</tt>: Corresponds to variable <span class="math"><img src="math/math762.png" alt="[[MathCmd 762]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">sux</tt>: Corresponds to variable <span class="math"><img src="math/math763.png" alt="[[MathCmd 763]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">xc</tt>: Corresponds to <span class="math"><span class="mi">A</span><span class="mi">x</span></span>. </p>
</dd>
</dl>

<p> The meaning of the values returned by this function depend on the <em>solution status</em> returned in the argument <tt class="tt">solsta</tt>. The most important possible values of <tt class="tt">solsta</tt> are: </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*optimal"><tt class="tt">mosek.solsta.optimal</tt></a> An optimal solution satisfying the optimality criteria for continuous problems is returned. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*integer-optimal"><tt class="tt">mosek.solsta.integer_optimal</tt></a> An optimal solution satisfying the optimality criteria for integer problems is returned. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*prim-feas"><tt class="tt">mosek.solsta.prim_feas</tt></a> A solution satisfying the feasibility criteria. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*prim-infeas-cer"><tt class="tt">mosek.solsta.prim_infeas_cer</tt></a> A primal certificate of infeasibility is returned. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*dual-infeas-cer"><tt class="tt">mosek.solsta.dual_infeas_cer</tt></a> A dual certificate of infeasibility is returned. </p>
</dd>
</dl>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">mosek.Task.getsolutioni</tt></a></dt>
<dd>
<p> Obtains the solution for a single constraint or variable.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutionslice"><tt class="tt">mosek.Task.getsolutionslice</tt></a></dt>
<dd>
<p> Obtains a slice of the solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getsolutioni</tt></span>

<p> <a name="func*mosek*task*getsolutioni">&#09;</a><a name="common-func*mosek*task*getsolutioni"></a> <a name="idx-104386432">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getsolutioni (
    accmode accmode,
    int i,
    soltype whichsol,
    out stakey sk,
    out double x,
    out double sl,
    out double su,
    out double sn);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a> the solution information for a constraint is retrieved. Otherwise for a variable.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">sk</tt></a> (output)</dt>
<dd>Status key of the constraint of variable.</dd>
<dt><tt class="tt">x</tt> (output)</dt>
<dd>Solution value of the primal variable.</dd>
<dt><tt class="tt">sl</tt> (output)</dt>
<dd>Solution value of the dual variable associated with the lower bound.</dd>
<dt><tt class="tt">su</tt> (output)</dt>
<dd>Solution value of the dual variable associated with the upper bound.</dd>
<dt><tt class="tt">sn</tt> (output)</dt>
<dd>Solution value of the dual variable associated with the cone constraint.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the primal and dual solution information for a single constraint or variable.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">mosek.Task.getsolution</tt></a></dt>
<dd>
<p> Obtains the complete solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutionslice"><tt class="tt">mosek.Task.getsolutionslice</tt></a></dt>
<dd>
<p> Obtains a slice of the solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getsolutioninf</tt></span>

<p> <a name="func*mosek*task*getsolutioninf">&#09;</a><a name="common-func*mosek*task*getsolutioninf"></a> <a name="idx-104419272">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getsolutioninf (
    soltype whichsol,
    out prosta prosta,
    out solsta solsta,
    out double primalobj,
    out double maxpbi,
    out double maxpcni,
    out double maxpeqi,
    out double maxinti,
    out double dualobj,
    out double maxdbi,
    out double maxdcni,
    out double maxdeqi);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
<dt><tt class="tt">primalobj</tt> (output)</dt>
<dd>
<p>Value of the primal objective. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math771.png" alt="\begin{math}\nonumber{}c^{T}x+c^{f}\end{math}"/></td>
<td>(15.9.12)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxpbi</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in primal bounds on variables. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math772.png" alt="\begin{math}\nonumber{}\max \left\lbrace{}0,\max _{{i\in{}{1,\ldots ,n-1}}}(x_{i}-u^{x}_{i}),\max _{{i\in{}{1,\ldots ,n-1}}}(l^{x}_{i}-x_{i}),\max _{{i\in{}{1,\ldots ,n-1}}}(x^{c}_{i}-u^{c}_{i}),\max _{{i\in{}{1,\ldots ,n-1}}}(l^{c}_{i}-x^{c}_{i})\right\rbrace{}\end{math}"/></td>
<td>(15.9.13)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxpcni</tt> (output)</dt>
<dd>Maximum infeasibility in the primal conic constraints.</dd>
<dt><tt class="tt">maxpeqi</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in primal equality constraints. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math773.png" alt="\begin{math}\nonumber{}\left\|Ax-x^{c}\right\|_{\infty }\end{math}"/></td>
<td>(15.9.14)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxinti</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in integer constraints. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math774.png" alt="\begin{math}\nonumber{}\max _{{i\in{}\lbrace{}0,\ldots ,n-1\rbrace{}}}(\min (x_{i}-\lfloor x_{i}\rfloor ,\lceil x_{i}\rceil -x_{i})).\end{math}"/></td>
<td>(15.9.15)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">dualobj</tt> (output)</dt>
<dd>
<p>Value of the dual objective. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math775.png" alt="\begin{math}\nonumber{}(l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c}+c^{f}\end{math}"/></td>
<td>(15.9.16)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxdbi</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in bounds on dual variables. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math776.png" alt="\begin{math}\nonumber{}\max \lbrace{}0,\max _{{i\in{}\lbrace{}0,\ldots ,n-1\rbrace{}}}-(s_{l}^{x})_{i},\max _{{i\in{}\lbrace{}0,\ldots ,n-1\rbrace{}}}-(s_{u}^{x})_{i},\max _{{i\in{}\lbrace{}0,\ldots ,m-1\rbrace{}}}-(s_{l}^{c})_{i},\max _{{i\in{}\lbrace{}0,\ldots ,m-1\rbrace{}}}-(s_{u}^{c})_{i}\rbrace{}\end{math}"/></td>
<td>(15.9.17)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxdcni</tt> (output)</dt>
<dd>Maximum infeasibility in the dual conic constraints.</dd>
<dt><tt class="tt">maxdeqi</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in the dual equality constraints. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math777.png" alt="\begin{math}\nonumber{}\max \left\lbrace{}\left\|A^{T}y+s_{l}^{x}-s_{u}^{x}-c\right\|_{\infty },\left\|-y+s_{l}^{c}-s_{u}^{c}\right\|_{\infty }\right\rbrace{}\end{math}"/></td>
<td>(15.9.18)</td></tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains information about the quality of a solution. Part of the following documentation is restricted to the linear case, it should be clear how to extend to other problem classes.</p>

<p>When optimizing MOSEK solves a reformulated problem with only equality constraints. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math778.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x+c^{f} &  & \\\nonumber{}\mbox{subject to} &  &  & Ax-x^{c} & = & 0\\\nonumber{} & l^{x} & \leq{} & x & \leq{} & u^{x},\\\nonumber{} & l^{c} & \leq{} & x^{c} & \leq{} & u^{c}.\end{array}\end{math}"/></td>
<td><a name="ais-ch-apiex-basissolve-eq-primal">&#09;</a>(15.9.19)</td></tr>
</tbody>
</table>

<p>  where  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math155.png" alt="\begin{displaymath}\nonumber{}x^{c}\in{}\mathbb{R}^{{m}}\mbox{ and }x\in{}\mathbb{R}^{n}.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> and the corresponding dual problem is </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math780.png" alt="\begin{math}\nonumber{}\begin{array}{lccl}\nonumber{}\mbox{maximize} & (l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c}+c^{f} &  & \\\nonumber{} & +(l^{x})^{T}s_{l}^{x}-(u^{x})^{T}s_{u}^{x}+c^{f} &  & \\\nonumber{}\mbox{subject to} & A^{T}y+s_{l}^{x}-s_{u}^{x} & = & c,\\\nonumber{} & -y+s_{l}^{c}-s_{u}^{c} & = & 0,\\\nonumber{} & s_{l}^{c},s_{u}^{c},s_{l}^{x},s_{u}^{x}\geq{}0. &  &\end{array}\end{math}"/></td>
<td>(15.9.20)</td></tr>
</tbody>
</table>

<p>  The values returned by this function refers to these problems.</p>

<p>Please note that this function computes the objective value and other values every time it is called. Hence, for efficiency reasons this function should not be used too frequently.</p>

<p>If only the problem status or the solution status is required then use <a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">mosek.Task.getsolutionstatus</tt></a> instead.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getpeqi"><tt class="tt">mosek.Task.getpeqi</tt></a></dt>
<dd>
<p> Obtains the primal equation infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdeqi"><tt class="tt">mosek.Task.getdeqi</tt></a></dt>
<dd>
<p> Optains the dual equation infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getpbi"><tt class="tt">mosek.Task.getpbi</tt></a></dt>
<dd>
<p> Obtains the primal bound infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdbi"><tt class="tt">mosek.Task.getdbi</tt></a></dt>
<dd>
<p> Obtains the dual bound infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdcni"><tt class="tt">mosek.Task.getdcni</tt></a></dt>
<dd>
<p> Obtains the dual cone infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getpcni"><tt class="tt">mosek.Task.getpcni</tt></a></dt>
<dd>
<p> Obtains the primal cone infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*analyzesolution"><tt class="tt">mosek.Task.analyzesolution</tt></a></dt>
<dd>
<p> Print information related to the quality of the solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">mosek.Task.getsolutionstatus</tt></a></dt>
<dd>
<p> Obtains information about the problem and solution statuses.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getsolutionslice</tt></span>

<p> <a name="func*mosek*task*getsolutionslice">&#09;</a><a name="common-func*mosek*task*getsolutionslice"></a> <a name="idx-104491056">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getsolutionslice (
    soltype whichsol,
    solitem solitem,
    int first,
    int last,
    double[] values);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*solitem"><tt class="tt">solitem</tt></a> (input)</dt>
<dd>Which part of the solution is required.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first value in the slice.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Value of the last index+1 in the slice, e.g. if <span class="math"><img src="math/math781.png" alt="[[MathCmd 781]]"/></span> is required <tt class="tt">last</tt> should be <span class="math"><span class="mn">10</span></span>.</dd>
<dt><tt class="tt">values</tt> (output)</dt>
<dd>The values in the required sequence are stored sequentially in <tt class="tt">values</tt> starting at <tt class="tt">values[0]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains a slice of the solution.</p>

<p>Consider the case of linear programming. The primal problem is given by </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math765.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x+c^{f} &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x & \leq{} & u^{x}.\end{array}\end{math}"/></td>
<td>(15.9.21)</td></tr>
</tbody>
</table>

<p> and the corresponding dual problem is </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math191.png" alt="\begin{math}\nonumber{}\begin{array}{lccl}\nonumber{}\mbox{maximize} & (l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c} &  & \\\nonumber{} & +(l^{x})^{T}s_{l}^{x}-(u^{x})^{T}s_{u}^{x}+c^{f} &  & \\\nonumber{}\mbox{subject to} & A^{T}y+s_{l}^{x}-s_{u}^{x} & = & c,\\\nonumber{} & -y+s_{l}^{c}-s_{u}^{c} & = & 0,\\\nonumber{} & s_{l}^{c},s_{u}^{c},s_{l}^{x},s_{u}^{x}\geq{}0. &  &\end{array}\end{math}"/></td>
<td>(15.9.22)</td></tr>
</tbody>
</table>

<p> The <tt class="tt">solitem</tt> argument determines which part of the solution is returned: </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*xx"><tt class="tt">mosek.solitem.xx</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><span class="mi">x</span></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*y"><tt class="tt">mosek.solitem.y</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><span class="mi">y</span></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*slc"><tt class="tt">mosek.solitem.slc</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><img src="math/math760.png" alt="[[MathCmd 760]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*suc"><tt class="tt">mosek.solitem.suc</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><img src="math/math761.png" alt="[[MathCmd 761]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*slx"><tt class="tt">mosek.solitem.slx</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><img src="math/math762.png" alt="[[MathCmd 762]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*sux"><tt class="tt">mosek.solitem.sux</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><img src="math/math763.png" alt="[[MathCmd 763]]"/></span>. </p>
</dd>
</dl>

<p> A conic optimization problem has the same primal variables as in the linear case. Recall that the dual of a conic optimization problem is given by: </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math243.png" alt="\begin{math}\nonumber{}\begin{array}{lccccc}\nonumber{}\mbox{maximize} & (l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c} &  & \\\nonumber{} & +(l^{x})^{T}s_{l}^{x}-(u^{x})^{T}s_{u}^{x}+c^{f} &  & \\\nonumber{}\mbox{subject to} & A^{T}y+s_{l}^{x}-s_{u}^{x}+s_{n}^{x} & = & c,\\\nonumber{} & -y+s_{l}^{c}-s_{u}^{c} & = & 0,\\\nonumber{} & s_{l}^{c},s_{u}^{c},s_{l}^{x},s_{u}^{x} & \geq{} & 0,\\\nonumber{} & s_{n}^{x}\in{}\mathcal{C}^{*} &  &\end{array}\end{math}"/></td>
<td>(15.9.23)</td></tr>
</tbody>
</table>

<p> This introduces one additional dual variable <span class="math"><img src="math/math764.png" alt="[[MathCmd 764]]"/></span>. This variable can be acceded by selecting <tt class="tt">solitem</tt> as <a href="node020.html#common-const*mosek*solitem*snx"><tt class="tt">mosek.solitem.snx</tt></a>.</p>

<p>The meaning of the values returned by this function also depends on the <em>solution status</em> which can be obtained with <a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">mosek.Task.getsolutionstatus</tt></a>. Depending on the solution status <tt class="tt">value</tt> will be: </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*optimal"><tt class="tt">mosek.solsta.optimal</tt></a> A part of the optimal solution satisfying the optimality criteria for continuous problems. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*integer-optimal"><tt class="tt">mosek.solsta.integer_optimal</tt></a> A part of the optimal solution satisfying the optimality criteria for integer problems. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*prim-feas"><tt class="tt">mosek.solsta.prim_feas</tt></a> A part of the solution satisfying the feasibility criteria. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*prim-infeas-cer"><tt class="tt">mosek.solsta.prim_infeas_cer</tt></a> A part of the primal certificate of infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*dual-infeas-cer"><tt class="tt">mosek.solsta.dual_infeas_cer</tt></a> A part of the dual certificate of infeasibility. </p>
</dd>
</dl>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">mosek.Task.getsolution</tt></a></dt>
<dd>
<p> Obtains the complete solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">mosek.Task.getsolutioni</tt></a></dt>
<dd>
<p> Obtains the solution for a single constraint or variable.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getsolutionstatus</tt></span>

<p> <a name="func*mosek*task*getsolutionstatus">&#09;</a><a name="common-func*mosek*task*getsolutionstatus"></a> <a name="idx-104567440">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getsolutionstatus (
    soltype whichsol,
    out prosta prosta,
    out solsta solsta);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains information about the problem and solution statuses.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getsolutionstatuskeyslice</tt></span>

<p> <a name="func*mosek*task*getsolutionstatuskeyslice">&#09;</a><a name="common-func*mosek*task*getsolutionstatuskeyslice"></a> <a name="idx-104586992">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getsolutionstatuskeyslice (
    accmode accmode,
    soltype whichsol,
    int first,
    int last,
    stakey[] sk);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first value in the slice.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Value of the last index+1 in the slice, e.g. if <span class="math"><img src="math/math781.png" alt="[[MathCmd 781]]"/></span> is required <tt class="tt">last</tt> should be <span class="math"><span class="mn">10</span></span>.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">sk</tt></a> (output)</dt>
<dd>The status keys in the required sequence are stored sequentially in <tt class="tt">sk</tt> starting at <tt class="tt">sk[0]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a slice of the solution status keys.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">mosek.Task.getsolution</tt></a></dt>
<dd>
<p> Obtains the complete solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">mosek.Task.getsolutioni</tt></a></dt>
<dd>
<p> Obtains the solution for a single constraint or variable.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.gettaskname64</tt></span>

<p> <a name="func*mosek*task*gettaskname64">&#09;</a><a name="common-func*mosek*task*gettaskname64"></a> <a name="idx-104613864">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public string gettaskname64 (out long len)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the task name.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void gettaskname64 (
    out long len,
    StringBuilder taskname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the task name.</dd>
<dt><tt class="tt">taskname</tt> (output)</dt>
<dd>Is assigned the task name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name assigned to the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getvarbranchdir</tt></span>

<p> <a name="func*mosek*task*getvarbranchdir">&#09;</a><a name="common-func*mosek*task*getvarbranchdir"></a> <a name="idx-104616880">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getvarbranchdir (int j)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getvarbranchdir (
    int j,
    out int direction);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*branchdir"><tt class="tt">direction</tt></a> (output)</dt>
<dd>The branching direction assigned to variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the branching direction for a given variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getvarbranchorder</tt></span>

<p> <a name="func*mosek*task*getvarbranchorder">&#09;</a><a name="common-func*mosek*task*getvarbranchorder"></a> <a name="idx-115086976">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getvarbranchorder (
    int j,
    out int priority,
    out int direction);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><tt class="tt">priority</tt> (output)</dt>
<dd>The branching priority assigned to variable <span class="math"><span class="mi">j</span></span>.</dd>
<dt><a href="node020.html#common-constclass*mosek*branchdir"><tt class="tt">direction</tt></a> (output)</dt>
<dd>The preferred branching direction for the j'th variable.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the branching priority and direction for a given variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getvarbranchpri</tt></span>

<p> <a name="func*mosek*task*getvarbranchpri">&#09;</a><a name="common-func*mosek*task*getvarbranchpri"></a> <a name="idx-115107816">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int getvarbranchpri (int j)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getvarbranchpri (
    int j,
    out int priority);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><tt class="tt">priority</tt> (output)</dt>
<dd>The branching priority assigned to variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the branching priority for a given variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getvarname</tt></span>

<p> <a name="func*mosek*task*getvarname64">&#09;</a><a name="common-func*mosek*task*getvarname64"></a> <a name="idx-115098328">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public string getvarname (int i)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getvarname (
    int i,
    StringBuilder name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a variable.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getvartype</tt></span>

<p> <a name="func*mosek*task*getvartype">&#09;</a><a name="common-func*mosek*task*getvartype"></a> <a name="idx-115133832">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public variabletype getvartype (int j)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getvartype (
    int j,
    out variabletype vartype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*variabletype"><tt class="tt">vartype</tt></a> (output)</dt>
<dd>Variable type of variable <tt class="tt">j</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Gets the variable type of one variable.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.getvartypelist</tt></span>

<p> <a name="func*mosek*task*getvartypelist">&#09;</a><a name="common-func*mosek*task*getvartypelist"></a> <a name="idx-115146120">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void getvartypelist (
    int[] subj,
    variabletype[] vartype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>A list of variable indexes.</dd>
<dt><a href="node020.html#common-constclass*mosek*variabletype"><tt class="tt">vartype</tt></a> (output)</dt>
<dd>The variables types corresponding to the variables specified by <tt class="tt">subj</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the variable type of one or more variables.</p>

<p>Upon return <tt class="tt">vartype[k]</tt> is the variable type of variable <tt class="tt">subj[k]</tt>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.initbasissolve</tt></span>

<p> <a name="func*mosek*task*initbasissolve">&#09;</a><a name="common-func*mosek*task*initbasissolve"></a> <a name="idx-115165160">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void initbasissolve (int[] basis)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">basis</tt> (output)</dt>
<dd>
<p>The array of basis indexes to use.</p>

<p>The array is interpreted as follows: If <span class="math"><img src="math/math791.png" alt="[[MathCmd 791]]"/></span>, then <span class="math"><img src="math/math792.png" alt="[[MathCmd 792]]"/></span> is in the basis at position <span class="math"><span class="mi">i</span></span>, otherwise <span class="math"><img src="math/math793.png" alt="[[MathCmd 793]]"/></span> is in the basis at position <span class="math"><span class="mi">i</span></span>.</p>
</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Prepare a task for use with the <a href="node017.html#common-func*mosek*task*solvewithbasis"><tt class="tt">mosek.Task.solvewithbasis</tt></a> function.</p>

<p>This function should be called </p>

<ul class="itemize">
<li>immediately before the first call to <a href="node017.html#common-func*mosek*task*solvewithbasis"><tt class="tt">mosek.Task.solvewithbasis</tt></a>, and </li>
<li>immediately before any subsequent call to <a href="node017.html#common-func*mosek*task*solvewithbasis"><tt class="tt">mosek.Task.solvewithbasis</tt></a> if the task has been modified. </li>
</ul>

<p> If the basis is singular i.e. not invertible, then </p>

<p>the exception <a href="#common-const*mosek*rescode*err-basis-singular"><tt class="tt">mosek.rescode.err_basis_singular</tt></a> is generated. </p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.inputdata</tt></span>

<p> <a name="func*mosek*task*inputdata">&#09;</a><a name="common-func*mosek*task*inputdata"></a> <a name="idx-115180680">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void inputdata (
    int maxnumcon,
    int maxnumvar,
    double[] c,
    double cfix,
    int[] aptrb,
    int[] aptre,
    int[] asub,
    double[] aval,
    boundkey[] bkc,
    double[] blc,
    double[] buc,
    boundkey[] bkx,
    double[] blx,
    double[] bux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>Number of preallocated constraints in the optimization task.</dd>
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>Number of preallocated variables in the optimization task.</dd>
<dt><tt class="tt">c</tt> (input)</dt>
<dd>Linear terms of the objective as a dense vector. The lengths is the number of variables.</dd>
<dt><tt class="tt">cfix</tt> (input)</dt>
<dd>Fixed term in the objective.</dd>
<dt><tt class="tt">aptrb</tt> (input)</dt>
<dd>Pointer to the first element in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aptre</tt> (input)</dt>
<dd>Pointers to the last element + 1 in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a></dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>Coefficient subscripts. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (input)</dt>
<dd>Bound keys for the constraints.</dd>
<dt><tt class="tt">blc</tt> (input)</dt>
<dd>Lower bounds for the constraints.</dd>
<dt><tt class="tt">buc</tt> (input)</dt>
<dd>Upper bounds for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (input)</dt>
<dd>Bound keys for the variables.</dd>
<dt><tt class="tt">blx</tt> (input)</dt>
<dd>Lower bounds for the variables.</dd>
<dt><tt class="tt">bux</tt> (input)</dt>
<dd>Upper bounds for the variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Input the linear part of an optimization problem.</p>

<p>The non-zeros of <span class="math"><span class="mi">A</span></span> are inputted column-wise in the format described in Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</p>

<p>For an explained code example see Section <a title="5.2. Linear optimization" href="node007.html#chap-apiintro-sec-linear-optimization">5.2</a> and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.inputdata</tt></span>

<p> <a name="func*mosek*task*inputdata64">&#09;</a><a name="common-func*mosek*task*inputdata64"></a> <a name="idx-115216328">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void inputdata (
    int maxnumcon,
    int maxnumvar,
    double[] c,
    double cfix,
    long[] aptrb,
    long[] aptre,
    int[] asub,
    double[] aval,
    boundkey[] bkc,
    double[] blc,
    double[] buc,
    boundkey[] bkx,
    double[] blx,
    double[] bux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>Number of preallocated constraints in the optimization task.</dd>
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>Number of preallocated variables in the optimization task.</dd>
<dt><tt class="tt">c</tt> (input)</dt>
<dd>Linear terms of the objective as a dense vector. The lengths is the number of variables.</dd>
<dt><tt class="tt">cfix</tt> (input)</dt>
<dd>Fixed term in the objective.</dd>
<dt><tt class="tt">aptrb</tt> (input)</dt>
<dd>Pointer to the first element in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aptre</tt> (input)</dt>
<dd>Pointers to the last element + 1 in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a></dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>Coefficient subscripts. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (input)</dt>
<dd>Bound keys for the constraints.</dd>
<dt><tt class="tt">blc</tt> (input)</dt>
<dd>Lower bounds for the constraints.</dd>
<dt><tt class="tt">buc</tt> (input)</dt>
<dd>Upper bounds for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (input)</dt>
<dd>Bound keys for the variables.</dd>
<dt><tt class="tt">blx</tt> (input)</dt>
<dd>Lower bounds for the variables.</dd>
<dt><tt class="tt">bux</tt> (input)</dt>
<dd>Upper bounds for the variables.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void inputdata (
    int maxnumcon,
    int maxnumvar,
    int numcon,
    int numvar,
    double[] c,
    double cfix,
    long[] aptrb,
    long[] aptre,
    int[] asub,
    double[] aval,
    boundkey[] bkc,
    double[] blc,
    double[] buc,
    boundkey[] bkx,
    double[] blx,
    double[] bux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>Number of preallocated constraints in the optimization task.</dd>
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>Number of preallocated variables in the optimization task.</dd>
<dt><tt class="tt">numcon</tt> (input)</dt>
<dd>Number of constraints.</dd>
<dt><tt class="tt">numvar</tt> (input)</dt>
<dd>Number of variables.</dd>
<dt><tt class="tt">c</tt> (input)</dt>
<dd>Linear terms of the objective as a dense vector. The lengths is the number of variables.</dd>
<dt><tt class="tt">cfix</tt> (input)</dt>
<dd>Fixed term in the objective.</dd>
<dt><tt class="tt">aptrb</tt> (input)</dt>
<dd>Pointer to the first element in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aptre</tt> (input)</dt>
<dd>Pointers to the last element + 1 in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a></dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>Coefficient subscripts. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (input)</dt>
<dd>Bound keys for the constraints.</dd>
<dt><tt class="tt">blc</tt> (input)</dt>
<dd>Lower bounds for the constraints.</dd>
<dt><tt class="tt">buc</tt> (input)</dt>
<dd>Upper bounds for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (input)</dt>
<dd>Bound keys for the variables.</dd>
<dt><tt class="tt">blx</tt> (input)</dt>
<dd>Lower bounds for the variables.</dd>
<dt><tt class="tt">bux</tt> (input)</dt>
<dd>Upper bounds for the variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Input the linear part of an optimization problem.</p>

<p>The non-zeros of <span class="math"><span class="mi">A</span></span> are inputted column-wise in the format described in Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</p>

<p>For an explained code example see Section <a title="5.2. Linear optimization" href="node007.html#chap-apiintro-sec-linear-optimization">5.2</a> and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.isdouparname</tt></span>

<p> <a name="func*mosek*task*isdouparname">&#09;</a><a name="common-func*mosek*task*isdouparname"></a> <a name="idx-115291056">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void isdouparname (
    string parname,
    out dparam param);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">parname</tt> (input)</dt>
<dd>Parameter name.</dd>
<dt><a href="node018.html#common-constclass*mosek*dparam"><tt class="tt">param</tt></a> (output)</dt>
<dd>Which parameter.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks whether <tt class="tt">parname</tt> is a valid double parameter name.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.isintparname</tt></span>

<p> <a name="func*mosek*task*isintparname">&#09;</a><a name="common-func*mosek*task*isintparname"></a> <a name="idx-115241112">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void isintparname (
    string parname,
    out iparam param);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">parname</tt> (input)</dt>
<dd>Parameter name.</dd>
<dt><a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">param</tt></a> (output)</dt>
<dd>Which parameter.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks whether <tt class="tt">parname</tt> is a valid integer parameter name.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.isstrparname</tt></span>

<p> <a name="func*mosek*task*isstrparname">&#09;</a><a name="common-func*mosek*task*isstrparname"></a> <a name="idx-115308736">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void isstrparname (
    string parname,
    out sparam param);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">parname</tt> (input)</dt>
<dd>Parameter name.</dd>
<dt><a href="node018.html#common-constclass*mosek*sparam"><tt class="tt">param</tt></a> (output)</dt>
<dd>Which parameter.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks whether <tt class="tt">parname</tt> is a valid string parameter name.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.linkfiletostream</tt></span>

<p> <a name="func*mosek*task*linkfiletotaskstream">&#09;</a><a name="common-func*mosek*task*linkfiletotaskstream"></a> <a name="idx-115259224">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void linkfiletostream (
    streamtype whichstream,
    string filename,
    int append);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>The name of the file where text from the stream defined by <tt class="tt">whichstream</tt> is written.</dd>
<dt><tt class="tt">append</tt> (input)</dt>
<dd>If this argument is 0 the output file will be overwritten, otherwise text is append to the output file.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Directs all output from a task stream to a file.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.makesolutionstatusunknown</tt></span>

<p> <a name="func*mosek*task*makesolutionstatusunknown">&#09;</a><a name="common-func*mosek*task*makesolutionstatusunknown"></a> <a name="idx-115336472">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void makesolutionstatusunknown (soltype whichsol)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the solution status to unknown. Also all the status keys for the constraints and the variables are set to unknown.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.netextraction</tt></span>

<p> <a name="func*mosek*task*netextraction">&#09;</a><a name="common-func*mosek*task*netextraction"></a> <a name="idx-115285528">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void netextraction (
    out int numcon,
    out int numvar,
    int[] netcon,
    int[] netvar,
    double[] scalcon,
    double[] scalvar,
    double[] cx,
    boundkey[] bkc,
    double[] blc,
    double[] buc,
    boundkey[] bkx,
    double[] blx,
    double[] bux,
    int[] from,
    int[] to);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numcon</tt> (output)</dt>
<dd>Number of network constraints (nodes) in the embedded network.</dd>
<dt><tt class="tt">numvar</tt> (output)</dt>
<dd>Number of network variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">netcon</tt> (output)</dt>
<dd>Indexes of network constraints (nodes) in the embedded network.</dd>
<dt><tt class="tt">netvar</tt> (output)</dt>
<dd>Indexes of network variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">scalcon</tt> (output)</dt>
<dd>Scaling values on constraints, used to convert the original part of the problem into network form.</dd>
<dt><tt class="tt">scalvar</tt> (output)</dt>
<dd>Scaling values on variables, used to convert the original part of the problem into network form.</dd>
<dt><tt class="tt">cx</tt> (output)</dt>
<dd>Linear terms of the objective for variables (arcs) in the embedded network as a dense vector.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (output)</dt>
<dd>Bound keys for the constraints (nodes) in the embedded network.</dd>
<dt><tt class="tt">blc</tt> (output)</dt>
<dd>Lower bounds for the constraints (nodes) in the embedded network.</dd>
<dt><tt class="tt">buc</tt> (output)</dt>
<dd>Upper bounds for the constraints (nodes) in the embedded network.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (output)</dt>
<dd>Bound keys for the variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">blx</tt> (output)</dt>
<dd>Lower bounds for the variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">bux</tt> (output)</dt>
<dd>Upper bounds for the variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">from</tt> (output)</dt>
<dd>Defines the origins of the arcs in the embedded network.</dd>
<dt><tt class="tt">to</tt> (output)</dt>
<dd>Defines the destinations of the arcs in the embedded network.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Uses a heuristic to find an embedded network in the problem specified in task. The returned network is a pure network flow problem and can be solved with a direct call to the network optimizer <a href="node017.html#common-func*mosek*task*netoptimize"><tt class="tt">mosek.Task.netoptimize</tt></a>. 
<br/>Each arc <span class="math"><span class="mi">a</span></span> in the network corresponds to a scaled subset of elements in column <span class="math"><img src="math/math794.png" alt="[[MathCmd 794]]"/></span> from the constraint matrix <span class="math"><span class="mi">A</span></span> stored in <tt class="tt">task</tt>. Each node <span class="math"><span class="mi">n</span></span> in the network corresponds to a scaled subset of elements in constraint <span class="math"><span class="mi">i</span><span class="mo">=</span><span class="mi">n</span><span class="mi">e</span><span class="mi">t</span><span class="mi">c</span><span class="mi">o</span><span class="mi">n</span><span class="mo">[</span><span class="mi">n</span><span class="mo">]</span></span> from <span class="math"><span class="mi">A</span></span>. Data structures for network problems is explained in <a title="5.2. Linear optimization" href="node007.html#chap-apiintro-sec-linear-optimization">5.2</a> and <a title="6.2. Embedded network flow problems" href="node008.html#advanced-embedded-network">6.2</a>. The relation between <span class="math"><span class="mi">A</span></span> and the extracted embedded network can be explained as follows: </p>

<ul class="itemize">
<li><span class="math"><img src="math/math795.png" alt="[[MathCmd 795]]"/></span> </li>
<li><span class="math"><img src="math/math796.png" alt="[[MathCmd 796]]"/></span> </li>
<li>The scaled matrix has at most two non-zeroes in each column in <tt class="tt">netvar</tt> over the indexes in <tt class="tt">netcon</tt> (i.e defines a pure network flow matrix). </li>
</ul>

<p> Please note if a column <span class="math"><span class="mi">j</span><span class="mo">=</span><span class="mi">n</span><span class="mi">e</span><span class="mi">t</span><span class="mi">v</span><span class="mi">a</span><span class="mi">r</span><span class="mo">[</span><span class="mi">a</span><span class="mo">]</span></span> is only represented by one non-zero in the embedded network, then either <span class="math"><span class="mi">f</span><span class="mi">r</span><span class="mi">o</span><span class="mi">m</span><span class="mo">[</span><span class="mi">a</span><span class="mo">]</span><span class="mo">=</span><span class="mi">n</span><span class="mi">e</span><span class="mi">t</span><span class="mi">c</span><span class="mi">o</span><span class="mi">n</span></span> or <span class="math"><span class="mi">t</span><span class="mi">o</span><span class="mo">[</span><span class="mi">a</span><span class="mo">]</span><span class="mo">=</span><span class="mi">n</span><span class="mi">e</span><span class="mi">t</span><span class="mi">c</span><span class="mi">o</span><span class="mi">n</span></span>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*netoptimize"><tt class="tt">mosek.Task.netoptimize</tt></a></dt>
<dd>
<p> Optimizes a pure network flow problem.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.netoptimize</tt></span>

<p> <a name="func*mosek*task*netoptimize">&#09;</a><a name="common-func*mosek*task*netoptimize"></a> <a name="idx-116861048">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void netoptimize (
    double[] cc,
    double[] cx,
    boundkey[] bkc,
    double[] blc,
    double[] buc,
    boundkey[] bkx,
    double[] blx,
    double[] bux,
    int[] from,
    int[] to,
    out prosta prosta,
    out solsta solsta,
    int hotstart,
    stakey[] skc,
    stakey[] skx,
    double[] xc,
    double[] xx,
    double[] y,
    double[] slc,
    double[] suc,
    double[] slx,
    double[] sux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">cc</tt> (input)</dt>
<dd>Linear terms of the objective for constraints (nodes) as a dense vector.</dd>
<dt><tt class="tt">cx</tt> (input)</dt>
<dd>Linear terms of the objective for variables (arcs) as a dense vector.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (input)</dt>
<dd>Bound keys for the constraints (nodes).</dd>
<dt><tt class="tt">blc</tt> (input)</dt>
<dd>Lower bounds for the constraints (nodes).</dd>
<dt><tt class="tt">buc</tt> (input)</dt>
<dd>Upper bounds for the constraints (nodes).</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (input)</dt>
<dd>Bound keys for the variables (arcs).</dd>
<dt><tt class="tt">blx</tt> (input)</dt>
<dd>Lower bounds for the variables (arcs).</dd>
<dt><tt class="tt">bux</tt> (input)</dt>
<dd>Upper bounds for the variables (arcs).</dd>
<dt><tt class="tt">from</tt> (input)</dt>
<dd>Defines the origins of the arcs in the network.</dd>
<dt><tt class="tt">to</tt> (input)</dt>
<dd>Defines the destinations of the arcs in the network.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
<dt><tt class="tt">hotstart</tt> (input)</dt>
<dd>If zero the network optimizer will not use hot-starts, if non-zero a solution must be defined in the solution variables below, which will be used to hot-start the network optimizer.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skc</tt></a> (input/output)</dt>
<dd>Status keys for the constraints (nodes).</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skx</tt></a> (input/output)</dt>
<dd>Status keys for the variables (arcs).</dd>
<dt><tt class="tt">xc</tt> (input/output)</dt>
<dd>Primal constraint solution (nodes).</dd>
<dt><tt class="tt">xx</tt> (input/output)</dt>
<dd>Primal variable solution (arcs).</dd>
<dt><tt class="tt">y</tt> (input/output)</dt>
<dd>Vector of dual variables corresponding to the constraints (nodes).</dd>
<dt><tt class="tt">slc</tt> (input/output)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (nodes).</dd>
<dt><tt class="tt">suc</tt> (input/output)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (nodes).</dd>
<dt><tt class="tt">slx</tt> (input/output)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (arcs).</dd>
<dt><tt class="tt">sux</tt> (input/output)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (arcs).</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void netoptimize (
    int numcon,
    int numvar,
    double[] cc,
    double[] cx,
    boundkey[] bkc,
    double[] blc,
    double[] buc,
    boundkey[] bkx,
    double[] blx,
    double[] bux,
    int[] from,
    int[] to,
    out prosta prosta,
    out solsta solsta,
    int hotstart,
    stakey[] skc,
    stakey[] skx,
    double[] xc,
    double[] xx,
    double[] y,
    double[] slc,
    double[] suc,
    double[] slx,
    double[] sux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numcon</tt> (input)</dt>
<dd>Number of network constraints (nodes) in the network.</dd>
<dt><tt class="tt">numvar</tt> (input)</dt>
<dd>Number of network variables (arcs) in the network.</dd>
<dt><tt class="tt">cc</tt> (input)</dt>
<dd>Linear terms of the objective for constraints (nodes) as a dense vector.</dd>
<dt><tt class="tt">cx</tt> (input)</dt>
<dd>Linear terms of the objective for variables (arcs) as a dense vector.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (input)</dt>
<dd>Bound keys for the constraints (nodes).</dd>
<dt><tt class="tt">blc</tt> (input)</dt>
<dd>Lower bounds for the constraints (nodes).</dd>
<dt><tt class="tt">buc</tt> (input)</dt>
<dd>Upper bounds for the constraints (nodes).</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (input)</dt>
<dd>Bound keys for the variables (arcs).</dd>
<dt><tt class="tt">blx</tt> (input)</dt>
<dd>Lower bounds for the variables (arcs).</dd>
<dt><tt class="tt">bux</tt> (input)</dt>
<dd>Upper bounds for the variables (arcs).</dd>
<dt><tt class="tt">from</tt> (input)</dt>
<dd>Defines the origins of the arcs in the network.</dd>
<dt><tt class="tt">to</tt> (input)</dt>
<dd>Defines the destinations of the arcs in the network.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
<dt><tt class="tt">hotstart</tt> (input)</dt>
<dd>If zero the network optimizer will not use hot-starts, if non-zero a solution must be defined in the solution variables below, which will be used to hot-start the network optimizer.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skc</tt></a> (input/output)</dt>
<dd>Status keys for the constraints (nodes).</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skx</tt></a> (input/output)</dt>
<dd>Status keys for the variables (arcs).</dd>
<dt><tt class="tt">xc</tt> (input/output)</dt>
<dd>Primal constraint solution (nodes).</dd>
<dt><tt class="tt">xx</tt> (input/output)</dt>
<dd>Primal variable solution (arcs).</dd>
<dt><tt class="tt">y</tt> (input/output)</dt>
<dd>Vector of dual variables corresponding to the constraints (nodes).</dd>
<dt><tt class="tt">slc</tt> (input/output)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (nodes).</dd>
<dt><tt class="tt">suc</tt> (input/output)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (nodes).</dd>
<dt><tt class="tt">slx</tt> (input/output)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (arcs).</dd>
<dt><tt class="tt">sux</tt> (input/output)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (arcs).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Uses the network optimizer to solve the given network problem. The problem must be a pure network flow problem. If <tt class="tt">hotstart</tt> is zero the network optimizer will not use hot-starts, if non-zero a solution must be defined in the solution variables <tt class="tt">skc</tt>,<tt class="tt">skx</tt>,<tt class="tt">xc</tt>,<tt class="tt">xx</tt>,<tt class="tt">y</tt>,<tt class="tt">slc</tt>,<tt class="tt">suc</tt>,<tt class="tt">slx</tt> and <tt class="tt">sux</tt>, which will be used to hot-start the network optimizer. Please note <tt class="tt">task</tt> only acts as a dummy task, where parameters and streams can be set for the network optimizer. No other data in <tt class="tt">task</tt> is used.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*netextraction"><tt class="tt">mosek.Task.netextraction</tt></a></dt>
<dd>
<p> Finds embedded network structure.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.optimizeconcurrent</tt></span>

<p> <a name="func*mosek*task*optimizeconcurrent">&#09;</a><a name="common-func*mosek*task*optimizeconcurrent"></a> <a name="idx-116878008">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void optimizeconcurrent (Task[] taskarray)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">taskarray</tt> (input)</dt>
<dd>An array of <tt class="tt">num</tt> tasks.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Solves several instances of the same problem in parallel, with unique parameter settings for each task. The argument <tt class="tt">task</tt> contains the problem to be solved. <tt class="tt">taskarray</tt> is a pointer to an array of <tt class="tt">num</tt> empty tasks. The task <tt class="tt">task</tt> and the <tt class="tt">num</tt> tasks pointed to by <tt class="tt">taskarray</tt> are solved in parallel. That is <span class="math"><img src="math/math797.png" alt="[[MathCmd 797]]"/></span> threads are started with one optimizer in each. Each of the tasks can be initialized with different parameters, e.g different selection of solver.</p>

<p>All the concurrently running tasks are stopped when the optimizer successfully terminates for one of the tasks. After the function returns <tt class="tt">task</tt> contains the solution found by the task that finished first.</p>

<p>After <a href="node017.html#common-func*mosek*task*optimizeconcurrent"><tt class="tt">mosek.Task.optimizeconcurrent</tt></a> returns <tt class="tt">task</tt> holds the optimal solution of the task which finished first. If all the concurrent optimizations finished without providing an optimal solution the error code from the solution of the task <tt class="tt">task</tt> is returned.</p>

<p>In summary a call to <a href="node017.html#common-func*mosek*task*optimizeconcurrent"><tt class="tt">mosek.Task.optimizeconcurrent</tt></a> does the following:</p>

<ol class="enumerate">
<li>All data except task parameters (<a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">mosek.iparam</tt></a>, <a href="node018.html#common-constclass*mosek*dparam"><tt class="tt">mosek.dparam</tt></a> and <a href="node018.html#common-constclass*mosek*sparam"><tt class="tt">mosek.sparam</tt></a>) in <tt class="tt">task</tt> is copied to each of the tasks in <tt class="tt">taskarray</tt>. In particular this means that any solution in <tt class="tt">task</tt> is copied to the other tasks. Call-back functions are not copied. </li>
<li>The tasks <tt class="tt">task</tt> and the <tt class="tt">num</tt> tasks in <tt class="tt">taskarray</tt> are started in parallel. </li>
<li>When a task finishes providing an optimal solution (or a certificate of infeasibility) its solution is copied to <tt class="tt">task</tt> and all other tasks are stopped. </li>
</ol>

<p> For an explained code example see Section <a title="8.6.4. A more flexible concurrent optimizer" href="node010.html#ch-concurrentopt-sec-flex">8.6.4</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.optimizersummary</tt></span>

<p> <a name="func*mosek*task*optimizersummary">&#09;</a><a name="common-func*mosek*task*optimizersummary"></a> <a name="idx-117001536">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void optimizersummary (streamtype whichstream)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints a short summary with optimizer statistics for last optimization.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.optimize</tt></span>

<p> <a name="func*mosek*task*optimizetrm">&#09;</a><a name="common-func*mosek*task*optimizetrm"></a> <a name="idx-116968480">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public rescode optimize ()
</pre>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void optimize (out rescode trmcode)
</pre>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">trmcode</tt></a> (output)</dt>
<dd>Is either <a href="#common-const*mosek*rescode*ok"><tt class="tt">mosek.rescode.ok</tt></a> or a termination response code.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Calls the optimizer. Depending on the problem type and the selected optimizer this will call one of the optimizers in MOSEK. By default the interior point optimizer will be selected for continuous problems. The optimizer may be selected manually by setting the parameter <a href="node018.html#common-const*mosek*iparam*optimizer"><tt class="tt">mosek.iparam.optimizer</tt></a>.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*optimizeconcurrent"><tt class="tt">mosek.Task.optimizeconcurrent</tt></a></dt>
<dd>
<p> Optimize a given task with several optimizers concurrently.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">mosek.Task.getsolution</tt></a></dt>
<dd>
<p> Obtains the complete solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">mosek.Task.getsolutioni</tt></a></dt>
<dd>
<p> Obtains the solution for a single constraint or variable.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">mosek.Task.getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*optimizer"><tt class="tt">mosek.iparam.optimizer</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.primalsensitivity</tt></span>

<p> <a name="func*mosek*task*primalsensitivity">&#09;</a><a name="common-func*mosek*task*primalsensitivity"></a> <a name="idx-117045656">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void primalsensitivity (
    int[] subi,
    mark[] marki,
    int[] subj,
    mark[] markj,
    double[] leftpricei,
    double[] rightpricei,
    double[] leftrangei,
    double[] rightrangei,
    double[] leftpricej,
    double[] rightpricej,
    double[] leftrangej,
    double[] rightrangej);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">subi</tt> (input)</dt>
<dd>Indexes of bounds on constraints to analyze.</dd>
<dt><a href="node020.html#common-constclass*mosek*mark"><tt class="tt">marki</tt></a> (input)</dt>
<dd>The value of <tt class="tt">marki[i]</tt> specifies for which bound (upper or lower) on constraint <tt class="tt">subi[i]</tt> sensitivity analysis should be performed.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Indexes of bounds on variables to analyze.</dd>
<dt><a href="node020.html#common-constclass*mosek*mark"><tt class="tt">markj</tt></a> (input)</dt>
<dd>The value of <tt class="tt">markj[j]</tt> specifies for which bound (upper or lower) on variable <tt class="tt">subj[j]</tt> sensitivity analysis should be performed.</dd>
<dt><tt class="tt">leftpricei</tt> (output)</dt>
<dd><tt class="tt">leftpricei[i]</tt> is the left shadow price for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">rightpricei</tt> (output)</dt>
<dd><tt class="tt">rightpricei[i]</tt> is the right shadow price for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">leftrangei</tt> (output)</dt>
<dd><tt class="tt">leftrangei[i]</tt> is the left range for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">rightrangei</tt> (output)</dt>
<dd><tt class="tt">rightrangei[i]</tt> is the right range for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">leftpricej</tt> (output)</dt>
<dd><tt class="tt">leftpricej[j]</tt> is the left shadow price for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt>.</dd>
<dt><tt class="tt">rightpricej</tt> (output)</dt>
<dd><tt class="tt">rightpricej[j]</tt> is the right shadow price for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt> .</dd>
<dt><tt class="tt">leftrangej</tt> (output)</dt>
<dd><tt class="tt">leftrangej[j]</tt> is the left range for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt>.</dd>
<dt><tt class="tt">rightrangej</tt> (output)</dt>
<dd><tt class="tt">rightrangej[j]</tt> is the right range for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void primalsensitivity (
    int numi,
    int[] subi,
    mark[] marki,
    int numj,
    int[] subj,
    mark[] markj,
    double[] leftpricei,
    double[] rightpricei,
    double[] leftrangei,
    double[] rightrangei,
    double[] leftpricej,
    double[] rightpricej,
    double[] leftrangej,
    double[] rightrangej);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numi</tt> (input)</dt>
<dd>Number of bounds on constraints to be analyzed. Length of <tt class="tt">subi</tt> and <tt class="tt">marki</tt>.</dd>
<dt><tt class="tt">subi</tt> (input)</dt>
<dd>Indexes of bounds on constraints to analyze.</dd>
<dt><a href="node020.html#common-constclass*mosek*mark"><tt class="tt">marki</tt></a> (input)</dt>
<dd>The value of <tt class="tt">marki[i]</tt> specifies for which bound (upper or lower) on constraint <tt class="tt">subi[i]</tt> sensitivity analysis should be performed.</dd>
<dt><tt class="tt">numj</tt> (input)</dt>
<dd>Number of bounds on variables to be analyzed. Length of <tt class="tt">subj</tt> and <tt class="tt">markj</tt>.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Indexes of bounds on variables to analyze.</dd>
<dt><a href="node020.html#common-constclass*mosek*mark"><tt class="tt">markj</tt></a> (input)</dt>
<dd>The value of <tt class="tt">markj[j]</tt> specifies for which bound (upper or lower) on variable <tt class="tt">subj[j]</tt> sensitivity analysis should be performed.</dd>
<dt><tt class="tt">leftpricei</tt> (output)</dt>
<dd><tt class="tt">leftpricei[i]</tt> is the left shadow price for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">rightpricei</tt> (output)</dt>
<dd><tt class="tt">rightpricei[i]</tt> is the right shadow price for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">leftrangei</tt> (output)</dt>
<dd><tt class="tt">leftrangei[i]</tt> is the left range for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">rightrangei</tt> (output)</dt>
<dd><tt class="tt">rightrangei[i]</tt> is the right range for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">leftpricej</tt> (output)</dt>
<dd><tt class="tt">leftpricej[j]</tt> is the left shadow price for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt>.</dd>
<dt><tt class="tt">rightpricej</tt> (output)</dt>
<dd><tt class="tt">rightpricej[j]</tt> is the right shadow price for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt> .</dd>
<dt><tt class="tt">leftrangej</tt> (output)</dt>
<dd><tt class="tt">leftrangej[j]</tt> is the left range for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt>.</dd>
<dt><tt class="tt">rightrangej</tt> (output)</dt>
<dd><tt class="tt">rightrangej[j]</tt> is the right range for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Calculates sensitivity information for bounds on variables and constraints.</p>

<p>For details on sensitivity analysis and the definitions of <em>shadow price</em> and <em>linearity interval</em> see chapter <a title="12. Sensitivity analysis" href="node014.html#chap-sensitivity-analysis">12</a>.</p>

<p>The constraints for which sensitivity analysis is performed are given by the data structures:</p>

<ol class="enumerate">
<li><tt class="tt">subi</tt> Index of constraint to analyze.</li>
<li><tt class="tt">marki</tt> Indicate for which bound of constraint <tt class="tt">subi[i]</tt> sensitivity analysis is performed. If <tt class="tt">marki[i] = <a href="node020.html#common-const*mosek*mark*up"><tt class="tt">mosek.mark.up</tt></a></tt> the upper bound of constraint <tt class="tt">subi[i]</tt> is analyzed, and if <tt class="tt">marki[i] = <a href="node020.html#common-const*mosek*mark*lo"><tt class="tt">mosek.mark.lo</tt></a></tt> the lower bound is analyzed. If <tt class="tt">subi[i]</tt> is an equality constraint, either <tt class="tt"><a href="node020.html#common-const*mosek*mark*lo"><tt class="tt">mosek.mark.lo</tt></a></tt> or <tt class="tt"><a href="node020.html#common-const*mosek*mark*up"><tt class="tt">mosek.mark.up</tt></a></tt> can be used to select the constraint for sensitivity analysis. </li>
</ol>

<p> Consider the problem:</p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math798.png" alt="\begin{math}\nonumber{}\begin{array}{lccl}\nonumber{}\mbox{minimize} & x_{1}+x_{2} &  & \\\nonumber{}\mbox{subject to}-1\leq{} & x_{1}-x_{2} & \leq{} & 1,\\\nonumber{} & x_{1} & = & 0,\\\nonumber{} & x_{1}\geq{}0,x_{2}\geq{}0 &  &\end{array}\end{math}"/></td>
<td>(15.9.24)</td></tr>
</tbody>
</table>

<p> Suppose that </p>

<pre class="verbatim">                    numi = 1;
                    subi = [0];
                    marki = [mosek.mark.up]                    
                    </pre>

<p> then</p>

<p><tt class="tt">leftpricei[0]</tt>, <tt class="tt">rightpricei[0]</tt>, <tt class="tt">leftrangei[0]</tt> and <tt class="tt">rightrangei[0]</tt> will contain the sensitivity information for the upper bound on constraint <span class="math"><span class="mn">0</span></span> given by the expression: </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math799.png" alt="\begin{math}\nonumber{}x_{1}-x_{2}\leq{}1\end{math}"/></td>
<td>(15.9.25)</td></tr>
</tbody>
</table>

<p> Similarly, the variables for which to perform sensitivity analysis are given by the structures: </p>

<ol class="enumerate">
<li><tt class="tt">subj</tt> Index of variables to analyze. </li>
<li><tt class="tt">markj</tt> Indicate for which bound of variable <tt class="tt">subi[j]</tt> sensitivity analysis is performed. If <tt class="tt">markj[j] = <a href="node020.html#common-const*mosek*mark*up"><tt class="tt">mosek.mark.up</tt></a></tt> the upper bound of constraint <tt class="tt">subi[j]</tt> is analyzed, and if <tt class="tt">markj[j] = <a href="node020.html#common-const*mosek*mark*lo"><tt class="tt">mosek.mark.lo</tt></a></tt> the lower bound is analyzed. If <tt class="tt">subi[j]</tt> is an equality constraint, either <tt class="tt"><a href="node020.html#common-const*mosek*mark*lo"><tt class="tt">mosek.mark.lo</tt></a></tt> or <tt class="tt"><a href="node020.html#common-const*mosek*mark*up"><tt class="tt">mosek.mark.up</tt></a></tt> can be used to select the constraint for sensitivity analysis. </li>
</ol>

<p> For an example, please see Section <a title="12.5. Sensitivity analysis from the MOSEK API" href="node014.html#chap-sensitivity-sec-apiex">12.5</a>.</p>

<p>The type of sensitivity analysis to be performed (basis or optimal partition) is controlled by the parameter <a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">mosek.iparam.sensitivity_type</tt></a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*dualsensitivity"><tt class="tt">mosek.Task.dualsensitivity</tt></a></dt>
<dd>
<p> Performs sensitivity analysis on objective coefficients.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*sensitivityreport"><tt class="tt">mosek.Task.sensitivityreport</tt></a></dt>
<dd>
<p> Creates a sensitivity report.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">mosek.iparam.sensitivity_type</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity"><tt class="tt">mosek.iparam.log_sensitivity</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity-opt"><tt class="tt">mosek.iparam.log_sensitivity_opt</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.printdata</tt></span>

<p> <a name="func*mosek*task*printdata">&#09;</a><a name="common-func*mosek*task*printdata"></a> <a name="idx-118614496">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void printdata (
    streamtype whichstream,
    int firsti,
    int lasti,
    int firstj,
    int lastj,
    int firstk,
    int lastk,
    int c,
    int qo,
    int a,
    int qc,
    int bc,
    int bx,
    int vartype,
    int cones);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">firsti</tt> (input)</dt>
<dd>Index of first constraint for which data should be printed.</dd>
<dt><tt class="tt">lasti</tt> (input)</dt>
<dd>Index of last constraint plus 1 for which data should be printed.</dd>
<dt><tt class="tt">firstj</tt> (input)</dt>
<dd>Index of first variable for which data should be printed.</dd>
<dt><tt class="tt">lastj</tt> (input)</dt>
<dd>Index of last variable plus 1 for which data should be printed.</dd>
<dt><tt class="tt">firstk</tt> (input)</dt>
<dd>Index of first cone for which data should be printed.</dd>
<dt><tt class="tt">lastk</tt> (input)</dt>
<dd>Index of last cone plus 1 for which data should be printed.</dd>
<dt><tt class="tt">c</tt> (input)</dt>
<dd>If non-zero <span class="math"><span class="mi">c</span></span> is printed.</dd>
<dt><tt class="tt">qo</tt> (input)</dt>
<dd>If non-zero <span class="math"><img src="math/math31.png" alt="[[MathCmd 31]]"/></span> is printed.</dd>
<dt><tt class="tt">a</tt> (input)</dt>
<dd>If non-zero <span class="math"><span class="mi">A</span></span> is printed.</dd>
<dt><tt class="tt">qc</tt> (input)</dt>
<dd>If non-zero <span class="math"><img src="math/math32.png" alt="[[MathCmd 32]]"/></span> is printed for the relevant constraints.</dd>
<dt><tt class="tt">bc</tt> (input)</dt>
<dd>If non-zero the constraints bounds are printed.</dd>
<dt><tt class="tt">bx</tt> (input)</dt>
<dd>If non-zero the variable bounds are printed.</dd>
<dt><tt class="tt">vartype</tt> (input)</dt>
<dd>If non-zero the variable types are printed.</dd>
<dt><tt class="tt">cones</tt> (input)</dt>
<dd>If non-zero the conic data is printed.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints a part of the problem data to a stream. This function is normally used for debugging purposes only, e.g. to verify that the correct data has been inputted.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.probtypetostr</tt></span>

<p> <a name="func*mosek*task*probtypetostr">&#09;</a><a name="common-func*mosek*task*probtypetostr"></a> <a name="idx-118637056">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void probtypetostr (
    problemtype probtype,
    StringBuilder str);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemtype"><tt class="tt">probtype</tt></a> (input)</dt>
<dd>Problem type.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the problem type key <tt class="tt">probtype</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a string containing the name of a problem type given.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.prostatostr</tt></span>

<p> <a name="func*mosek*task*prostatostr">&#09;</a><a name="common-func*mosek*task*prostatostr"></a> <a name="idx-118654592">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void prostatostr (
    prosta prosta,
    StringBuilder str);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (input)</dt>
<dd>Problem status.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the status key <tt class="tt">prosta</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a string containing the name of a problem status given.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putaij</tt></span>

<p> <a name="func*mosek*task*putaij">&#09;</a><a name="common-func*mosek*task*putaij"></a> <a name="idx-118658976">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putaij (
    int i,
    int j,
    double aij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint in which the change should occur.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable in which the change should occur.</dd>
<dt><tt class="tt">aij</tt> (input)</dt>
<dd>New coefficient for <span class="math"><img src="math/math720.png" alt="[[MathCmd 720]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Changes a coefficient in <span class="math"><span class="mi">A</span></span> using the method </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math803.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{i}\mathtt{j}}}=\mathtt{aij}.\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">mosek.Task.putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putaij"><tt class="tt">mosek.Task.putaij</tt></a></dt>
<dd>
<p> Changes a single value in the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">mosek.Task.putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putaijlist</tt></span>

<p> <a name="func*mosek*task*putaijlist">&#09;</a><a name="common-func*mosek*task*putaijlist"></a> <a name="idx-118673776">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putaijlist (
    int[] subi,
    int[] subj,
    double[] valij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">subi</tt> (input)</dt>
<dd>Constraint indexes in which the change should occur.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Variable indexes in which the change should occur.</dd>
<dt><tt class="tt">valij</tt> (input)</dt>
<dd>New coefficient values for <span class="math"><img src="math/math720.png" alt="[[MathCmd 720]]"/></span>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putaijlist (
    int num,
    int[] subi,
    int[] subj,
    double[] valij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of coefficients that should be changed.</dd>
<dt><tt class="tt">subi</tt> (input)</dt>
<dd>Constraint indexes in which the change should occur.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Variable indexes in which the change should occur.</dd>
<dt><tt class="tt">valij</tt> (input)</dt>
<dd>New coefficient values for <span class="math"><img src="math/math720.png" alt="[[MathCmd 720]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Changes one or more coefficients in <span class="math"><span class="mi">A</span></span> using the method </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math806.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{subi[k]},\mathtt{subj[k]}}}=\mathtt{valij[k]},\quad{}k=0,\ldots ,\mathtt{num}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> If the same <span class="math"><img src="math/math720.png" alt="[[MathCmd 720]]"/></span> entry appears multiple times only the last one will be used.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">mosek.Task.putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putaij"><tt class="tt">mosek.Task.putaij</tt></a></dt>
<dd>
<p> Changes a single value in the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">mosek.Task.putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putavec</tt></span>

<p> <a name="func*mosek*task*putavec">&#09;</a><a name="common-func*mosek*task*putavec"></a> <a name="idx-118727816">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putavec (
    accmode accmode,
    int i,
    int[] asub,
    double[] aval);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether to replace a column or a row.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>If <tt class="tt">accmode</tt> equals <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, then <span class="math"><span class="mi">i</span></span> is a constraint index. Otherwise it is a column index.</dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>Index of the <span class="math"><img src="math/math720.png" alt="[[MathCmd 720]]"/></span> values that should be changed.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>New <span class="math"><img src="math/math720.png" alt="[[MathCmd 720]]"/></span> values.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putavec (
    accmode accmode,
    int i,
    int nzi,
    int[] asub,
    double[] aval);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether to replace a column or a row.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>If <tt class="tt">accmode</tt> equals <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, then <span class="math"><span class="mi">i</span></span> is a constraint index. Otherwise it is a column index.</dd>
<dt><tt class="tt">nzi</tt> (input)</dt>
<dd>Number of non-zeros in the vector.</dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>Index of the <span class="math"><img src="math/math720.png" alt="[[MathCmd 720]]"/></span> values that should be changed.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>New <span class="math"><img src="math/math720.png" alt="[[MathCmd 720]]"/></span> values.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all elements in one row or column of <span class="math"><span class="mi">A</span></span>.</p>

<p>Assuming that there are no duplicate subscripts in <tt class="tt">asub</tt>, assignment is performed as follows: </p>

<ul class="itemize">
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, then </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math812.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{i},\mathtt{asub}[k]}}=\mathtt{aval}[k],\quad{}k=0,\ldots ,\mathtt{nzi}-1\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> and all other <span class="math"><img src="math/math813.png" alt="[[MathCmd 813]]"/></span>. </p>
</li>
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a>, then </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math814.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{asub}[k],\mathtt{i}}}=\mathtt{aval}[k],\quad{}k=0,\ldots ,\mathtt{nzi}-1\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> and all other <span class="math"><img src="math/math815.png" alt="[[MathCmd 815]]"/></span>. </p>
</li>
</ul>

<p> If <tt class="tt">asub</tt> contains duplicates, the corresponding coefficients will be added together.</p>

<p>For an explanation of the meaning of <tt class="tt">ptrb</tt> and <tt class="tt">ptre</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">mosek.Task.putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putaij"><tt class="tt">mosek.Task.putaij</tt></a></dt>
<dd>
<p> Changes a single value in the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">mosek.Task.putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putaveclist</tt></span>

<p> <a name="func*mosek*task*putaveclist">&#09;</a><a name="common-func*mosek*task*putaveclist"></a> <a name="idx-120213160">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putaveclist (
    accmode accmode,
    int[] sub,
    int[] ptrb,
    int[] ptre,
    int[] asub,
    double[] aval);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of rows or columns that should be replaced. <tt class="tt">sub</tt> should not contain duplicate values.</dd>
<dt><tt class="tt">ptrb</tt> (input)</dt>
<dd>Array of pointers to the first element in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptrb</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">ptre</tt> (input)</dt>
<dd>Array of pointers to the last element plus one in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptre</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, then <tt class="tt">asub</tt> contains the new variable indexes, otherwise it contains the new constraint indexes.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putaveclist (
    accmode accmode,
    int num,
    int[] sub,
    int[] ptrb,
    int[] ptre,
    int[] asub,
    double[] aval);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of rows or columns of <span class="math"><span class="mi">A</span></span> to replace.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of rows or columns that should be replaced. <tt class="tt">sub</tt> should not contain duplicate values.</dd>
<dt><tt class="tt">ptrb</tt> (input)</dt>
<dd>Array of pointers to the first element in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptrb</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">ptre</tt> (input)</dt>
<dd>Array of pointers to the last element plus one in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptre</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, then <tt class="tt">asub</tt> contains the new variable indexes, otherwise it contains the new constraint indexes.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all elements in a set of rows or columns of <span class="math"><span class="mi">A</span></span>.</p>

<p>The elements are replaced as follows. </p>

<ul class="itemize">
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, then for <span class="math"><img src="math/math816.png" alt="[[MathCmd 816]]"/></span> </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math817.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{sub}[i],\mathtt{asub}[k]}}=\mathtt{aval}[k],\quad{}k=\mathtt{aptrb}[i],\ldots ,\mathtt{aptre}[i]-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a>, then for <span class="math"><img src="math/math816.png" alt="[[MathCmd 816]]"/></span> </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math819.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{asub}[k],\mathtt{sub}[i]}}=\mathtt{aval}[k],\quad{}k=\mathtt{aptrb}[i],\ldots ,\mathtt{aptre}[i]-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
</ul>

<p>  If the same row or column appears multiple times only the last one will be used.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">mosek.Task.putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">mosek.Task.putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putaveclist</tt></span>

<p> <a name="func*mosek*task*putaveclist64">&#09;</a><a name="common-func*mosek*task*putaveclist64"></a> <a name="idx-120280776">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putaveclist (
    accmode accmode,
    int[] sub,
    long[] ptrb,
    long[] ptre,
    int[] asub,
    double[] aval);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of rows or columns that should be replaced. <tt class="tt">sub</tt> should not contain duplicate values.</dd>
<dt><tt class="tt">ptrb</tt> (input)</dt>
<dd>Array of pointers to the first element in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptrb</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">ptre</tt> (input)</dt>
<dd>Array of pointers to the last element plus one in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptre</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, then <tt class="tt">asub</tt> contains the new variable indexes, otherwise it contains the new constraint indexes.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putaveclist (
    accmode accmode,
    int num,
    int[] sub,
    long[] ptrb,
    long[] ptre,
    int[] asub,
    double[] aval);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of rows or columns of <span class="math"><span class="mi">A</span></span> to replace.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of rows or columns that should be replaced. <tt class="tt">sub</tt> should not contain duplicate values.</dd>
<dt><tt class="tt">ptrb</tt> (input)</dt>
<dd>Array of pointers to the first element in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptrb</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">ptre</tt> (input)</dt>
<dd>Array of pointers to the last element plus one in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptre</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, then <tt class="tt">asub</tt> contains the new variable indexes, otherwise it contains the new constraint indexes.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all elements in a set of rows or columns of <span class="math"><span class="mi">A</span></span>.</p>

<p>The elements are replaced as follows. </p>

<ul class="itemize">
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>, then for <span class="math"><img src="math/math816.png" alt="[[MathCmd 816]]"/></span> </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math817.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{sub}[i],\mathtt{asub}[k]}}=\mathtt{aval}[k],\quad{}k=\mathtt{aptrb}[i],\ldots ,\mathtt{aptre}[i]-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a>, then for <span class="math"><img src="math/math816.png" alt="[[MathCmd 816]]"/></span> </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math819.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{asub}[k],\mathtt{sub}[i]}}=\mathtt{aval}[k],\quad{}k=\mathtt{aptrb}[i],\ldots ,\mathtt{aptre}[i]-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
</ul>

<p>  If the same row or column appears multiple times only the last one will be used.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">mosek.Task.putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">mosek.Task.putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putbound</tt></span>

<p> <a name="func*mosek*task*putbound">&#09;</a><a name="common-func*mosek*task*putbound"></a> <a name="idx-120362408">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putbound (
    accmode accmode,
    int i,
    boundkey bk,
    double bl,
    double bu);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether the bound for a constraint or a variable is changed.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (input)</dt>
<dd>New bound key.</dd>
<dt><tt class="tt">bl</tt> (input)</dt>
<dd>New lower bound.</dd>
<dt><tt class="tt">bu</tt> (input)</dt>
<dd>New upper bound.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Changes the bounds for either one constraint or one variable.</p>

<p>If the a bound value specified is numerically larger than <a href="node018.html#common-const*mosek*dparam*data-tol-bound-inf"><tt class="tt">mosek.dparam.data_tol_bound_inf</tt></a> it is considered infinite and the bound key is changed accordingly. If a bound value is numerically larger than <a href="node018.html#common-const*mosek*dparam*data-tol-bound-wrn"><tt class="tt">mosek.dparam.data_tol_bound_wrn</tt></a>, a warning will be displayed, but the bound is inputted as specified.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putboundlist"><tt class="tt">mosek.Task.putboundlist</tt></a></dt>
<dd>
<p> Changes the bounds of constraints or variables.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putboundlist</tt></span>

<p> <a name="func*mosek*task*putboundlist">&#09;</a><a name="common-func*mosek*task*putboundlist"></a> <a name="idx-120391296">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putboundlist (
    accmode accmode,
    int[] sub,
    boundkey[] bk,
    double[] bl,
    double[] bu);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether bounds for constraints (<a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>) or variables (<a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a>) are changed.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Subscripts of the bounds that should be changed.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (input)</dt>
<dd>Constraint or variable index <tt class="tt">sub[t]</tt> is assigned the bound key <tt class="tt">bk[t]</tt>.</dd>
<dt><tt class="tt">bl</tt> (input)</dt>
<dd>Constraint or variable index <tt class="tt">sub[t]</tt> is assigned the lower bound <tt class="tt">bl[t]</tt>.</dd>
<dt><tt class="tt">bu</tt> (input)</dt>
<dd>Constraint or variable index <tt class="tt">sub[t]</tt> is assigned the upper bound <tt class="tt">bu[t]</tt>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putboundlist (
    accmode accmode,
    int num,
    int[] sub,
    boundkey[] bk,
    double[] bl,
    double[] bu);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether bounds for constraints (<a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>) or variables (<a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a>) are changed.</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of bounds that should be changed.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Subscripts of the bounds that should be changed.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (input)</dt>
<dd>Constraint or variable index <tt class="tt">sub[t]</tt> is assigned the bound key <tt class="tt">bk[t]</tt>.</dd>
<dt><tt class="tt">bl</tt> (input)</dt>
<dd>Constraint or variable index <tt class="tt">sub[t]</tt> is assigned the lower bound <tt class="tt">bl[t]</tt>.</dd>
<dt><tt class="tt">bu</tt> (input)</dt>
<dd>Constraint or variable index <tt class="tt">sub[t]</tt> is assigned the upper bound <tt class="tt">bu[t]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Changes the bounds for either some constraints or variables. If multiple bound changes are specified for a constraint or a variable, only the last change takes effect.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putbound"><tt class="tt">mosek.Task.putbound</tt></a></dt>
<dd>
<p> Changes the bound for either one constraint or one variable.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-inf"><tt class="tt">mosek.dparam.data_tol_bound_inf</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-wrn"><tt class="tt">mosek.dparam.data_tol_bound_wrn</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putboundslice</tt></span>

<p> <a name="func*mosek*task*putboundslice">&#09;</a><a name="common-func*mosek*task*putboundslice"></a> <a name="idx-121941600">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putboundslice (
    accmode con,
    int first,
    int last,
    boundkey[] bk,
    double[] bl,
    double[] bu);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">con</tt></a> (input)</dt>
<dd>Defines whether bounds for constraints (<a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a>) or variables (<a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">mosek.accmode.var</tt></a>) are changed.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>First index in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Last index plus 1 in the sequence.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (input)</dt>
<dd>Bound keys.</dd>
<dt><tt class="tt">bl</tt> (input)</dt>
<dd>Values for lower bounds.</dd>
<dt><tt class="tt">bu</tt> (input)</dt>
<dd>Values for upper bounds.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Changes the bounds for a sequence of variables or constraints.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putbound"><tt class="tt">mosek.Task.putbound</tt></a></dt>
<dd>
<p> Changes the bound for either one constraint or one variable.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-inf"><tt class="tt">mosek.dparam.data_tol_bound_inf</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-wrn"><tt class="tt">mosek.dparam.data_tol_bound_wrn</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putcfix</tt></span>

<p> <a name="func*mosek*task*putcfix">&#09;</a><a name="common-func*mosek*task*putcfix"></a> <a name="idx-121978536">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putcfix (double cfix)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">cfix</tt> (input)</dt>
<dd>Fixed term in the objective.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Replaces the fixed term in the objective by a new one.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putcj</tt></span>

<p> <a name="func*mosek*task*putcj">&#09;</a><a name="common-func*mosek*task*putcj"></a> <a name="idx-121967248">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putcj (
    int j,
    double cj);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable for which <span class="math"><span class="mi">c</span></span> should be changed.</dd>
<dt><tt class="tt">cj</tt> (input)</dt>
<dd>New value of <span class="math"><img src="math/math87.png" alt="[[MathCmd 87]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Modifies one coefficient in the linear objective vector <span class="math"><span class="mi">c</span></span>, i.e. </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math825.png" alt="\begin{displaymath}\nonumber{}c_{{\mathtt{j}}}=\mathtt{cj}.\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putclist</tt></span>

<p> <a name="func*mosek*task*putclist">&#09;</a><a name="common-func*mosek*task*putclist"></a> <a name="idx-121996784">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putclist (
    int[] subj,
    double[] val);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Index of variables for which <span class="math"><span class="mi">c</span></span> should be changed.</dd>
<dt><tt class="tt">val</tt> (input)</dt>
<dd>New numerical values for coefficients in <span class="math"><span class="mi">c</span></span> that should be modified.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putclist (
    int num,
    int[] subj,
    double[] val);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of coefficients that should be changed.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Index of variables for which <span class="math"><span class="mi">c</span></span> should be changed.</dd>
<dt><tt class="tt">val</tt> (input)</dt>
<dd>New numerical values for coefficients in <span class="math"><span class="mi">c</span></span> that should be modified.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Modifies elements in the linear term <span class="math"><span class="mi">c</span></span> in the objective using the principle </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math826.png" alt="\begin{displaymath}\nonumber{}c_{{\mathtt{subj[t]}}}=\mathtt{val[t]},\quad{}t=0,\ldots ,\mathtt{num}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> If a variable index is specified multiple times in <tt class="tt">subj</tt> only the last entry is used.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putcone</tt></span>

<p> <a name="func*mosek*task*putcone">&#09;</a><a name="common-func*mosek*task*putcone"></a> <a name="idx-122021576">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putcone (
    int k,
    conetype conetype,
    double conepar,
    int[] submem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the cone.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (input)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (input)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">submem</tt> (input)</dt>
<dd>Variable subscripts of the members in the cone.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putcone (
    int k,
    conetype conetype,
    double conepar,
    int nummem,
    int[] submem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the cone.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (input)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (input)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">nummem</tt> (input)</dt>
<dd>Number of member variables in the cone.</dd>
<dt><tt class="tt">submem</tt> (input)</dt>
<dd>Variable subscripts of the members in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Replaces a conic constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putdouparam</tt></span>

<p> <a name="func*mosek*task*putdouparam">&#09;</a><a name="common-func*mosek*task*putdouparam"></a> <a name="idx-122042848">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putdouparam (
    dparam param,
    double parvalue);
</pre>

<dl class="funcargsdesc">
<dt><a href="node018.html#common-constclass*mosek*dparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a double parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putintparam</tt></span>

<p> <a name="func*mosek*task*putintparam">&#09;</a><a name="common-func*mosek*task*putintparam"></a> <a name="idx-122024448">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putintparam (
    iparam param,
    int parvalue);
</pre>

<dl class="funcargsdesc">
<dt><a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of an integer parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putmaxnumanz</tt></span>

<p> <a name="func*mosek*task*putmaxnumanz">&#09;</a><a name="common-func*mosek*task*putmaxnumanz"></a> <a name="idx-122071952">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putmaxnumanz (int maxnumanz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumanz</tt> (input)</dt>
<dd>New size of the storage reserved for storing <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>MOSEK stores only the non-zero elements in <span class="math"><span class="mi">A</span></span>. Therefore, MOSEK cannot predict how much storage is required to store <span class="math"><span class="mi">A</span></span>. Using this function it is possible to specify the number of non-zeros to preallocate for storing <span class="math"><span class="mi">A</span></span>.</p>

<p>If the number of non-zeros in the problem is known, it is a good idea to set <tt class="tt">maxnumanz</tt> slightly larger than this number, otherwise a rough estimate can be used. In general, if <span class="math"><span class="mi">A</span></span> is inputted in many small chunks, setting this value may speed up the the data input phase.</p>

<p>It is not mandatory to call this function, since MOSEK will reallocate internal structures whenever it is necessary.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node020.html#common-const*mosek*iinfitem*sto-num-a-realloc"><tt class="tt">mosek.iinfitem.sto_num_a_realloc</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putmaxnumanz</tt></span>

<p> <a name="func*mosek*task*putmaxnumanz64">&#09;</a><a name="common-func*mosek*task*putmaxnumanz64"></a> <a name="idx-122084672">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putmaxnumanz (long maxnumanz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumanz</tt> (input)</dt>
<dd>New size of the storage reserved for storing <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The function changes the size of the preallocated storage for linear coefficients.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node020.html#common-const*mosek*iinfitem*sto-num-a-realloc"><tt class="tt">mosek.iinfitem.sto_num_a_realloc</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putmaxnumcon</tt></span>

<p> <a name="func*mosek*task*putmaxnumcon">&#09;</a><a name="common-func*mosek*task*putmaxnumcon"></a> <a name="idx-122102920">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putmaxnumcon (int maxnumcon)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>Number of preallocated constraints in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the number of preallocated constraints in the optimization task. When this number of constraints is reached MOSEK will automatically allocate more space for constraints.</p>

<p>It is never mandatory to call this function, since MOSEK will reallocate any internal structures whenever it is required.</p>

<p>Please note that <tt class="tt">maxnumcon</tt> must be larger than the current number of constraints in the task.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putmaxnumcone</tt></span>

<p> <a name="func*mosek*task*putmaxnumcone">&#09;</a><a name="common-func*mosek*task*putmaxnumcone"></a> <a name="idx-122105440">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putmaxnumcone (int maxnumcone)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumcone</tt> (input)</dt>
<dd>Number of preallocated conic constraints in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the number of preallocated conic constraints in the optimization task. When this number of conic constraints is reached MOSEK will automatically allocate more space for conic constraints.</p>

<p>It is never mandatory to call this function, since MOSEK will reallocate any internal structures whenever it is required.</p>

<p>Please note that <tt class="tt">maxnumcon</tt> must be larger than the current number of constraints in the task.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putmaxnumqnz</tt></span>

<p> <a name="func*mosek*task*putmaxnumqnz">&#09;</a><a name="common-func*mosek*task*putmaxnumqnz"></a> <a name="idx-122119016">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putmaxnumqnz (int maxnumqnz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumqnz</tt> (input)</dt>
<dd>Number of non-zero elements preallocated in quadratic coefficient matrices.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>MOSEK stores only the non-zero elements in <span class="math"><span class="mi">Q</span></span>. Therefore, MOSEK cannot predict how much storage is required to store <span class="math"><span class="mi">Q</span></span>. Using this function it is possible to specify the number non-zeros to preallocate for storing <span class="math"><span class="mi">Q</span></span> (both objective and constraints).</p>

<p>It may be advantageous to reserve more non-zeros for <span class="math"><span class="mi">Q</span></span> than actually needed since it may improve the internal efficiency of MOSEK, however, it is never worthwhile to specify more than the double of the anticipated number of non-zeros in <span class="math"><span class="mi">Q</span></span>.</p>

<p>It is never mandatory to call this function, since its only function is to give a hint of the amount of data to preallocate for efficiency reasons.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putmaxnumqnz</tt></span>

<p> <a name="func*mosek*task*putmaxnumqnz64">&#09;</a><a name="common-func*mosek*task*putmaxnumqnz64"></a> <a name="idx-122063400">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putmaxnumqnz (long maxnumqnz)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumqnz</tt> (input)</dt>
<dd>Number of non-zero elements preallocated in quadratic coefficient matrices.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>MOSEK stores only the non-zero elements in <span class="math"><span class="mi">Q</span></span>. Therefore, MOSEK cannot predict how much storage is required to store <span class="math"><span class="mi">Q</span></span>. Using this function it is possible to specify the number non-zeros to preallocate for storing <span class="math"><span class="mi">Q</span></span> (both objective and constraints).</p>

<p>It may be advantageous to reserve more non-zeros for <span class="math"><span class="mi">Q</span></span> than actually needed since it may improve the internal efficiency of MOSEK, however, it is never worthwhile to specify more than the double of the anticipated number of non-zeros in <span class="math"><span class="mi">Q</span></span>.</p>

<p>It is never mandatory to call this function, since its only function is to give a hint of the amount of data to preallocate for efficiency reasons.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putmaxnumvar</tt></span>

<p> <a name="func*mosek*task*putmaxnumvar">&#09;</a><a name="common-func*mosek*task*putmaxnumvar"></a> <a name="idx-122139712">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putmaxnumvar (int maxnumvar)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>Number of preallocated variables in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the number of preallocated variables in the optimization task. When this number of variables is reached MOSEK will automatically allocate more space for variables.</p>

<p>It is never mandatory to call this function, since its only function is to give a hint of the amount of data to preallocate for efficiency reasons.</p>

<p>Please note that <tt class="tt">maxnumvar</tt> must be larger than the current number of variables in the task.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putnadouparam</tt></span>

<p> <a name="func*mosek*task*putnadouparam">&#09;</a><a name="common-func*mosek*task*putnadouparam"></a> <a name="idx-122139856">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putnadouparam (
    string paramname,
    double parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a named double parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putnaintparam</tt></span>

<p> <a name="func*mosek*task*putnaintparam">&#09;</a><a name="common-func*mosek*task*putnaintparam"></a> <a name="idx-122157392">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putnaintparam (
    string paramname,
    int parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a named integer parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putname</tt></span>

<p> <a name="func*mosek*task*putname">&#09;</a><a name="common-func*mosek*task*putname"></a> <a name="idx-122170544">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putname (
    problemitem whichitem,
    int i,
    string name);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">name</tt> (input)</dt>
<dd>New name to be assigned to the item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Assigns the name defined by <tt class="tt">name</tt> to a problem item (a variable, a constraint or a cone).</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putnastrparam</tt></span>

<p> <a name="func*mosek*task*putnastrparam">&#09;</a><a name="common-func*mosek*task*putnastrparam"></a> <a name="idx-122183408">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putnastrparam (
    string paramname,
    string parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a named string parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putobjname</tt></span>

<p> <a name="func*mosek*task*putobjname">&#09;</a><a name="common-func*mosek*task*putobjname"></a> <a name="idx-123633248">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putobjname (string objname)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">objname</tt> (input)</dt>
<dd>Name of the objective.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Assigns the name given by <tt class="tt">objname</tt> to the objective function.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putobjsense</tt></span>

<p> <a name="func*mosek*task*putobjsense">&#09;</a><a name="common-func*mosek*task*putobjsense"></a> <a name="idx-122149776">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putobjsense (objsense sense)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*objsense"><tt class="tt">sense</tt></a> (input)</dt>
<dd>The objective sense of the task. The values <a href="node020.html#common-const*mosek*objsense*maximize"><tt class="tt">mosek.objsense.maximize</tt></a> and <a href="node020.html#common-const*mosek*objsense*minimize"><tt class="tt">mosek.objsense.minimize</tt></a> means that the the problem is maximized or minimized respectively. The value <a href="node020.html#common-const*mosek*objsense*undefined"><tt class="tt">mosek.objsense.undefined</tt></a> means that the objective sense is taken from the parameter <a href="node018.html#common-const*mosek*iparam*objective-sense"><tt class="tt">mosek.iparam.objective_sense</tt></a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the objective sense of the task.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getobjsense"><tt class="tt">mosek.Task.getobjsense</tt></a></dt>
<dd>
<p> Gets the objective sense.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putparam</tt></span>

<p> <a name="func*mosek*task*putparam">&#09;</a><a name="common-func*mosek*task*putparam"></a> <a name="idx-122057864">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putparam (
    string parname,
    string parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">parname</tt> (input)</dt>
<dd>Parameter name.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks if a <tt class="tt">parname</tt> is valid parameter name. If it is, the parameter is assigned the value specified by <tt class="tt">parvalue</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putqcon</tt></span>

<p> <a name="func*mosek*task*putqcon">&#09;</a><a name="common-func*mosek*task*putqcon"></a> <a name="idx-123669536">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putqcon (
    int[] qcsubk,
    int[] qcsubi,
    int[] qcsubj,
    double[] qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">qcsubk</tt> (input)</dt>
<dd><span class="math"><span class="mi">k</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubi</tt> (input)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (input)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (input)</dt>
<dd>Numerical value for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putqcon (
    int numqcnz,
    int[] qcsubk,
    int[] qcsubi,
    int[] qcsubj,
    double[] qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numqcnz</tt> (input)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubk</tt> (input)</dt>
<dd><span class="math"><span class="mi">k</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubi</tt> (input)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (input)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (input)</dt>
<dd>Numerical value for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all quadratic entries in the constraints. Consider constraints on the form:  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math835.png" alt="\begin{math}\nonumber{}l_{k}^{c}\leq{}\frac{1}{2}\sum _{{i=0}}^{{\mathtt{numvar}-1}}\sum _{{j=0}}^{{\mathtt{numvar}-1}}q_{{ij}}^{k}x_{i}x_{j}+\sum _{{j=0}}^{{\mathtt{numvar}-1}}a_{{kj}}x_{j}\leq{}u_{k}^{c},~k=0,\ldots ,m-1.\end{math}"/></td>
<td>(15.9.26)</td></tr>
</tbody>
</table>

<p>  The function assigns values to <span class="math"><span class="mi">q</span></span> such that:  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math836.png" alt="\begin{math}\nonumber{}q_{{\mathtt{qcsubi[t]},\mathtt{qcsubj[t]}}}^{{\mathtt{qcsubk[t]}}}=\mathtt{qcval[t]},~t=0,\ldots ,\mathtt{numqcnz}-1.\end{math}"/></td>
<td>(15.9.27)</td></tr>
</tbody>
</table>

<p>  and  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math837.png" alt="\begin{math}\nonumber{}q_{{\mathtt{\mathtt{qcsubj[t]},qcsubi[t]}}}^{{\mathtt{qcsubk[t]}}}=\mathtt{qcval[t]},~t=0,\ldots ,\mathtt{numqcnz}-1.\end{math}"/></td>
<td>(15.9.28)</td></tr>
</tbody>
</table>

<p> Values not assigned are set to zero.</p>

<p>Please note that duplicate entries are added together.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putqconk"><tt class="tt">mosek.Task.putqconk</tt></a></dt>
<dd>
<p> Replaces all quadratic terms in a single constraint.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><tt class="tt">mosek.Task.putmaxnumqnz</tt></a></dt>
<dd>
<p> Changes the size of the preallocated storage for quadratic terms.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putqconk</tt></span>

<p> <a name="func*mosek*task*putqconk">&#09;</a><a name="common-func*mosek*task*putqconk"></a> <a name="idx-123719120">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putqconk (
    int k,
    int[] qcsubi,
    int[] qcsubj,
    double[] qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>The constraint in which the new <span class="math"><span class="mi">Q</span></span> elements are inserted.</dd>
<dt><tt class="tt">qcsubi</tt> (input)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (input)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (input)</dt>
<dd>Numerical value for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putqconk (
    int k,
    int numqcnz,
    int[] qcsubi,
    int[] qcsubj,
    double[] qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>The constraint in which the new <span class="math"><span class="mi">Q</span></span> elements are inserted.</dd>
<dt><tt class="tt">numqcnz</tt> (input)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubi</tt> (input)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (input)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (input)</dt>
<dd>Numerical value for <span class="math"><img src="math/math89.png" alt="[[MathCmd 89]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all the quadratic entries in one constraint <span class="math"><span class="mi">k</span></span> of the form: </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math844.png" alt="\begin{math}\nonumber{}l_{k}^{c}\leq{}\frac{1}{2}\sum _{{i=0}}^{{\mathtt{numvar}-1}}\sum _{{j=0}}^{{\mathtt{numvar}-1}}q_{{ij}}^{k}x_{i}x_{j}+\sum _{{j=0}}^{{\mathtt{numvar}-1}}a_{{kj}}x_{j}\leq{}u_{k}^{c}.\end{math}"/></td>
<td>(15.9.29)</td></tr>
</tbody>
</table>

<p>  It is assumed that <span class="math"><img src="math/math32.png" alt="[[MathCmd 32]]"/></span> is symmetric, i.e. <span class="math"><img src="math/math846.png" alt="[[MathCmd 846]]"/></span>, and therefore, only the values of <span class="math"><img src="math/math847.png" alt="[[MathCmd 847]]"/></span> for which <span class="math"><span class="mi">i</span>&ge;<span class="mi">j</span></span> should be inputted to MOSEK. To be precise, MOSEK uses the following procedure  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math848.png" alt="\begin{displaymath}\nonumber{}\begin{array}{ll}\nonumber{}1. & Q^{{k}}=0\\\nonumber{}2. & \mbox{for }t=0\mbox{ to }\mathtt{numqonz}-1\\\nonumber{}3. & \qquad{}q_{{\mathtt{qcsubi[t]},\mathtt{qcsubj[t]}}}^{{k}}=q_{{\mathtt{qcsubi[t]},\mathtt{qcsubj[t]}}}^{{k}}+\mathtt{qcval[t]}\\\nonumber{}3. & \qquad{}q_{{\mathtt{qcsubj[t]},\mathtt{qcsubi[t]}}}^{{k}}=q_{{\mathtt{qcsubj[t]},\mathtt{qcsubi[t]}}}^{{k}}+\mathtt{qcval[t]}\end{array}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>Please note that:  </p>

<ul class="itemize">
<li>For large problems it is essential for the efficiency that the function <a href="node017.html#common-func*mosek*task*putmaxnumqnz64"><tt class="tt">mosek.Task.putmaxnumqnz64</tt></a> is employed to specify an appropriate <tt class="tt">maxnumqnz</tt>.</li>
<li>Only the lower triangular part should be specified because <span class="math"><img src="math/math32.png" alt="[[MathCmd 32]]"/></span> is symmetric. Specifying values for <span class="math"><img src="math/math847.png" alt="[[MathCmd 847]]"/></span> where <span class="math"><span class="mi">i</span><span class="mo">&lt;</span><span class="mi">j</span></span> will result in an error.</li>
<li>Only non-zero elements should be specified.</li>
<li>The order in which the non-zero elements are specified is insignificant. </li>
<li>Duplicate elements are added together. Hence, it is recommended not to specify the same element multiple times in <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>.</li>
</ul>

<p> For a code example see Section <a title="5.3.2. Example: Quadratic constraints" href="node007.html#chap:mosekapi:sec:quadratic_constraint">5.3.2</a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putqcon"><tt class="tt">mosek.Task.putqcon</tt></a></dt>
<dd>
<p> Replaces all quadratic terms in constraints.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><tt class="tt">mosek.Task.putmaxnumqnz</tt></a></dt>
<dd>
<p> Changes the size of the preallocated storage for quadratic terms.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putqobj</tt></span>

<p> <a name="func*mosek*task*putqobj">&#09;</a><a name="common-func*mosek*task*putqobj"></a> <a name="idx-123785160">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putqobj (
    int[] qosubi,
    int[] qosubj,
    double[] qoval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">qosubi</tt> (input)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscript for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
<dt><tt class="tt">qosubj</tt> (input)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscript for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
<dt><tt class="tt">qoval</tt> (input)</dt>
<dd>Numerical value for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putqobj (
    int numqonz,
    int[] qosubi,
    int[] qosubj,
    double[] qoval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">numqonz</tt> (input)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math31.png" alt="[[MathCmd 31]]"/></span>.</dd>
<dt><tt class="tt">qosubi</tt> (input)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscript for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
<dt><tt class="tt">qosubj</tt> (input)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscript for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
<dt><tt class="tt">qoval</tt> (input)</dt>
<dd>Numerical value for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all the quadratic terms in the objective  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math858.png" alt="\begin{math}\nonumber{}\frac{1}{2}\sum \limits _{{i=0}}^{{\mathtt{numvar}-1}}\sum _{{j=0}}^{{\mathtt{numvar}-1}}q_{{ij}}^{o}x_{i}x_{j}+\sum _{{j=0}}^{{\mathtt{numvar}-1}}c_{j}x_{j}+c^{f}.\end{math}"/></td>
<td>(15.9.30)</td></tr>
</tbody>
</table>

<p>  It is assumed that <span class="math"><img src="math/math31.png" alt="[[MathCmd 31]]"/></span> is symmetric, i.e. <span class="math"><img src="math/math860.png" alt="[[MathCmd 860]]"/></span>, and therefore, only the values of <span class="math"><img src="math/math861.png" alt="[[MathCmd 861]]"/></span> for which <span class="math"><span class="mi">i</span>&ge;<span class="mi">j</span></span> should be specified. To be precise, MOSEK uses the following procedure  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math862.png" alt="\begin{displaymath}\nonumber{}\begin{array}{ll}\nonumber{}1. & Q^{o}=0\\\nonumber{}2. & \mbox{for }t=0\mbox{ to }\mathtt{numqonz}-1\\\nonumber{}3. & \qquad{}q_{{\mathtt{qosubi[t]},\mathtt{qosubj[t]}}}^{{o}}=q_{{\mathtt{qosubi[t]},\mathtt{qosubj[t]}}}^{{o}}+\mathtt{qoval[t]}\\\nonumber{}3. & \qquad{}q_{{\mathtt{qosubj[t]},\mathtt{qosubi[t]}}}^{{o}}=q_{{\mathtt{qosubj[t]},\mathtt{qosubi[t]}}}^{{o}}+\mathtt{qoval[t]}\end{array}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> Please note that:  </p>

<ul class="itemize">
<li>Only the lower triangular part should be specified because <span class="math"><img src="math/math31.png" alt="[[MathCmd 31]]"/></span> is symmetric. Specifying values for <span class="math"><img src="math/math861.png" alt="[[MathCmd 861]]"/></span> where <span class="math"><span class="mi">i</span><span class="mo">&lt;</span><span class="mi">j</span></span> will result in an error.</li>
<li>Only non-zero elements should be specified.</li>
<li>The order in which the non-zero elements are specified is insignificant.</li>
<li>Duplicate entries are added to together. </li>
</ul>

<p> For a code example see Section <a title="5.3.1. Example: Quadratic objective" href="node007.html#chap:mosekapi:sec:quadratic_objective">5.3.1</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putqobjij</tt></span>

<p> <a name="func*mosek*task*putqobjij">&#09;</a><a name="common-func*mosek*task*putqobjij"></a> <a name="idx-123833520">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putqobjij (
    int i,
    int j,
    double qoij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Row index for the coefficient to be replaced.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Column index for the coefficient to be replaced.</dd>
<dt><tt class="tt">qoij</tt> (input)</dt>
<dd>The new value for <span class="math"><img src="math/math83.png" alt="[[MathCmd 83]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces one coefficient in the quadratic term in the objective. The function performs the assignment  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math866.png" alt="\begin{displaymath}\nonumber{}q_{{\mathtt{i}\mathtt{j}}}^{o}=\mathtt{qoij}.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Only the elements in the lower triangular part are accepted. Setting <span class="math"><img src="math/math867.png" alt="[[MathCmd 867]]"/></span> with <span class="math"><span class="mi">j</span><span class="mo">&gt;</span><span class="mi">i</span></span> will cause an error.</p>

<p>Please note that replacing all quadratic element, one at a time, is more computationally expensive than replacing all elements at once. Use <a href="node017.html#common-func*mosek*task*putqobj"><tt class="tt">mosek.Task.putqobj</tt></a> instead whenever possible.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putsolution</tt></span>

<p> <a name="func*mosek*task*putsolution">&#09;</a><a name="common-func*mosek*task*putsolution"></a> <a name="idx-123848968">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putsolution (
    soltype whichsol,
    stakey[] skc,
    stakey[] skx,
    stakey[] skn,
    double[] xc,
    double[] xx,
    double[] y,
    double[] slc,
    double[] suc,
    double[] slx,
    double[] sux,
    double[] snx);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skc</tt></a> (input)</dt>
<dd>Status keys for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skx</tt></a> (input)</dt>
<dd>Status keys for the variables.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skn</tt></a> (input)</dt>
<dd>Status keys for the conic constraints.</dd>
<dt><tt class="tt">xc</tt> (input)</dt>
<dd>Primal constraint solution.</dd>
<dt><tt class="tt">xx</tt> (input)</dt>
<dd>Primal variable solution (<span class="math"><span class="mi">x</span></span>).</dd>
<dt><tt class="tt">y</tt> (input)</dt>
<dd>Vector of dual variables corresponding to the constraints.</dd>
<dt><tt class="tt">slc</tt> (input)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (<span class="math"><img src="math/math760.png" alt="[[MathCmd 760]]"/></span>).</dd>
<dt><tt class="tt">suc</tt> (input)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (<span class="math"><img src="math/math761.png" alt="[[MathCmd 761]]"/></span>).</dd>
<dt><tt class="tt">slx</tt> (input)</dt>
<dd>Dual variables corresponding to the lower bounds on the variables (<span class="math"><img src="math/math762.png" alt="[[MathCmd 762]]"/></span>).</dd>
<dt><tt class="tt">sux</tt> (input)</dt>
<dd>Dual variables corresponding to the upper bounds on the variables (appears as <span class="math"><img src="math/math763.png" alt="[[MathCmd 763]]"/></span>).</dd>
<dt><tt class="tt">snx</tt> (input)</dt>
<dd>Dual variables corresponding to the conic constraints on the variables (<span class="math"><img src="math/math764.png" alt="[[MathCmd 764]]"/></span>).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Inserts a solution into the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putsolutioni</tt></span>

<p> <a name="func*mosek*task*putsolutioni">&#09;</a><a name="common-func*mosek*task*putsolutioni"></a> <a name="idx-125434264">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putsolutioni (
    accmode accmode,
    int i,
    soltype whichsol,
    stakey sk,
    double x,
    double sl,
    double su,
    double sn);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">mosek.accmode.con</tt></a> the solution information for a constraint is modified. Otherwise for a variable.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">sk</tt></a> (input)</dt>
<dd>Status key of the constraint or variable.</dd>
<dt><tt class="tt">x</tt> (input)</dt>
<dd>Solution value of the primal constraint or variable.</dd>
<dt><tt class="tt">sl</tt> (input)</dt>
<dd>Solution value of the dual variable associated with the lower bound.</dd>
<dt><tt class="tt">su</tt> (input)</dt>
<dd>Solution value of the dual variable associated with the upper bound.</dd>
<dt><tt class="tt">sn</tt> (input)</dt>
<dd>Solution value of the dual variable associated with the cone constraint.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the primal and dual solution information for a single constraint or variable.</p>

<p>To define a solution or a significant part of a solution, first call the <a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><tt class="tt">mosek.Task.makesolutionstatusunknown</tt></a> function, then for each relevant constraint and variable call <a href="node017.html#common-func*mosek*task*putsolutioni"><tt class="tt">mosek.Task.putsolutioni</tt></a> to set the solution information.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><tt class="tt">mosek.Task.makesolutionstatusunknown</tt></a></dt>
<dd>
<p> Sets the solution status to unknown.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putsolutionyi</tt></span>

<p> <a name="func*mosek*task*putsolutionyi">&#09;</a><a name="common-func*mosek*task*putsolutionyi"></a> <a name="idx-123864848">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putsolutionyi (
    int i,
    soltype whichsol,
    double y);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the dual variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">y</tt> (input)</dt>
<dd>Solution value of the dual variable.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Inputs the dual variable of a solution.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><tt class="tt">mosek.Task.makesolutionstatusunknown</tt></a></dt>
<dd>
<p> Sets the solution status to unknown.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putsolutioni"><tt class="tt">mosek.Task.putsolutioni</tt></a></dt>
<dd>
<p> Sets the primal and dual solution information for a single constraint or variable.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putstrparam</tt></span>

<p> <a name="func*mosek*task*putstrparam">&#09;</a><a name="common-func*mosek*task*putstrparam"></a> <a name="idx-125465376">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putstrparam (
    sparam param,
    string parvalue);
</pre>

<dl class="funcargsdesc">
<dt><a href="node018.html#common-constclass*mosek*sparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a string parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.puttaskname</tt></span>

<p> <a name="func*mosek*task*puttaskname">&#09;</a><a name="common-func*mosek*task*puttaskname"></a> <a name="idx-125486864">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void puttaskname (string taskname)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">taskname</tt> (input)</dt>
<dd>Name assigned to the task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Assigns the name <tt class="tt">taskname</tt> to the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putvarbranchorder</tt></span>

<p> <a name="func*mosek*task*putvarbranchorder">&#09;</a><a name="common-func*mosek*task*putvarbranchorder"></a> <a name="idx-125495704">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putvarbranchorder (
    int j,
    int priority,
    int direction);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><tt class="tt">priority</tt> (input)</dt>
<dd>The branching priority that should be assigned to variable <span class="math"><span class="mi">j</span></span>.</dd>
<dt><a href="node020.html#common-constclass*mosek*branchdir"><tt class="tt">direction</tt></a> (input)</dt>
<dd>Specifies the preferred branching direction for variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The purpose of the function is to assign a branching priority and direction. The higher priority that is assigned to an integer variable the earlier the mixed integer optimizer will branch on the variable. The branching direction controls if the optimizer branches up or down on the variable.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putvartype</tt></span>

<p> <a name="func*mosek*task*putvartype">&#09;</a><a name="common-func*mosek*task*putvartype"></a> <a name="idx-125505336">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putvartype (
    int j,
    variabletype vartype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*variabletype"><tt class="tt">vartype</tt></a> (input)</dt>
<dd>The new variable type.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the variable type of one variable.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putvartypelist"><tt class="tt">mosek.Task.putvartypelist</tt></a></dt>
<dd>
<p> Sets the variable type for one or more variables.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.putvartypelist</tt></span>

<p> <a name="func*mosek*task*putvartypelist">&#09;</a><a name="common-func*mosek*task*putvartypelist"></a> <a name="idx-125501520">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putvartypelist (
    int[] subj,
    variabletype[] vartype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>A list of variable indexes for which the variable type should be changed.</dd>
<dt><a href="node020.html#common-constclass*mosek*variabletype"><tt class="tt">vartype</tt></a> (input)</dt>
<dd>A list of variable types that should be assigned to the variables specified by <tt class="tt">subj</tt>. See section <a title="18.55. Variable types" href="node020.html#constclass*mosek*variabletype">18.55</a> for the possible values of <tt class="tt">vartype</tt>.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void putvartypelist (
    int num,
    int[] subj,
    variabletype[] vartype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of variables for which the variable type should be set.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>A list of variable indexes for which the variable type should be changed.</dd>
<dt><a href="node020.html#common-constclass*mosek*variabletype"><tt class="tt">vartype</tt></a> (input)</dt>
<dd>A list of variable types that should be assigned to the variables specified by <tt class="tt">subj</tt>. See section <a title="18.55. Variable types" href="node020.html#constclass*mosek*variabletype">18.55</a> for the possible values of <tt class="tt">vartype</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the variable type for one or more variables, i.e. variable number <span class="math"><img src="math/math873.png" alt="[[MathCmd 873]]"/></span> is assigned the variable type <span class="math"><img src="math/math874.png" alt="[[MathCmd 874]]"/></span>.</p>

<p>If the same index is specified multiple times in <tt class="tt">subj</tt> only the last entry takes effect.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putvartype"><tt class="tt">mosek.Task.putvartype</tt></a></dt>
<dd>
<p> Sets the variable type of one variable.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.readbranchpriorities</tt></span>

<p> <a name="func*mosek*task*readbranchpriorities">&#09;</a><a name="common-func*mosek*task*readbranchpriorities"></a> <a name="idx-125555992">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void readbranchpriorities (string filename)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Data is read from the file <tt class="tt">filename</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Reads branching priority data from a file.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*writebranchpriorities"><tt class="tt">mosek.Task.writebranchpriorities</tt></a></dt>
<dd>
<p> Writes branching priority data to a file.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.readdata</tt></span>

<p> <a name="func*mosek*task*readdata">&#09;</a><a name="common-func*mosek*task*readdata"></a> <a name="idx-125540616">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void readdata (string filename)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Data is read from the file <tt class="tt">filename</tt> if it is a nonempty string. Otherwise data is read from the file specified by <a href="node018.html#common-const*mosek*sparam*data-file-name"><tt class="tt">mosek.sparam.data_file_name</tt></a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Reads an optimization data and associated data from a file.</p>

<p>The data file format is determined by the <a href="node018.html#common-const*mosek*iparam*read-data-format"><tt class="tt">mosek.iparam.read_data_format</tt></a> parameter. By default the parameter has the value <a href="node020.html#common-const*mosek*dataformat*extension"><tt class="tt">mosek.dataformat.extension</tt></a> indicating that the extension of the input file should determine the file type, where the extension is interpreted as follows:</p>

<ul class="itemize">
<li>"<tt class="tt">.lp</tt>" and "<tt class="tt">.lp.gz</tt>" are interpreted as an LP file and a compressed LP file respectively. </li>
<li>"<tt class="tt">.opf</tt>" and "<tt class="tt">.opf.gz</tt>" are interpreted as an OPF file and a compressed OPF file respectively. </li>
<li>"<tt class="tt">.mps</tt>" and "<tt class="tt">.mps.gz</tt>" are interpreted as an MPS file and a compressed MPS file respectively. </li>
<li>"<tt class="tt">.mbt</tt>" and "<tt class="tt">.mbt.gz</tt>" are interpreted as an MBT file and a compressed MBT file respectively. </li>
</ul>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*writedata"><tt class="tt">mosek.Task.writedata</tt></a></dt>
<dd>
<p> Writes problem data to a file.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*read-data-format"><tt class="tt">mosek.iparam.read_data_format</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.readparamfile</tt></span>

<p> <a name="func*mosek*task*readparamfile">&#09;</a><a name="common-func*mosek*task*readparamfile"></a> <a name="idx-125615856">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void readparamfile ()
</pre>
</dd>
<dt>Description:</dt>
<dd>Reads a parameter file.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.readsolution</tt></span>

<p> <a name="func*mosek*task*readsolution">&#09;</a><a name="common-func*mosek*task*readsolution"></a> <a name="idx-125616928">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void readsolution (
    soltype whichsol,
    string filename);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>A valid file name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Reads a solution file and inserts the solution into the solution <tt class="tt">whichsol</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.readsummary</tt></span>

<p> <a name="func*mosek*task*readsummary">&#09;</a><a name="common-func*mosek*task*readsummary"></a> <a name="idx-125638488">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void readsummary (streamtype whichstream)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints a short summary of last file that was read.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.relaxprimal</tt></span>

<p> <a name="func*mosek*task*relaxprimal">&#09;</a><a name="common-func*mosek*task*relaxprimal"></a> <a name="idx-125647976">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Task relaxprimal (
    double[] wlc,
    double[] wuc,
    double[] wlx,
    double[] wux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">wlc</tt> (input/output)</dt>
<dd>Weights associated with lower bounds on the activity of constraints. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math875.png" alt="[[MathCmd 875]]"/></span>, then <span class="math"><img src="math/math537.png" alt="[[MathCmd 537]]"/></span> is fixed to zero. On return <tt class="tt">wlc[i]</tt> contains the relaxed bound.</dd>
<dt><tt class="tt">wuc</tt> (input/output)</dt>
<dd>Weights associated with upper bounds on the activity of constraints. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math877.png" alt="[[MathCmd 877]]"/></span>, then <span class="math"><img src="math/math538.png" alt="[[MathCmd 538]]"/></span> is fixed to zero. On return <tt class="tt">wuc[i]</tt> contains the relaxed bound.</dd>
<dt><tt class="tt">wlx</tt> (input/output)</dt>
<dd>Weights associated with lower bounds on the activity of variables. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math879.png" alt="[[MathCmd 879]]"/></span> then <span class="math"><img src="math/math880.png" alt="[[MathCmd 880]]"/></span> is fixed to zero. On return <tt class="tt">wlx[i]</tt> contains the relaxed bound.</dd>
<dt><tt class="tt">wux</tt> (input/output)</dt>
<dd>Weights associated with upper bounds on the activity of variables. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math881.png" alt="[[MathCmd 881]]"/></span> then <span class="math"><img src="math/math882.png" alt="[[MathCmd 882]]"/></span> is fixed to zero. On return <tt class="tt">wux[i]</tt> contains the relaxed bound.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void relaxprimal (
    out Task relaxedtask,
    double[] wlc,
    double[] wuc,
    double[] wlx,
    double[] wux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">relaxedtask</tt> (output)</dt>
<dd>The returned task.</dd>
<dt><tt class="tt">wlc</tt> (input/output)</dt>
<dd>Weights associated with lower bounds on the activity of constraints. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math875.png" alt="[[MathCmd 875]]"/></span>, then <span class="math"><img src="math/math537.png" alt="[[MathCmd 537]]"/></span> is fixed to zero. On return <tt class="tt">wlc[i]</tt> contains the relaxed bound.</dd>
<dt><tt class="tt">wuc</tt> (input/output)</dt>
<dd>Weights associated with upper bounds on the activity of constraints. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math877.png" alt="[[MathCmd 877]]"/></span>, then <span class="math"><img src="math/math538.png" alt="[[MathCmd 538]]"/></span> is fixed to zero. On return <tt class="tt">wuc[i]</tt> contains the relaxed bound.</dd>
<dt><tt class="tt">wlx</tt> (input/output)</dt>
<dd>Weights associated with lower bounds on the activity of variables. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math879.png" alt="[[MathCmd 879]]"/></span> then <span class="math"><img src="math/math880.png" alt="[[MathCmd 880]]"/></span> is fixed to zero. On return <tt class="tt">wlx[i]</tt> contains the relaxed bound.</dd>
<dt><tt class="tt">wux</tt> (input/output)</dt>
<dd>Weights associated with upper bounds on the activity of variables. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math881.png" alt="[[MathCmd 881]]"/></span> then <span class="math"><img src="math/math882.png" alt="[[MathCmd 882]]"/></span> is fixed to zero. On return <tt class="tt">wux[i]</tt> contains the relaxed bound.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Creates a problem that computes the minimal (weighted) relaxation of the bounds that will make an infeasible problem feasible.</p>

<p>Given an existing task describing the problem  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math891.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x & \leq{} & u^{x},\end{array}\end{math}"/></td>
<td>(15.9.31)</td></tr>
</tbody>
</table>

<p>  the function forms a new task <tt class="tt">relaxedtask</tt> having the form  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math892.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & p &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax+v_{l}^{c}-v_{u}^{c} & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x+v_{l}^{x}-v_{u}^{x} & \leq{} & u^{x},\\\nonumber{} &  &  & (w_{l}^{c})^{T}v_{l}^{c}+(w_{u}^{c})^{T}v_{u}^{c}+(w_{l}^{x})^{T}v_{l}^{x}+(w_{u}^{x})^{T}v_{u}^{x}-p & \leq{} & 0,\\\nonumber{} &  &  & v_{l}^{c},v_{u}^{c},v_{l}^{x},v_{u}^{x}\geq{}0. &  &\end{array}\end{math}"/></td>
<td><a name="ais-eq-feasrepair1">&#09;</a>(15.9.32)</td></tr>
</tbody>
</table>

<p>  Hence, the function adds so-called elasticity variables to all the constraints which relax the constraints, for instance <span class="math"><img src="math/math537.png" alt="[[MathCmd 537]]"/></span> and <span class="math"><img src="math/math538.png" alt="[[MathCmd 538]]"/></span> relax <span class="math"><img src="math/math542.png" alt="[[MathCmd 542]]"/></span> and <span class="math"><img src="math/math896.png" alt="[[MathCmd 896]]"/></span> respectively. It should be obvious that (<a href="node017.html#ais-eq-feasrepair1">15.9.32</a>) is feasible. Moreover, the function adds the constraint  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math897.png" alt="\begin{displaymath}\nonumber{}(w_{l}^{c})^{T}v_{l}^{c}+(w_{u}^{c})^{T}v_{u}^{c}+(w_{l}^{x})^{T}v_{l}^{x}+(w_{u}^{x})^{T}v_{u}^{x}-p\leq{}0\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  to the problem which makes the variable <span class="math"><span class="mi">p</span></span> bigger than the total weighted sum of the relaxation to the bounds. <span class="math"><img src="math/math546.png" alt="[[MathCmd 546]]"/></span>, <span class="math"><img src="math/math547.png" alt="[[MathCmd 547]]"/></span>, <span class="math"><img src="math/math548.png" alt="[[MathCmd 548]]"/></span> and <span class="math"><img src="math/math549.png" alt="[[MathCmd 549]]"/></span> are user-defined weights which normally should be nonnegative. If a weight is negative, then the corresponding elasticity variable is fixed to zero.</p>

<p>Hence, when the problem (<a href="node017.html#ais-eq-feasrepair1">15.9.32</a>) is optimized, the weighted minimal change to the bounds such that the problem is feasible is computed.</p>

<p>One can specify that a bound should be strictly enforced by assigning a negative value to the corresponding weight, i.e if <span class="math"><img src="math/math875.png" alt="[[MathCmd 875]]"/></span> then <span class="math"><img src="math/math537.png" alt="[[MathCmd 537]]"/></span> is fixed to zero.</p>

<p>Now let <span class="math"><img src="math/math552.png" alt="[[MathCmd 552]]"/></span> be the optimal objective value to (<a href="node017.html#ais-eq-feasrepair1">15.9.32</a>), then a natural thing to do is to solve the optimization problem  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math905.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax+v_{l}^{c}-v_{u}^{c} & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x+v_{l}^{x}-v_{u}^{x} & \leq{} & u^{x},\\\nonumber{} &  &  & (w_{l}^{c})^{T}v_{l}^{c}+(w_{u}^{c})^{T}v_{u}^{c}+(w_{l}^{x})^{T}v_{l}^{x}+(w_{u}^{x})^{T}v_{u}^{x}-p & \leq{} & 0,\\\nonumber{} &  &  & p & = & p^{*},\\\nonumber{} &  &  & v_{l}^{c},v_{u}^{c},v_{l}^{x},v_{u}^{x}\geq{}0, &  &\end{array}\end{math}"/></td>
<td><a name="ais-eq-feasrepair2">&#09;</a>(15.9.33)</td></tr>
</tbody>
</table>

<p>  where the original objective function is minimized subject to the constraint that the total weighted relaxation is minimal.</p>

<p>The parameter <a href="node018.html#common-const*mosek*iparam*feasrepair-optimize"><tt class="tt">mosek.iparam.feasrepair_optimize</tt></a> controls whether the function returns the problem (<a href="node017.html#ais-eq-feasrepair1">15.9.32</a>) or the problem (<a href="node017.html#ais-eq-feasrepair2">15.9.33</a>).The parameter can take one of the following values.  </p>

<dl class="description">
<dt><a href="node020.html#common-const*mosek*feasrepairtype*optimize-none"><tt class="tt">mosek.feasrepairtype.optimize_none</tt></a></dt>
<dd>
<p>: The returned task <tt class="tt">relaxedtask</tt> contains problem (<a href="node017.html#ais-eq-feasrepair1">15.9.32</a>) and is not optimized.</p>
</dd>
<dt><a href="node020.html#common-const*mosek*feasrepairtype*optimize-penalty"><tt class="tt">mosek.feasrepairtype.optimize_penalty</tt></a></dt>
<dd>
<p>: The returned task <tt class="tt">relaxedtask</tt> contains problem (<a href="node017.html#ais-eq-feasrepair1">15.9.32</a>) and is optimized.</p>
</dd>
<dt><a href="node020.html#common-const*mosek*feasrepairtype*optimize-combined"><tt class="tt">mosek.feasrepairtype.optimize_combined</tt></a></dt>
<dd>
<p>: The returned task <tt class="tt">relaxedtask</tt> contains problem (<a href="node017.html#ais-eq-feasrepair2">15.9.33</a>) and is optimized. </p>
</dd>
</dl>

<p>  Please note that the <span class="math"><span class="mi">v</span></span> variables are appended to the <span class="math"><span class="mi">x</span></span> variables ordered as </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math906.png" alt="\begin{displaymath}\nonumber{}(v_{u}^{c})_{1},(v_{l}^{c})_{1},(v_{u}^{c})_{2},(v_{l}^{c})_{2},\ldots ,(v_{u}^{c})_{m},(v_{l}^{c})_{m},\quad{}(v_{u}^{x})_{1},(v_{l}^{x})_{1},(v_{u}^{x})_{2},(v_{l}^{x})_{2},\ldots ,(v_{u}^{x})_{n},(v_{l}^{x})_{n}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> in the returned task.</p>

<p>If <tt class="tt">NAME_CON</tt> (<tt class="tt">NAME_VAR</tt>) is the name of the <span class="math"><span class="mi">i</span></span>th constraint (variable) then the new variables are named as follows: </p>

<ul class="itemize">
<li>The variable corresponding to <span class="math"><img src="math/math538.png" alt="[[MathCmd 538]]"/></span> (<span class="math"><img src="math/math908.png" alt="[[MathCmd 908]]"/></span>) is named &#8220;<tt class="tt">NAME_CON*up</tt>&#8221; (&#8220;<tt class="tt">NAME_VAR*up</tt>&#8221;).</li>
<li>The variable corresponding to <span class="math"><img src="math/math537.png" alt="[[MathCmd 537]]"/></span> (<span class="math"><img src="math/math539.png" alt="[[MathCmd 539]]"/></span>) is named &#8220;<tt class="tt">NAME_CON*lo</tt>&#8221; (&#8220;<tt class="tt">NAME_VAR*lo</tt>&#8221;). </li>
</ul>

<p> where &#8220;<tt class="tt">*</tt>&#8221; can be replaced by a user-defined string by setting the <a href="node018.html#common-const*mosek*sparam*feasrepair-name-separator"><tt class="tt">mosek.sparam.feasrepair_name_separator</tt></a> parameter.</p>

<p>Please note that if <span class="math"><img src="math/math911.png" alt="[[MathCmd 911]]"/></span> or <span class="math"><img src="math/math912.png" alt="[[MathCmd 912]]"/></span> then the feasibility repair problem becomes infeasible. Such trivial conflicts must therefore be removed manually before using <a href="node017.html#common-func*mosek*task*relaxprimal"><tt class="tt">mosek.Task.relaxprimal</tt></a>.</p>

<p>The above discussion shows how the function works for a linear optimization problem. However, the function also works for quadratic and conic optimization problems but it cannot be used for general nonlinear optimization problems.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node018.html#common-const*mosek*dparam*feasrepair-tol"><tt class="tt">mosek.dparam.feasrepair_tol</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*feasrepair-optimize"><tt class="tt">mosek.iparam.feasrepair_optimize</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*sparam*feasrepair-name-separator"><tt class="tt">mosek.sparam.feasrepair_name_separator</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*sparam*feasrepair-name-prefix"><tt class="tt">mosek.sparam.feasrepair_name_prefix</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.remove</tt></span>

<p> <a name="func*mosek*task*remove">&#09;</a><a name="common-func*mosek*task*remove"></a> <a name="idx-127028472">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void remove (
    accmode accmode,
    int[] sub);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of constraints or variables which should be removed.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void remove (
    accmode accmode,
    int num,
    int[] sub);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of constraints or variables which should be removed.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of constraints or variables which should be removed.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The function removes a number of constraints or variables from the optimization task. This implies that the existing constraints and variables are renumbered, for instance if constraint 5 is removed then constraint 6 becomes constraint 5 and so forth.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*append"><tt class="tt">mosek.Task.append</tt></a></dt>
<dd>
<p> Appends a number of variables or constraints to the optimization task.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.removecone</tt></span>

<p> <a name="func*mosek*task*removecone">&#09;</a><a name="common-func*mosek*task*removecone"></a> <a name="idx-127048016">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void removecone (int k)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the conic constraint that should be removed.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Removes a conic constraint from the problem. This implies that all the conic constraints appearing after cone number <tt class="tt">k</tt> are renumbered, decresing their indexes by one.</p>

<p>In general, it is much more efficient to remove a cone with a high index than a low index.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.resizetask</tt></span>

<p> <a name="func*mosek*task*resizetask">&#09;</a><a name="common-func*mosek*task*resizetask"></a> <a name="idx-127064544">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void resizetask (
    int maxnumcon,
    int maxnumvar,
    int maxnumcone,
    int maxnumanz,
    int maxnumqnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>New maximum number of constraints.</dd>
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>New maximum number of variables.</dd>
<dt><tt class="tt">maxnumcone</tt> (input)</dt>
<dd>New maximum number of cones.</dd>
<dt><tt class="tt">maxnumanz</tt> (input)</dt>
<dd>New maximum number of non-zeros in <span class="math"><span class="mi">A</span></span>.</dd>
<dt><tt class="tt">maxnumqnz</tt> (input)</dt>
<dd>New maximum number of non-zeros in all <span class="math"><span class="mi">Q</span></span> matrices.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the amount of preallocated space assigned for each type of data in an optimization task.</p>

<p>It is never mandatory to call this function, since its only function is to give a hint of the amount of data to preallocate for efficiency reasons.</p>

<p>Please note that the procedure is <b>destructive</b> in the sense that all existing data stored in the task is destroyed.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putmaxnumvar"><tt class="tt">mosek.Task.putmaxnumvar</tt></a></dt>
<dd>
<p> Sets the number of preallocated variables in the optimization task.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumcon"><tt class="tt">mosek.Task.putmaxnumcon</tt></a></dt>
<dd>
<p> Sets the number of preallocated constraints in the optimization task.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumcone"><tt class="tt">mosek.Task.putmaxnumcone</tt></a></dt>
<dd>
<p> Sets the number of preallocated conic constraints in the optimization task.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">mosek.Task.putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><tt class="tt">mosek.Task.putmaxnumqnz</tt></a></dt>
<dd>
<p> Changes the size of the preallocated storage for quadratic terms.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.sensitivityreport</tt></span>

<p> <a name="func*mosek*task*sensitivityreport">&#09;</a><a name="common-func*mosek*task*sensitivityreport"></a> <a name="idx-127083944">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void sensitivityreport (streamtype whichstream)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Reads a sensitivity format file from a location given by <a href="node018.html#common-const*mosek*sparam*sensitivity-file-name"><tt class="tt">mosek.sparam.sensitivity_file_name</tt></a> and writes the result to the stream <tt class="tt">whichstream</tt>. If <a href="node018.html#common-const*mosek*sparam*sensitivity-res-file-name"><tt class="tt">mosek.sparam.sensitivity_res_file_name</tt></a> is set to a non-empty string, then the sensitivity report is also written to a file of this name.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*dualsensitivity"><tt class="tt">mosek.Task.dualsensitivity</tt></a></dt>
<dd>
<p> Performs sensitivity analysis on objective coefficients.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*primalsensitivity"><tt class="tt">mosek.Task.primalsensitivity</tt></a></dt>
<dd>
<p> Perform sensitivity analysis on bounds.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity"><tt class="tt">mosek.iparam.log_sensitivity</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity-opt"><tt class="tt">mosek.iparam.log_sensitivity_opt</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">mosek.iparam.sensitivity_type</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.set_Stream</tt></span>

<p> <a name="func*mosek*task*set-stream">&#09;</a><a name="common-func*mosek*task*set-stream"></a> <a name="idx-127118584">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void set_Stream (
    streamtype whichstream,
    Stream stream);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> </dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">stream</tt> </dt>
<dd>The stream object to attach. To detach all objects, let this be null.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Attach a stream call-back handler.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.setdefaults</tt></span>

<p> <a name="func*mosek*task*setdefaults">&#09;</a><a name="common-func*mosek*task*setdefaults"></a> <a name="idx-127126056">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void setdefaults ()
</pre>
</dd>
<dt>Description:</dt>
<dd>Resets all the parameters to their default values.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.sktostr</tt></span>

<p> <a name="func*mosek*task*sktostr">&#09;</a><a name="common-func*mosek*task*sktostr"></a> <a name="idx-127094728">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void sktostr (
    int sk,
    StringBuilder str);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">sk</tt> (input)</dt>
<dd>A valid status key.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the status key <tt class="tt">sk</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an explanatory string corresponding to a status key.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.solstatostr</tt></span>

<p> <a name="func*mosek*task*solstatostr">&#09;</a><a name="common-func*mosek*task*solstatostr"></a> <a name="idx-127149048">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void solstatostr (
    solsta solsta,
    StringBuilder str);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (input)</dt>
<dd>Solution status.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the solution status <tt class="tt">solsta</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an explanatory string corresponding to a solution status.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.solutiondef</tt></span>

<p> <a name="func*mosek*task*solutiondef">&#09;</a><a name="common-func*mosek*task*solutiondef"></a> <a name="idx-127079560">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public int solutiondef (soltype whichsol)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void solutiondef (
    soltype whichsol,
    out int isdef);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">isdef</tt> (output)</dt>
<dd>Is non-zero if the requested solution is defined.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks whether a solution is defined.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.solutionsummary</tt></span>

<p> <a name="func*mosek*task*solutionsummary">&#09;</a><a name="common-func*mosek*task*solutionsummary"></a> <a name="idx-127177936">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void solutionsummary (streamtype whichstream)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints a short summary of the current solutions. Please see Section <a title="8.7. Understanding solution quality" href="node010.html#chap:solving:sec:solqual">8.7</a> for more details.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.solvewithbasis</tt></span>

<p> <a name="func*mosek*task*solvewithbasis">&#09;</a><a name="common-func*mosek*task*solvewithbasis"></a> <a name="idx-127180024">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void solvewithbasis (
    int transp,
    ref int numnz,
    int[] sub,
    double[] val);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">transp</tt> (input)</dt>
<dd>If this argument is non-zero, then (<a href="node017.html#ais-eq-Btxb">15.9.35</a>) is solved. Otherwise the system (<a href="node017.html#ais-eq-Bxb">15.9.34</a>) is solved.</dd>
<dt><tt class="tt">numnz</tt> (input/output)</dt>
<dd>As input it is the number of non-zeros in <span class="math"><span class="mi">b</span></span>. As output it is the number of non-zeros in <span class="math"><img src="math/math420.png" alt="[[MathCmd 420]]"/></span>.</dd>
<dt><tt class="tt">sub</tt> (input/output)</dt>
<dd>
<p>As input it contains the positions of the non-zeros in <span class="math"><span class="mi">b</span></span>, i.e.  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math914.png" alt="\begin{displaymath}\nonumber{}b[\mathtt{sub}[k]]\not=0,~k=0,\ldots ,\mathtt{numnz[0]}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> As output it contains the positions of the non-zeros in <span class="math"><img src="math/math420.png" alt="[[MathCmd 420]]"/></span>. It is important that <tt class="tt">sub</tt> has room for <tt class="tt">numcon</tt> elements.</p>
</dd>
<dt><tt class="tt">val</tt> (input/output)</dt>
<dd>
<p>As input it is the vector <span class="math"><span class="mi">b</span></span>. Although the positions of the non-zero elements are specified in <tt class="tt">sub</tt> it is required that <span class="math"><img src="math/math916.png" alt="[[MathCmd 916]]"/></span> if <span class="math"><span class="mi">b</span><span class="mo">[</span><span class="mi">i</span><span class="mo">]</span><span class="mo">=</span><span class="mn">0</span></span>. As output <tt class="tt">val</tt> is the vector <span class="math"><img src="math/math420.png" alt="[[MathCmd 420]]"/></span>.</p>

<p>Please note that <tt class="tt">val</tt> is a dense vector &mdash; not a packed sparse vector. This implies that <tt class="tt">val</tt> has room for <tt class="tt">numcon</tt> elements.</p>
</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>If a basic solution is available, then exactly <span class="math"><img src="math/math18.png" alt="[[MathCmd 18]]"/></span> basis variables are defined. These <span class="math"><img src="math/math18.png" alt="[[MathCmd 18]]"/></span> basis variables are denoted the basis. Associated with the basis is a basis matrix denoted <span class="math"><span class="mi">B</span></span>. This function solves either the linear equation system  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math920.png" alt="\begin{math}\nonumber{}B\bar{x}=b\end{math}"/></td>
<td><a name="ais-eq-Bxb">&#09;</a>(15.9.34)</td></tr>
</tbody>
</table>

<p>  or the system  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math921.png" alt="\begin{math}\nonumber{}B^{T}\bar{x}=b\end{math}"/></td>
<td><a name="ais-eq-Btxb">&#09;</a>(15.9.35)</td></tr>
</tbody>
</table>

<p>  for the unknowns <span class="math"><img src="math/math420.png" alt="[[MathCmd 420]]"/></span>, with <span class="math"><span class="mi">b</span></span> being a user-defined vector.</p>

<p>In order to make sense of the solution <span class="math"><img src="math/math420.png" alt="[[MathCmd 420]]"/></span> it is important to know the ordering of the variables in the basis because the ordering specifies how <span class="math"><span class="mi">B</span></span> is constructed. When calling <a href="node017.html#common-func*mosek*task*initbasissolve"><tt class="tt">mosek.Task.initbasissolve</tt></a> an ordering of the basis variables is obtained, whicd can be used to deduce how MOSEK has constructed <span class="math"><span class="mi">B</span></span>. Indeed if the <span class="math"><span class="mi">k</span></span>th basis variable is variable <span class="math"><img src="math/math157.png" alt="[[MathCmd 157]]"/></span> it implies that  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math925.png" alt="\begin{displaymath}\nonumber{}B_{{i,k}}=A_{{i,j}},~i=0,\ldots ,\mathtt{numcon}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Otherwise if the <span class="math"><span class="mi">k</span></span>th basis variable is variable <span class="math"><img src="math/math926.png" alt="[[MathCmd 926]]"/></span> it implies that`  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math927.png" alt="\begin{displaymath}\nonumber{}B_{{i,k}}=\left\lbrace{}\begin{array}{ll}\nonumber{}-1, & i=j,\\\nonumber{}0, & i\not=j.\end{array}\right.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Given the knowledge of how <span class="math"><span class="mi">B</span></span> is constructed it is possible to interpret the solution <span class="math"><img src="math/math420.png" alt="[[MathCmd 420]]"/></span> correctly.</p>

<p>Please note that this function exploits the sparsity in the vector <span class="math"><span class="mi">b</span></span> to speed up the computations.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*initbasissolve"><tt class="tt">mosek.Task.initbasissolve</tt></a></dt>
<dd>
<p> Prepare a task for basis solver.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*basis-solve-use-plus-one"><tt class="tt">mosek.iparam.basis_solve_use_plus_one</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.strtoconetype</tt></span>

<p> <a name="func*mosek*task*strtoconetype">&#09;</a><a name="common-func*mosek*task*strtoconetype"></a> <a name="idx-120495640">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void strtoconetype (
    string str,
    out conetype conetype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">str</tt> (input)</dt>
<dd>String corresponding to the cone type code <tt class="tt">codetype</tt>.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (output)</dt>
<dd>The cone type corresponding to the string <tt class="tt">str</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains cone type code corresponding to a cone type string.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.strtosk</tt></span>

<p> <a name="func*mosek*task*strtosk">&#09;</a><a name="common-func*mosek*task*strtosk"></a> <a name="idx-120488952">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void strtosk (
    string str,
    out int sk);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">str</tt> (input)</dt>
<dd>Status key string.</dd>
<dt><tt class="tt">sk</tt> (output)</dt>
<dd>Status key corresponding to the string.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the status key corresponding to an explanatory string.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.undefsolution</tt></span>

<p> <a name="func*mosek*task*undefsolution">&#09;</a><a name="common-func*mosek*task*undefsolution"></a> <a name="idx-120519928">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void undefsolution (soltype whichsol)
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Undefines a solution. Purges all information regarding <tt class="tt">whichsol</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.writebranchpriorities</tt></span>

<p> <a name="func*mosek*task*writebranchpriorities">&#09;</a><a name="common-func*mosek*task*writebranchpriorities"></a> <a name="idx-120519424">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void writebranchpriorities (string filename)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Data is written to the file <tt class="tt">filename</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Writes branching priority data to a file.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*readbranchpriorities"><tt class="tt">mosek.Task.readbranchpriorities</tt></a></dt>
<dd>
<p> Reads branching priority data from a file.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.writedata</tt></span>

<p> <a name="func*mosek*task*writedata">&#09;</a><a name="common-func*mosek*task*writedata"></a> <a name="idx-120548168">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void writedata (string filename)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Data is written to the file <tt class="tt">filename</tt> if it is a nonempty string. Otherwise data is written to the file specified by <a href="node018.html#common-const*mosek*sparam*data-file-name"><tt class="tt">mosek.sparam.data_file_name</tt></a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Writes problem data associated with the optimization task to a file in one of four formats:</p>

<dl class="description">
<dt></dt>
<dd>
<p>LP : A text based row oriented format. File extension <tt class="tt">.lp</tt>. See Appendix <a title="D. The LP file format" href="node024.html#app-sec-lpformat">D</a>. </p>
</dd>
<dt></dt>
<dd>
<p>MPS : A text based column oriented format. File extension <tt class="tt">.mps</tt>. See Appendix <a title="C. The MPS file format" href="node023.html#app-sec-mpsformat">C</a>. </p>
</dd>
<dt></dt>
<dd>
<p>OPF : A text based row oriented format. File extension <tt class="tt">.opf</tt>. Supports more problem types than MPS and LP. See Appendix <a title="E. The OPF format" href="node025.html#app-sec-opfformat">E</a>. </p>
</dd>
<dt></dt>
<dd>
<p>MBT : A binary format for fast reading and writing. File extension <tt class="tt">.mbt</tt>. </p>
</dd>
</dl>

<p> By default the data file format is determined by the file name extension. This behaviour can be overridden by setting the <a href="node018.html#common-const*mosek*iparam*write-data-format"><tt class="tt">mosek.iparam.write_data_format</tt></a> parameter.</p>

<p>MOSEK is able to read and write files in a compressed format (gzip). To write in the compressed format append the extension "<tt class="tt">.gz</tt>". E.g to write a gzip compressed MPS file use the extension <tt class="tt">mps.gz</tt>.</p>

<p>Please note that MPS, LP and OPF files require all variables to have unique names. If a task contains no names, it is possible to write the file with automaticly generated anonymous names by setting the <a href="node018.html#common-const*mosek*iparam*write-generic-names"><tt class="tt">mosek.iparam.write_generic_names</tt></a> parameter to <a href="node020.html#common-const*mosek*onoffkey*on"><tt class="tt">mosek.onoffkey.on</tt></a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*readdata"><tt class="tt">mosek.Task.readdata</tt></a></dt>
<dd>
<p> Reads problem data from a file.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*write-data-format"><tt class="tt">mosek.iparam.write_data_format</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.writeparamfile</tt></span>

<p> <a name="func*mosek*task*writeparamfile">&#09;</a><a name="common-func*mosek*task*writeparamfile"></a> <a name="idx-120562392">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void writeparamfile (string filename)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>The name of parameter file.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Writes all the parameters to a parameter file.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">mosek.Task.writesolution</tt></span>

<p> <a name="func*mosek*task*writesolution">&#09;</a><a name="common-func*mosek*task*writesolution"></a> <a name="idx-120581872">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public void writesolution (
    soltype whichsol,
    string filename);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>A valid file name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Saves the current basic, interior-point, or integer solution to a file.</dd>
</dl>
</li>
</ul>

</div>

</div>

<div>
<h1><a name="247092288">15.10. Class <tt class="tt">mosek.Warning</tt></a></h1>

<p><a name="apiclass*mosek*warning">&#09;</a><a name="common-apiclass*mosek*warning"></a> </p>

<dl class="description">
<dt>Derived from:</dt>
<dd>
<p><tt class="tt">mosek.Exception</tt> </p>
</dd>
<dt>Description:</dt>
<dd>
<p>This is an exception class representing MOSEK warnings.</p>
</dd>
</dl>

<div>
<h2><a name="241037896">15.10.1. Constructors</a></h2>

<p> <a name="idx-120592792">&#09;</a> <a name="idx-120490824">&#09;</a> </p>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">mosek.Warning</tt></span>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">public Warning (rescode code)
</pre>
</dd>
<dt>Description:</dt>
<dd>Construct a warning from a MOSEK error code.</dd>
<dt>Arguments:</dt>
<dd>
<p>&nbsp;</p>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">code</tt></a></dt>
<dd>The MOSEK response code to create the exception from.</dd>
</dl>
</dd>
</dl>
</li>
</ul>

</div>

</div>

</div>

<div class="navigationarea">
<table class="navigation" width="100%" cellpadding="0" cellspacing="2">
<tbody><tr>
<td><a href="node016.html" target="_self"><img src="graphics/previous.png" class="navbutton-previous" alt="Previous : 14. Using MOSEK from Microsoft Solver Foundation" border="0"/></a></td>
<td><a href="index.html" target="_self"><img src="graphics/up.png" class="navbutton-up" alt="Up:  The MOSEK .NET API manual. 
Version 6.0 (Revision 137)." border="0"/></a></td>
<td><a href="node018.html" target="_self"><img src="graphics/next.png" class="navbutton-next" alt="Next:  16. Parameter reference" border="0"/></a></td>
<td align="center" class="navtitle">The MOSEK .NET API manual. 
<br/>Version 6.0 (Revision 137).</td>
<td><a href="index.html"><img src="graphics/contents.png" class="navbutton-contents" alt="" border="0"/></a></td>
<td><a href="node030.html"><img src="graphics/index.png" class="navbutton-index" alt="" border="0"/></a></td></tr>
</tbody>
</table>


<table class="trail"><tr>
<td valign="top"><b>Previous : </b><a href="node016.html" target="_self">14. Using MOSEK from Microsoft Solver Foundation</a></td>
<td valign="top"><b>Up : </b><a href="index.html" target="_self">The MOSEK .NET API manual. 
<br/>Version 6.0 (Revision 137).</a></td>
<td valign="top"><b>Next : </b><a href="node018.html" target="_self">16. Parameter reference</a></td>
<td valign="top"><a href="index.html" target="_self"><b>Contents</b></a></td>
<td valign="top"><a href="node030.html"><b>Index</b></a></td></tr></table>

<hr/>
</div>

<div class="gentime">Tue Apr 10 10:46:07 2012</div>
</body></html>