<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>15. API reference</title>
<!-- pyLaTeX: XHTML.lib.Sectioning.chapter -->
<link href="styles/style.css" rel="stylesheet"/>
<link href="styles/gstyles.css" rel="stylesheet"/>
<link href="graphics/favicon.png" rel="shortcut icon"/>
</head>
<body>
<div class="navigationarea">
<table class="navigation" width="100%" cellpadding="0" cellspacing="2">
<tbody><tr>
<td><a href="node016.html" target="_self"><img src="graphics/previous.png" class="navbutton-previous" alt="Previous : 14. Usage guidelines" border="0"/></a></td>
<td><a href="index.html" target="_self"><img src="graphics/up.png" class="navbutton-up" alt="Up:  The MOSEK C API manual. 
Version 6.0 (Revision 137)." border="0"/></a></td>
<td><a href="node018.html" target="_self"><img src="graphics/next.png" class="navbutton-next" alt="Next:  16. Parameter reference" border="0"/></a></td>
<td align="center" class="navtitle">The MOSEK C API manual. 
<br/>Version 6.0 (Revision 137).</td>
<td><a href="index.html"><img src="graphics/contents.png" class="navbutton-contents" alt="" border="0"/></a></td>
<td><a href="node030.html"><img src="graphics/index.png" class="navbutton-index" alt="" border="0"/></a></td></tr>
</tbody>
</table>


<table class="trail"><tr>
<td valign="top"><b>Previous : </b><a href="node016.html" target="_self">14. Usage guidelines</a></td>
<td valign="top"><b>Up : </b><a href="index.html" target="_self">The MOSEK C API manual. 
<br/>Version 6.0 (Revision 137).</a></td>
<td valign="top"><b>Next : </b><a href="node018.html" target="_self">16. Parameter reference</a></td>
<td valign="top"><a href="index.html" target="_self"><b>Contents</b></a></td>
<td valign="top"><a href="node030.html"><b>Index</b></a></td></tr></table>

<hr/>
</div>

<div>
<h1><a name="274293464">15. API reference</a></h1>

<div class="contents">
<ul class="toc-level-1">
<li><a href="node017.html#274292536" target="_self">15.1. Type definitions</a></li>
<li><a href="node017.html#274375888" target="_self">15.2. API Functionality</a>
<ul class="toc-level-2">
<li><a href="node017.html#274292608" target="_self">15.2.1. Analyzing the problem and associated data</a></li>
<li><a href="node017.html#274377040" target="_self">15.2.2. Reading and writing data files</a></li>
<li><a href="node017.html#274379480" target="_self">15.2.3. Solutions</a></li>
<li><a href="node017.html#274386024" target="_self">15.2.4. Call-backs (put/get)</a></li>
<li><a href="node017.html#274389112" target="_self">15.2.5. Memory allocation and deallocation</a></li>
<li><a href="node017.html#274392416" target="_self">15.2.6. Changing problem specification</a></li>
<li><a href="node017.html#274398960" target="_self">15.2.7. Delete problem elements (variables,constraints,cones)</a></li>
<li><a href="node017.html#274400104" target="_self">15.2.8. Add problem elements (variables,constraints,cones)</a></li>
<li><a href="node017.html#274401184" target="_self">15.2.9. Problem inspection</a></li>
<li><a href="node017.html#274409736" target="_self">15.2.10. Conic constraints</a></li>
<li><a href="node017.html#274411744" target="_self">15.2.11. Bounds</a></li>
<li><a href="node017.html#274413688" target="_self">15.2.12. Task initialization and deletion</a></li>
<li><a href="node017.html#274414984" target="_self">15.2.13. Error handling</a></li>
<li><a href="node017.html#274416776" target="_self">15.2.14. Output stream functions</a></li>
<li><a href="node017.html#274420728" target="_self">15.2.15. Objective function</a></li>
<li><a href="node017.html#274425544" target="_self">15.2.16. Optimizer statistics</a></li>
<li><a href="node017.html#274428200" target="_self">15.2.17. Parameters (set/get)</a></li>
<li><a href="node017.html#274434528" target="_self">15.2.18. Naming</a></li>
<li><a href="node017.html#274438912" target="_self">15.2.19. Preallocating space for problem data</a></li>
<li><a href="node017.html#274442648" target="_self">15.2.20. Integer variables</a></li>
<li><a href="node017.html#274445304" target="_self">15.2.21. Quadratic terms</a></li>
<li><a href="node017.html#274447896" target="_self">15.2.22. Diagnosing infeasibility</a></li>
<li><a href="node017.html#274449040" target="_self">15.2.23. Optimization</a></li>
<li><a href="node017.html#274450768" target="_self">15.2.24. Network optimization</a></li>
<li><a href="node017.html#274451848" target="_self">15.2.25. Sensitivity analysis</a></li>
<li><a href="node017.html#274453208" target="_self">15.2.26. Testing data validity</a></li>
<li><a href="node017.html#274454072" target="_self">15.2.27. Solving with the basis</a></li>
<li><a href="node017.html#274455368" target="_self">15.2.28. Initialization of environment</a></li>
<li><a href="node017.html#274457160" target="_self">15.2.29. Change <span class="math"><span class="mi">A</span></span></a></li>
</ul>
</li>
<li><a href="node017.html#274459824" target="_self">15.3. Mosek Env</a>
<ul class="toc-level-2">
<li><a href="node017.html#274460256" target="_self">15.3.1. Methods</a></li>
</ul>
</li>
<li><a href="node017.html#276790304" target="_self">15.4. Mosek Task</a>
<ul class="toc-level-2">
<li><a href="node017.html#274461040" target="_self">15.4.1. Methods</a></li>
</ul>
</li>
</ul>

<hr width="100%" class="tocseparator"/>
</div>

<p> <a name="chap-apiref">&#09;</a></p>

<p>This chapter lists all functionality in the MOSEK C API.</p>

<div>
<h1><a name="274292536">15.1. Type definitions</a></h1>

<ul class="functionlist">
<li class="sumitem">
<p><tt class="tt">MSKbooleant</tt> <a name="idx-100409288">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A signed integer interpreted as a boolean value.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKenv_t</tt> <a name="idx-100419272">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>The MOSEK Environment type.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKidxt</tt> <a name="idx-100424304">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A 32 bits signed integer used for indexing. This is used as indexer into arrays which are guaranteed to not exceed <span class="math"><img src="math/math849.png" alt="[[MathCmd 849]]"/></span> bits in length.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKint32t</tt> <a name="idx-100429768">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>Signed 32bit integer.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKint64t</tt> <a name="idx-100418264">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>Signed 64bit integer.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKintt</tt> <a name="idx-100389304">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A signed integer. This is a 32 bits signed integer.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKlidxt</tt> <a name="idx-100435296">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A signed integer used for indexing. This is used as indexer into arrays which on some platforms may exceed <span class="math"><img src="math/math850.png" alt="[[MathCmd 850]]"/></span> bits in length. On 32-bit architectures it will always be a signed 32 bits integer, while on 64-bit architectures it may be either a 32 or 64 bits signed integer.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKlintt</tt> <a name="idx-100440760">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A signed large integer. On 32-bit architectures it is always 32 bits, while on 64-bit architectures it may be either 32 or 64 bits.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKoprt</tt> <a name="idx-100445792">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>An unsigned integer interpreted as a code list element. Each operation in a code list consists of 4 elements.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKrealt</tt> <a name="idx-100450888">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>The floating point type used by MOSEK.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKstring_t</tt> <a name="idx-100439896">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>The string type used by MOSEK. This is an UTF-8 encoded zero-terminated char string.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKtask_t</tt> <a name="idx-100453336">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>The MOSEK Task type.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKuint32t</tt> <a name="idx-100462464">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>Unsigned 32bit integer.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKuint64t</tt> <a name="idx-100468208">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>Unsigned 64bit integer.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKuserhandle_t</tt> <a name="idx-100473384">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A pointer to a generic user-defined structure.</p>
</dd>
</dl>
</li>
<li class="sumitem">
<p><tt class="tt">MSKwchart</tt> <a name="idx-100478488">&#09;</a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>Wide char type. The actual type may differ depending on the platform; it is either a 16 or 32 bits signed or unsigned integer.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSKcallbackfunc</tt></span>

<p> <a name="idx-100477264">&#09;</a> <a name="typedef*mosek*callbackfunc">&#09;</a><a name="common-typedef*mosek*callbackfunc"></a> </p>

<dl class="funcdesc">
<dt>Description:</dt>
<dd>
<p>Definition of the progress call-back function. The progress call-back function is a user-defined function which will be called by MOSEK occasionally during the optimization process. In particular, the call-back function is called at the beginning of each iteration in the interior-point optimizer. For the simplex optimizers <a href="node018.html#common-const*mosek*iparam*log-sim-freq"><tt class="tt">MSK_IPAR_LOG_SIM_FREQ</tt></a> controls how frequently the call-back is called.</p>

<p>Typically the user-defined call-back function displays information about the solution process. The call-back function can also be used to terminate the optimization process since if the progress call-back function returns a non-zero value, the optimization process is aborted.</p>

<p><b>It is important that the user-defined call-back function does not modify the optimization task, this will lead to undefined and incorrect results</b>. The only MOSEK functions that can be called safely from within the user-defined call-back function are <a href="node017.html#common-func*mosek*task*getdouinf"><tt class="tt">MSK_getdouinf</tt></a> and <a href="node017.html#common-func*mosek*task*getintinf"><tt class="tt">MSK_getintinf</tt></a> which access the task information database. The items in task information database are updated during the optimization process.</p>
</dd>
<dt>Syntax:</dt>
<dd>
<pre class="verbatim">MSKintt MSKcallbackfunc (
    MSKtask_t task,
    MSKuserhandle_t usrptr,
    MSKcallbackcodee caller);
</pre>
</dd>
<dt>Arguments:</dt>
<dd>
<dl class="description">
<dt><tt class="tt">task</tt></dt>
<dd>
<p>(input)</p>

<p>An optimization task.</p>
</dd>
<dt><tt class="tt">usrptr</tt></dt>
<dd>
<p>(input/output)</p>

<p>A pointer to a user-defined structure.</p>
</dd>
<dt><a href="node020.html#common-constclass*mosek*callbackcode"><tt class="tt">caller</tt></a></dt>
<dd>
<p>(input)</p>

<p>An integer which tells where the function was called from. See section <a title="18.7. Progress call-back codes" href="node020.html#constclass*mosek*callbackcode">18.7</a> for the possible values of this argument.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSKexitfunc</tt></span>

<p> <a name="idx-100480352">&#09;</a> <a name="typedef*mosek*exitfunc">&#09;</a><a name="common-typedef*mosek*exitfunc"></a> </p>

<dl class="funcdesc">
<dt>Description:</dt>
<dd>A user-defined exit function which is called in case of fatal errors to handle an error message and terminate the program. The function should never return.</dd>
<dt>Syntax:</dt>
<dd>
<pre class="verbatim">void MSKexitfunc (
    MSKuserhandle_t usrptr,
    MSKCONST char * file,
    MSKintt line,
    MSKCONST char * msg);
</pre>
</dd>
<dt>Arguments:</dt>
<dd>
<dl class="description">
<dt><tt class="tt">usrptr</tt></dt>
<dd>
<p>(input/output)</p>

<p>A pointer to a user-defined structure.</p>
</dd>
<dt><tt class="tt">file</tt></dt>
<dd>
<p>(input)</p>

<p>The name of the file where the fatal error occurred.</p>
</dd>
<dt><tt class="tt">line</tt></dt>
<dd>
<p>(input)</p>

<p>The line number in the file where the fatal error occurred.</p>
</dd>
<dt><tt class="tt">msg</tt></dt>
<dd>
<p>(input)</p>

<p>A message about the error.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSKfreefunc</tt></span>

<p> <a name="idx-101422288">&#09;</a> <a name="typedef*mosek*freefunc">&#09;</a><a name="common-typedef*mosek*freefunc"></a> </p>

<dl class="funcdesc">
<dt>Description:</dt>
<dd>A user-defined memory freeing function.</dd>
<dt>Syntax:</dt>
<dd>
<pre class="verbatim">void MSKfreefunc (
    MSKuserhandle_t usrptr,
    void * buffer);
</pre>
</dd>
<dt>Arguments:</dt>
<dd>
<dl class="description">
<dt><tt class="tt">usrptr</tt></dt>
<dd>
<p>(input)</p>

<p>A pointer to a user-defined structure.</p>
</dd>
<dt><tt class="tt">buffer</tt></dt>
<dd>
<p>(input/output)</p>

<p>A pointer to the buffer which should be freed.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSKmallocfunc</tt></span>

<p> <a name="idx-100496664">&#09;</a> <a name="typedef*mosek*mallocfunc">&#09;</a><a name="common-typedef*mosek*mallocfunc"></a> </p>

<dl class="funcdesc">
<dt>Description:</dt>
<dd>A user-defined memory allocation function.</dd>
<dt>Syntax:</dt>
<dd>
<pre class="verbatim">void * MSKmallocfunc (
    MSKuserhandle_t usrptr,
    MSKCONST size_t size);
</pre>
</dd>
<dt>Arguments:</dt>
<dd>
<dl class="description">
<dt><tt class="tt">usrptr</tt></dt>
<dd>
<p>(input)</p>

<p>A pointer to a user-defined structure.</p>
</dd>
<dt><tt class="tt">size</tt></dt>
<dd>
<p>(input)</p>

<p>The number of characters to allocate.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSKnlgetspfunc</tt></span>

<p> <a name="idx-101447656">&#09;</a> <a name="typedef*mosek*nlgetspfunc">&#09;</a><a name="common-typedef*mosek*nlgetspfunc"></a> </p>

<dl class="funcdesc">
<dt>Description:</dt>
<dd>
<p>Type definition of the call-back function which is used to provide structural information about the nonlinear functions <span class="math"><span class="mi">f</span></span> and <span class="math"><span class="mi">g</span></span> in the optimization problem.</p>

<p>Hence, it is the user's responsibility to provide a function satisfying the definition. The function is inputted to MOSEK using the API function <a href="node017.html#common-func*mosek*task*putnlfunc"><tt class="tt">MSK_putnlfunc</tt></a>.</p>
</dd>
<dt>Syntax:</dt>
<dd>
<pre class="verbatim">MSKintt MSKnlgetspfunc (
    MSKuserhandle_t nlhandle,
    MSKintt * numgrdobjnz,
    MSKidxt * grdobjsub,
    MSKidxt i,
    MSKbooleant * convali,
    MSKintt * grdconinz,
    MSKidxt * grdconisub,
    MSKintt yo,
    MSKintt numycnz,
    MSKCONST MSKidxt * ycsub,
    MSKintt maxnumhesnz,
    MSKintt * numhesnz,
    MSKidxt * hessubi,
    MSKidxt * hessubj);
</pre>
</dd>
<dt>Arguments:</dt>
<dd>
<dl class="description">
<dt><tt class="tt">nlhandle</tt></dt>
<dd>
<p>(input/output)</p>

<p>A pointer to a user-defined data structure specified when the function is attached to a task using the function <a href="node017.html#common-func*mosek*task*putnlfunc"><tt class="tt">MSK_putnlfunc</tt></a>.</p>
</dd>
<dt><tt class="tt">numgrdobjnz</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, <tt class="tt">numgrdobjnz</tt> should be assigned the number of non-zero elements in the gradient of <span class="math"><span class="mi">f</span></span>.</p>
</dd>
<dt><tt class="tt">grdobjsub</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, put here the positions of the non-zero elements in the gradient of <span class="math"><span class="mi">f</span></span>. The elements are stored in  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math851.png" alt="\begin{displaymath}\nonumber{}\mathtt{grdobjsub}[0,..,\mathtt{numgrdobjsub}-1.]\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">i</tt></dt>
<dd>
<p>(input)</p>

<p>Index of a constraint. If <span class="math"><span class="mi">i</span><span class="mo">&lt;</span><span class="mn">0</span></span> or <span class="math"><img src="math/math852.png" alt="[[MathCmd 852]]"/></span>, no information about a constraint is requested.</p>
</dd>
<dt><tt class="tt">convali</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, assign a true/false value indicating if constraint <tt class="tt">i</tt> contains general nonlinear terms.</p>
</dd>
<dt><tt class="tt">grdconinz</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, <tt class="tt">grdconinz</tt> shall be assigned the number of non-zero elements in <span class="math"><img src="math/math853.png" alt="[[MathCmd 853]]"/></span>.</p>
</dd>
<dt><tt class="tt">grdconisub</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, this array shall contain the indexes of the non-zeros in <span class="math"><img src="math/math853.png" alt="[[MathCmd 853]]"/></span>. The length of the array must be the same as given in <tt class="tt">grdconinz</tt>.</p>
</dd>
<dt><tt class="tt">yo</tt></dt>
<dd>
<p>(input)</p>

<p>If non-zero, then the <span class="math"><span class="mi">f</span></span> shall be included when the gradient and the Hessian of the Lagrangian are computed.</p>
</dd>
<dt><tt class="tt">numycnz</tt></dt>
<dd>
<p>(input)</p>

<p>Number of constraint functions which are included in the definition of the Lagrangian. See (<a href="node017.html#ais-eq-defsymlag">15.1.1</a>).</p>
</dd>
<dt><tt class="tt">ycsub</tt></dt>
<dd>
<p>(input)</p>

<p>Index of constraint functions which are included in the definition of the Lagrangian. See (<a href="node017.html#ais-eq-defsymlag">15.1.1</a>).</p>
</dd>
<dt><tt class="tt">maxnumhesnz</tt></dt>
<dd>
<p>(input)</p>

<p>Length of the arguments <tt class="tt">hessubi</tt> and <tt class="tt">hessubj</tt>.</p>
</dd>
<dt><tt class="tt">numhesnz</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, <tt class="tt">numhesnz</tt> should be assigned the number of non-zero elements in the lower triangular part of the Hessian of the Lagrangian:  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math855.png" alt="\begin{math}\nonumber{}L:=\mathtt{yo}f(x)-\sum _{{k=0}}^{{\mathtt{numycnz}-1}}g_{{\mathtt{ycsub[k]}}}(x)\end{math}"/></td>
<td><a name="ais-eq-defsymlag">&#09;</a>(15.1.1)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">hessubi</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, <tt class="tt">hessubi</tt> and <tt class="tt">hessubj</tt> are used to convey the position of the non-zeros in the Hessian of the Lagrangian <span class="math"><span class="mi">L</span></span> (see (<a href="node017.html#ais-eq-defsymlag">15.1.1</a>)) as follows  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math856.png" alt="\begin{math}\nonumber{}\nabla ^{2}L_{{\mathtt{hessubi}[k],\mathtt{hessubj}[k]}}(x)\not=0.0\end{math}"/></td>
<td>(15.1.2)</td></tr>
</tbody>
</table>

<p>  for <span class="math"><img src="math/math857.png" alt="[[MathCmd 857]]"/></span>.  All other positions in <span class="math"><span class="mi">L</span></span> are assumed to be zero. Please note that <em>only</em> the lower <em>or</em> the upper triangular part of the Hessian should be return.</p>
</dd>
<dt><tt class="tt">hessubj</tt></dt>
<dd>
<p>(output)</p>

<p>See the argument <tt class="tt">hessubi</tt>.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSKnlgetvafunc</tt></span>

<p> <a name="idx-101522104">&#09;</a> <a name="typedef*mosek*nlgetvafunc">&#09;</a><a name="common-typedef*mosek*nlgetvafunc"></a> </p>

<dl class="funcdesc">
<dt>Description:</dt>
<dd>
<p>Type definition of the call-back function which is used to provide structural and numerical information about the nonlinear functions <span class="math"><span class="mi">f</span></span> and <span class="math"><span class="mi">g</span></span> in an optimization problem.</p>

<p>For later use we need the definition of the Lagrangian <span class="math"><span class="mi">L</span></span> which is given by  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math858.png" alt="\begin{math}\nonumber{}L:=\mathtt{yo}*f(\mathtt{xx})-\sum _{{k=0}}^{{\mathtt{numi}-1}}\mathtt{yc}_{{\mathtt{subi[k]}}}g_{{\mathtt{subi[k]}}}(\mathtt{xx}).\end{math}"/></td>
<td><a name="ais-eq-defnumlag">&#09;</a>(15.1.3)</td></tr>
</tbody>
</table>
</dd>
<dt>Syntax:</dt>
<dd>
<pre class="verbatim">MSKintt MSKnlgetvafunc (
    MSKuserhandle_t nlhandle,
    MSKCONST MSKrealt * xx,
    MSKrealt yo,
    MSKCONST MSKrealt * yc,
    MSKrealt * objval,
    MSKintt * numgrdobjnz,
    MSKidxt * grdobjsub,
    MSKrealt * grdobjval,
    MSKintt numi,
    MSKCONST MSKidxt * subi,
    MSKrealt * conval,
    MSKCONST MSKintt * grdconptrb,
    MSKCONST MSKintt * grdconptre,
    MSKCONST MSKidxt * grdconsub,
    MSKrealt * grdconval,
    MSKrealt * grdlag,
    MSKintt maxnumhesnz,
    MSKintt * numhesnz,
    MSKidxt * hessubi,
    MSKidxt * hessubj,
    MSKrealt * hesval);
</pre>
</dd>
<dt>Arguments:</dt>
<dd>
<dl class="description">
<dt><tt class="tt">nlhandle</tt></dt>
<dd>
<p>(input/output)</p>

<p>A pointer to a user-defined data structure. The pointer is passed to MOSEK when the function <a href="node017.html#common-func*mosek*task*putnlfunc"><tt class="tt">MSK_putnlfunc</tt></a> is called.</p>
</dd>
<dt><tt class="tt">xx</tt></dt>
<dd>
<p>(input)</p>

<p>The point at which the nonlinear function must be evaluated. The length equals the number of variables in the task.</p>
</dd>
<dt><tt class="tt">yo</tt></dt>
<dd>
<p>(input)</p>

<p>Multiplier on the objective function <span class="math"><span class="mi">f</span></span>.</p>
</dd>
<dt><tt class="tt">yc</tt></dt>
<dd>
<p>(input)</p>

<p>Multipliers for the constraint functions <span class="math"><img src="math/math859.png" alt="[[MathCmd 859]]"/></span>. The length is <tt class="tt">numcon</tt>.</p>
</dd>
<dt><tt class="tt">objval</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, <tt class="tt">objval</tt> shall be assigned the value of <span class="math"><span class="mi">f</span></span> evaluated at <span class="math"><span class="mi">x</span><span class="mi">x</span></span>.</p>
</dd>
<dt><tt class="tt">numgrdobjnz</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, <tt class="tt">numgrdobjnz</tt> shall be assigned the number of non-zero elements in the gradient of <span class="math"><span class="mi">f</span></span>.</p>
</dd>
<dt><tt class="tt">grdobjsub</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, it shall contain the position of the non-zero elements in the gradient of <span class="math"><span class="mi">f</span></span>. The elements are stored in  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math860.png" alt="\begin{displaymath}\nonumber{}\mathtt{grdobjsub}[0,\ldots ,\mathtt{numgrdobjnz}-1].\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">grdobjval</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, it shall contain the the gradient of <span class="math"><span class="mi">f</span></span> evaluated at <span class="math"><img src="math/math861.png" alt="[[MathCmd 861]]"/></span>. The following data structure  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math862.png" alt="\begin{displaymath}\nonumber{}\mathtt{grdobjval[k]}=\frac{\partial f}{\partial x_{{{grdobjsub[k]}}}}(\mathtt{xx})\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  for <span class="math"><img src="math/math863.png" alt="[[MathCmd 863]]"/></span> is used.</p>
</dd>
<dt><tt class="tt">numi</tt></dt>
<dd>
<p>(input)</p>

<p>Number of elements in <tt class="tt">subi</tt>.</p>
</dd>
<dt><tt class="tt">subi</tt></dt>
<dd>
<p>(input)</p>

<p><span class="math"><img src="math/math864.png" alt="[[MathCmd 864]]"/></span> contain the indexes of the constraints that has to be evaluated. The length is <tt class="tt">numi</tt>.</p>
</dd>
<dt><tt class="tt">conval</tt></dt>
<dd>
<p>(output)</p>

<p><span class="math"><img src="math/math865.png" alt="[[MathCmd 865]]"/></span> for the required constraint functions i.e.  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math866.png" alt="\begin{displaymath}\nonumber{}\mathtt{conval[k]}=g_{{\mathtt{subi[k]}}}(\mathtt{xx)}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  for <span class="math"><img src="math/math867.png" alt="[[MathCmd 867]]"/></span></p>
</dd>
<dt><tt class="tt">grdconptrb</tt></dt>
<dd>
<p>(input)</p>

<p>If given, it specifies the structure of the gradients of the constraint functions. See the argument <tt class="tt">grdconval</tt> for details.</p>
</dd>
<dt><tt class="tt">grdconptre</tt></dt>
<dd>
<p>(input)</p>

<p>If given, it specifies the structure of the gradients of the constraint functions. See the argument <tt class="tt">grdconval</tt> for details.</p>
</dd>
<dt><tt class="tt">grdconsub</tt></dt>
<dd>
<p>(input)</p>

<p>If requested, it shall specify the positions of the non-zeros in gradients of the constraints. See the argument <tt class="tt">grdconval</tt> for details.</p>
</dd>
<dt><tt class="tt">grdconval</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, it shall specify the values of the gradient of the nonlinear constraints.</p>

<p>Together <tt class="tt">grdconptrb</tt>, <tt class="tt">grdconptre</tt>, <tt class="tt">grdconsub</tt> and <tt class="tt">grdconval</tt> are used to specify the gradients of the nonlinear constraint functions.</p>

<p><b>Please note that both <tt class="tt">grdconsub</tt> and <tt class="tt">grdconval</tt> should be computed when requested.</b></p>

<p>The gradient data is stored as follows  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math868.png" alt="\begin{displaymath}\nonumber{}\begin{array}{l}\nonumber{}\mathtt{grdconval[k]}=\frac{\partial g_{{\mathtt{subi[i]}}}(xx)}{\partial xx_{\mathtt{grdconsub[k]}}},\quad{}\mbox{for}\\\nonumber{}\quad{}k=\mathtt{grdconptrb}[i],\ldots ,\mathtt{grdconptre}[i]-1,\\\nonumber{}\quad{}i=0,\ldots ,\mathtt{numi}-1.\end{array}\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">grdlag</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, <tt class="tt">grdlag</tt> shall contain the gradient of the Lagrangian function, i.e.  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math869.png" alt="\begin{displaymath}\nonumber{}\mathtt{grdlag}=\nabla L.\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxnumhesnz</tt></dt>
<dd>
<p>(input)</p>

<p>Maximum number of non-zeros in the Hessian of the Lagrangian, i.e. <tt class="tt">maxnumhesnz</tt> is the length of the arrays <tt class="tt">hessubi</tt>, <tt class="tt">hessubj</tt>, and <tt class="tt">hesval</tt>.</p>
</dd>
<dt><tt class="tt">numhesnz</tt></dt>
<dd>
<p>(output)</p>

<p>If requested, <tt class="tt">numhesnz</tt> shall be assigned the number of non-zeros elements in the Hessian of the Lagrangian <span class="math"><span class="mi">L</span></span>. See (<a href="node017.html#ais-eq-defnumlag">15.1.3</a>).</p>
</dd>
<dt><tt class="tt">hessubi</tt></dt>
<dd>
<p>(output)</p>

<p>See the argument <tt class="tt">hesval</tt>.</p>
</dd>
<dt><tt class="tt">hessubj</tt></dt>
<dd>
<p>(output)</p>

<p>See the argument <tt class="tt">hesval</tt>.</p>
</dd>
<dt><tt class="tt">hesval</tt></dt>
<dd>
<p>(output)</p>

<p>Together <tt class="tt">hessubi</tt>, <tt class="tt">hessubj</tt>, and <tt class="tt">hesval</tt> specify the Hessian of the Lagrangian function <span class="math"><span class="mi">L</span></span> defined in (<a href="node017.html#ais-eq-defnumlag">15.1.3</a>).</p>

<p>The Hessian is stored in the following format:  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math870.png" alt="\begin{displaymath}\nonumber{}\mathtt{hesval}[k]=\nabla ^{2}L_{{\min (\mathtt{hessubi}[k],\mathtt{hessubj}[k]),\max (\mathtt{hessubi}[k],\mathtt{hessubj}[k])}}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  for <span class="math"><img src="math/math871.png" alt="[[MathCmd 871]]"/></span>. Please note that if an element is specified multiple times, then the elements are added together. Hence, <em>only</em> the lower <em>or</em> the upper triangular part of the Hessian should be returned.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSKresponsefunc</tt></span>

<p> <a name="idx-101622200">&#09;</a> <a name="typedef*mosek*responsefunc">&#09;</a><a name="common-typedef*mosek*responsefunc"></a> </p>

<dl class="funcdesc">
<dt>Description:</dt>
<dd>Whenever MOSEK generate a warning or an error this function is called. The argument <tt class="tt">r</tt> contains the code of the error/warning and the argument <tt class="tt">msg</tt> contains the corresponding error/warning message. This function should always return <a href="#common-const*mosek*rescode*ok"><tt class="tt">MSK_RES_OK</tt></a>.</dd>
<dt>Syntax:</dt>
<dd>
<pre class="verbatim">MSKrescodee MSKresponsefunc (
    MSKuserhandle_t handle,
    MSKrescodee r,
    MSKCONST char * msg);
</pre>
</dd>
<dt>Arguments:</dt>
<dd>
<dl class="description">
<dt><tt class="tt">handle</tt></dt>
<dd>
<p>(input/output)</p>

<p>A pointer to a user-defined data structure or NULL.</p>
</dd>
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">r</tt></a></dt>
<dd>
<p>(input)</p>

<p>The response code corresponding to the exception.</p>
</dd>
<dt><tt class="tt">msg</tt></dt>
<dd>
<p>(input)</p>

<p>A string containing the exception message.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSKstreamfunc</tt></span>

<p> <a name="idx-101635712">&#09;</a> <a name="typedef*mosek*streamfunc">&#09;</a><a name="common-typedef*mosek*streamfunc"></a> </p>

<dl class="funcdesc">
<dt>Description:</dt>
<dd>A function of this type can be linked to any of the MOSEK streams. This implies that if a message is send to the stream to which the function is linked, the function is called by MOSEK and the argument <tt class="tt">str</tt> will contain the message. Hence, the user can decide what should happen to message.</dd>
<dt>Syntax:</dt>
<dd>
<pre class="verbatim">void MSKstreamfunc (
    MSKuserhandle_t handle,
    MSKCONST char * str);
</pre>
</dd>
<dt>Arguments:</dt>
<dd>
<dl class="description">
<dt><tt class="tt">handle</tt></dt>
<dd>
<p>(input/output)</p>

<p>A pointer to a user-defined data structure (or a null pointer).</p>
</dd>
<dt><tt class="tt">str</tt></dt>
<dd>
<p>(input)</p>

<p>A string containing a message to a stream.</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>

</div>

<div>
<h1><a name="274375888">15.2. API Functionality</a></h1>

<p> Functions in the interface grouped by functionality.</p>

<div>
<h2><a name="274292608">15.2.1. Analyzing the problem and associated data</a></h2>

<p> Analyzing the problem and associated data. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*analyzeproblem"><b>MSK_analyzeproblem</b></a>
<br/>Analyze the data of a task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*analyzesolution"><b>MSK_analyzesolution</b></a>
<br/>Print information related to the quality of the solution. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274377040">15.2.2. Reading and writing data files</a></h2>

<p> Reading and writing data files. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readbranchpriorities"><b>MSK_readbranchpriorities</b></a>
<br/>Reads branching priority data from a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readdata"><b>MSK_readdata</b></a>
<br/>Reads problem data from a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readparamfile"><b>MSK_readparamfile</b></a>
<br/>Reads a parameter file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readsolution"><b>MSK_readsolution</b></a>
<br/>Reads a solution from a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*writebranchpriorities"><b>MSK_writebranchpriorities</b></a>
<br/>Writes branching priority data to a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*writedata"><b>MSK_writedata</b></a>
<br/>Writes problem data to a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*writeparamfile"><b>MSK_writeparamfile</b></a>
<br/>Writes all the parameters to a parameter file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*writesolution"><b>MSK_writesolution</b></a>
<br/>Write a solution to a file. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274379480">15.2.3. Solutions</a></h2>

<p> Obtain or define a solution. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*deletesolution"><b>MSK_deletesolution</b></a>
<br/>Undefines a solution and frees the memory it uses. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdbi"><b>MSK_getdbi</b></a>
<br/>Obtains the dual bound infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdcni"><b>MSK_getdcni</b></a>
<br/>Obtains the dual cone infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdeqi"><b>MSK_getdeqi</b></a>
<br/>Optains the dual equation infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdualobj"><b>MSK_getdualobj</b></a>
<br/>Obtains the dual objective value. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getinti"><b>MSK_getinti</b></a>
<br/>Obtains the primal equation infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getpbi"><b>MSK_getpbi</b></a>
<br/>Obtains the primal bound infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getpcni"><b>MSK_getpcni</b></a>
<br/>Obtains the primal cone infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getpeqi"><b>MSK_getpeqi</b></a>
<br/>Obtains the primal equation infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getprimalobj"><b>MSK_getprimalobj</b></a>
<br/>Obtains the primal objective value. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getreducedcosts"><b>MSK_getreducedcosts</b></a>
<br/>Obtains the difference of (slx-sux) for a sequence of variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolution"><b>MSK_getsolution</b></a>
<br/>Obtains the complete solution. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutioni"><b>MSK_getsolutioni</b></a>
<br/>Obtains the solution for a single constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutionincallback"><b>MSK_getsolutionincallback</b></a>
<br/>Obtains the whole or a part of the solution from the progress call-back function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutioninf"><b>MSK_getsolutioninf</b></a>
<br/>Obtains information about a solution. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutionslice"><b>MSK_getsolutionslice</b></a>
<br/>Obtains a slice of the solution. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutionstatus"><b>MSK_getsolutionstatus</b></a>
<br/>Obtains information about the problem and solution statuses. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutionstatuskeyslice"><b>MSK_getsolutionstatuskeyslice</b></a>
<br/>Obtains a slice of the solution status keys. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><b>MSK_makesolutionstatusunknown</b></a>
<br/>Sets the solution status to unknown. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*optimizersummary"><b>MSK_optimizersummary</b></a>
<br/>Prints a short summary with optimizer statistics for last optimization. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putsolution"><b>MSK_putsolution</b></a>
<br/>Inserts a solution. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putsolutioni"><b>MSK_putsolutioni</b></a>
<br/>Sets the primal and dual solution information for a single constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readsolution"><b>MSK_readsolution</b></a>
<br/>Reads a solution from a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solstatostr"><b>MSK_solstatostr</b></a>
<br/>Obtains a solution status string. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solutiondef"><b>MSK_solutiondef</b></a>
<br/>Checks whether a solution is defined. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solutionsummary"><b>MSK_solutionsummary</b></a>
<br/>Prints a short summary of the current solutions. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*undefsolution"><b>MSK_undefsolution</b></a>
<br/>Undefines a solution. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274386024">15.2.4. Call-backs (put/get)</a></h2>

<p> Manipulating call-backs. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcallbackfunc"><b>MSK_getcallbackfunc</b></a>
<br/>Obtains the call-back function and the associated user handle. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnlfunc"><b>MSK_getnlfunc</b></a>
<br/>Gets nonlinear call-back functions. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getsolutionincallback"><b>MSK_getsolutionincallback</b></a>
<br/>Obtains the whole or a part of the solution from the progress call-back function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*linkfunctoenvstream"><b>MSK_linkfunctoenvstream</b></a>
<br/>Connects a user-defined function to a stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*linkfunctotaskstream"><b>MSK_linkfunctotaskstream</b></a>
<br/>Connects a user-defined function to a task stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcallbackfunc"><b>MSK_putcallbackfunc</b></a>
<br/>Input the progress call-back function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*putexitfunc"><b>MSK_putexitfunc</b></a>
<br/>Inputs a user-defined exit function which is called in case of fatal errors. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putnlfunc"><b>MSK_putnlfunc</b></a>
<br/>Inputs nonlinear function information. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putresponsefunc"><b>MSK_putresponsefunc</b></a>
<br/>Inputs a user-defined error call-back function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*unlinkfuncfromenvstream"><b>MSK_unlinkfuncfromenvstream</b></a>
<br/>Disconnects a user-defined function from a stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*unlinkfuncfromtaskstream"><b>MSK_unlinkfuncfromtaskstream</b></a>
<br/>Disconnects a user-defined function from a task stream. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274389112">15.2.5. Memory allocation and deallocation</a></h2>

<p> Memory allocation and deallocation. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*callocdbgenv"><b>MSK_callocdbgenv</b></a>
<br/>A replacement for the system calloc function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*callocdbgtask"><b>MSK_callocdbgtask</b></a>
<br/>A replacement for the system calloc function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*callocenv"><b>MSK_callocenv</b></a>
<br/>A replacement for the system calloc function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*calloctask"><b>MSK_calloctask</b></a>
<br/>A replacement for the system calloc function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*checkmemenv"><b>MSK_checkmemenv</b></a>
<br/>Checks the memory allocated by the environment. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*checkmemtask"><b>MSK_checkmemtask</b></a>
<br/>Checks the memory allocated by the task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*freedbgenv"><b>MSK_freedbgenv</b></a>
<br/>Frees space allocated by MOSEK. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*freedbgtask"><b>MSK_freedbgtask</b></a>
<br/>Frees space allocated by MOSEK. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*freeenv"><b>MSK_freeenv</b></a>
<br/>Frees space allocated by MOSEK. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*freetask"><b>MSK_freetask</b></a>
<br/>Frees space allocated by MOSEK. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmemusagetask"><b>MSK_getmemusagetask</b></a>
<br/>Obtains information about the amount of memory used by a task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmemusagetask64"><b>MSK_getmemusagetask64</b></a>
<br/>Obtains information about the amount of memory used by a task. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274392416">15.2.6. Changing problem specification</a></h2>

<p> Input or change problem specification. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*append"><b>MSK_append</b></a>
<br/>Appends a number of variables or constraints to the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*appendcone"><b>MSK_appendcone</b></a>
<br/>Appends a new cone constraint to the problem. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*checkoutlicense"><b>MSK_checkoutlicense</b></a>
<br/>Check out a license feature from the license server ahead of time. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*chgbound"><b>MSK_chgbound</b></a>
<br/>Changes the bounds for one constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*clonetask"><b>MSK_clonetask</b></a>
<br/>Creates a clone of an existing task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*commitchanges"><b>MSK_commitchanges</b></a>
<br/>Commits all cached problem changes. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*inputdata"><b>MSK_inputdata</b></a>
<br/>Input the linear part of an optimization task in one function call. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*inputdata64"><b>MSK_inputdata64</b></a>
<br/>Input the linear part of an optimization task in one function call. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaij"><b>MSK_putaij</b></a>
<br/>Changes a single value in the linear coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaijlist"><b>MSK_putaijlist</b></a>
<br/>Changes one or more coefficients in the linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putavec"><b>MSK_putavec</b></a>
<br/>Replaces all elements in one row or column of the linear coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaveclist"><b>MSK_putaveclist</b></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaveclist64"><b>MSK_putaveclist64</b></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putbound"><b>MSK_putbound</b></a>
<br/>Changes the bound for either one constraint or one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putboundlist"><b>MSK_putboundlist</b></a>
<br/>Changes the bounds of constraints or variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putboundslice"><b>MSK_putboundslice</b></a>
<br/>Modifies bounds. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcfix"><b>MSK_putcfix</b></a>
<br/>Replaces the fixed term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcj"><b>MSK_putcj</b></a>
<br/>Modifies one linear coefficient in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putclist"><b>MSK_putclist</b></a>
<br/>Modifies a part of the linear objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcone"><b>MSK_putcone</b></a>
<br/>Replaces a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putobjsense"><b>MSK_putobjsense</b></a>
<br/>Sets the objective sense. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqcon"><b>MSK_putqcon</b></a>
<br/>Replaces all quadratic terms in constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqconk"><b>MSK_putqconk</b></a>
<br/>Replaces all quadratic terms in a single constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobj"><b>MSK_putqobj</b></a>
<br/>Replaces all quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobjij"><b>MSK_putqobjij</b></a>
<br/>Replaces one coefficient in the quadratic term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvartype"><b>MSK_putvartype</b></a>
<br/>Sets the variable type of one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvartypelist"><b>MSK_putvartypelist</b></a>
<br/>Sets the variable type for one or more variables. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274398960">15.2.7. Delete problem elements (variables,constraints,cones)</a></h2>

<p> Functionality for deleting problem elements such as variables, constraints or cones. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*remove"><b>MSK_remove</b></a>
<br/>The function removes a number of constraints or variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*removecone"><b>MSK_removecone</b></a>
<br/>Removes a conic constraint from the problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274400104">15.2.8. Add problem elements (variables,constraints,cones)</a></h2>

<p> Functionality for adding problem elements such as variables, constraints or cones. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*append"><b>MSK_append</b></a>
<br/>Appends a number of variables or constraints to the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*appendcone"><b>MSK_appendcone</b></a>
<br/>Appends a new cone constraint to the problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274401184">15.2.9. Problem inspection</a></h2>

<p> Functionality for inspecting the problem specification (<span class="math"><span class="mi">A</span></span>,<span class="math"><span class="mi">Q</span></span>, bounds, objective e.t.c). </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getaij"><b>MSK_getaij</b></a>
<br/>Obtains a single coefficient in linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getaslice"><b>MSK_getaslice</b></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getaslice64"><b>MSK_getaslice64</b></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getaslicetrip"><b>MSK_getaslicetrip</b></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix in triplet format. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getavec"><b>MSK_getavec</b></a>
<br/>Obtains one row or column of the linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getavecnumnz"><b>MSK_getavecnumnz</b></a>
<br/>Obtains the number of non-zero elements in one row or column of the linear constraint matrix </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getbound"><b>MSK_getbound</b></a>
<br/>Obtains bound information for one constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getboundslice"><b>MSK_getboundslice</b></a>
<br/>Obtains bounds information for a sequence of variables or constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getc"><b>MSK_getc</b></a>
<br/>Obtains all objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcfix"><b>MSK_getcfix</b></a>
<br/>Obtains the fixed term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcone"><b>MSK_getcone</b></a>
<br/>Obtains a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getconeinfo"><b>MSK_getconeinfo</b></a>
<br/>Obtains information about a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcslice"><b>MSK_getcslice</b></a>
<br/>Obtains a sequence of coefficients from the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getintpntnumthreads"><b>MSK_getintpntnumthreads</b></a>
<br/>Obtains the number of threads used by the interior-point optimizer. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumanz"><b>MSK_getnumanz</b></a>
<br/>Obtains the number of non-zeros in the coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumanz64"><b>MSK_getnumanz64</b></a>
<br/>Obtains the number of non-zeros in the coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumcon"><b>MSK_getnumcon</b></a>
<br/>Obtains the number of constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumcone"><b>MSK_getnumcone</b></a>
<br/>Obtains the number of cones. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumconemem"><b>MSK_getnumconemem</b></a>
<br/>Obtains the number of members in a cone. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumintvar"><b>MSK_getnumintvar</b></a>
<br/>Obtains the number of integer-constrained variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqconknz"><b>MSK_getnumqconknz</b></a>
<br/>Obtains the number of non-zero quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqconknz64"><b>MSK_getnumqconknz64</b></a>
<br/>Obtains the number of non-zero quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqobjnz"><b>MSK_getnumqobjnz</b></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqobjnz64"><b>MSK_getnumqobjnz64</b></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumvar"><b>MSK_getnumvar</b></a>
<br/>Obtains the number of variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjsense"><b>MSK_getobjsense</b></a>
<br/>Gets the objective sense. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getprobtype"><b>MSK_getprobtype</b></a>
<br/>Obtains the problem type. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqconk"><b>MSK_getqconk</b></a>
<br/>Obtains all the quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqconk64"><b>MSK_getqconk64</b></a>
<br/>Obtains all the quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj"><b>MSK_getqobj</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj64"><b>MSK_getqobj64</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobjij"><b>MSK_getqobjij</b></a>
<br/>Obtains one coefficient from the quadratic term of the objective </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvartype"><b>MSK_getvartype</b></a>
<br/>Gets the variable type of one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvartypelist"><b>MSK_getvartypelist</b></a>
<br/>Obtains the variable type for one or more variables. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274409736">15.2.10. Conic constraints</a></h2>

<p> Functionality related to conic terms in the problem. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*appendcone"><b>MSK_appendcone</b></a>
<br/>Appends a new cone constraint to the problem. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcone"><b>MSK_getcone</b></a>
<br/>Obtains a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getconeinfo"><b>MSK_getconeinfo</b></a>
<br/>Obtains information about a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumcone"><b>MSK_getnumcone</b></a>
<br/>Obtains the number of cones. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcone"><b>MSK_putcone</b></a>
<br/>Replaces a conic constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*removecone"><b>MSK_removecone</b></a>
<br/>Removes a conic constraint from the problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274411744">15.2.11. Bounds</a></h2>

<p> Functionality related to changing or inspecting bounds on variables or constraints. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*chgbound"><b>MSK_chgbound</b></a>
<br/>Changes the bounds for one constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getbound"><b>MSK_getbound</b></a>
<br/>Obtains bound information for one constraint or variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getboundslice"><b>MSK_getboundslice</b></a>
<br/>Obtains bounds information for a sequence of variables or constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putbound"><b>MSK_putbound</b></a>
<br/>Changes the bound for either one constraint or one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putboundlist"><b>MSK_putboundlist</b></a>
<br/>Changes the bounds of constraints or variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putboundslice"><b>MSK_putboundslice</b></a>
<br/>Modifies bounds. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274413688">15.2.12. Task initialization and deletion</a></h2>

<p> Task initialization and deletion. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*deletetask"><b>MSK_deletetask</b></a>
<br/>Deletes an optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*makeemptytask"><b>MSK_makeemptytask</b></a>
<br/>Creates a new and empty optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*maketask"><b>MSK_maketask</b></a>
<br/>Creates a new optimization task. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274414984">15.2.13. Error handling</a></h2>

<p> Error handling. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*exceptiontask"><b>MSK_exceptiontask</b></a>
<br/>Echo a response code to a task stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*getcodedesc"><b>MSK_getcodedesc</b></a>
<br/>Obtains a short description of a response code. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*getcodedisc"><b>MSK_getcodedisc</b></a>
<br/>Obtains a short description of a response code. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*getresponseclass"><b>MSK_getresponseclass</b></a>
<br/>Obtain the class of a response code. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putresponsefunc"><b>MSK_putresponsefunc</b></a>
<br/>Inputs a user-defined error call-back function. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274416776">15.2.14. Output stream functions</a></h2>

<p> Output stream functions. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*echoenv"><b>MSK_echoenv</b></a>
<br/>Sends a message to a given environment stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*echointro"><b>MSK_echointro</b></a>
<br/>Prints an intro to message stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*echotask"><b>MSK_echotask</b></a>
<br/>Prints a format string to a task stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*exceptiontask"><b>MSK_exceptiontask</b></a>
<br/>Echo a response code to a task stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*linkfiletoenvstream"><b>MSK_linkfiletoenvstream</b></a>
<br/>Directs all output from a stream to a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*linkfiletotaskstream"><b>MSK_linkfiletotaskstream</b></a>
<br/>Directs all output from a task stream to a file. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*linkfunctoenvstream"><b>MSK_linkfunctoenvstream</b></a>
<br/>Connects a user-defined function to a stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*linkfunctotaskstream"><b>MSK_linkfunctotaskstream</b></a>
<br/>Connects a user-defined function to a task stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*optimizersummary"><b>MSK_optimizersummary</b></a>
<br/>Prints a short summary with optimizer statistics for last optimization. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*printdata"><b>MSK_printdata</b></a>
<br/>Prints a part of the problem data to a stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*printparam"><b>MSK_printparam</b></a>
<br/>Prints the current parameter settings. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*readsummary"><b>MSK_readsummary</b></a>
<br/>Prints information about last file read. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solutionsummary"><b>MSK_solutionsummary</b></a>
<br/>Prints a short summary of the current solutions. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*unlinkfuncfromenvstream"><b>MSK_unlinkfuncfromenvstream</b></a>
<br/>Disconnects a user-defined function from a stream. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*unlinkfuncfromtaskstream"><b>MSK_unlinkfuncfromtaskstream</b></a>
<br/>Disconnects a user-defined function from a task stream. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274420728">15.2.15. Objective function</a></h2>

<p> Change or inspect objective function. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getc"><b>MSK_getc</b></a>
<br/>Obtains all objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcfix"><b>MSK_getcfix</b></a>
<br/>Obtains the fixed term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getcslice"><b>MSK_getcslice</b></a>
<br/>Obtains a sequence of coefficients from the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdualobj"><b>MSK_getdualobj</b></a>
<br/>Obtains the dual objective value. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqobjnz"><b>MSK_getnumqobjnz</b></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumqobjnz64"><b>MSK_getnumqobjnz64</b></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjname"><b>MSK_getobjname</b></a>
<br/>Obtains the name assigned to the objective function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjname64"><b>MSK_getobjname64</b></a>
<br/>Obtains the name assigned to the objective function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjsense"><b>MSK_getobjsense</b></a>
<br/>Gets the objective sense. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getprimalobj"><b>MSK_getprimalobj</b></a>
<br/>Obtains the primal objective value. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj"><b>MSK_getqobj</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj64"><b>MSK_getqobj64</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobjij"><b>MSK_getqobjij</b></a>
<br/>Obtains one coefficient from the quadratic term of the objective </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcfix"><b>MSK_putcfix</b></a>
<br/>Replaces the fixed term in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putcj"><b>MSK_putcj</b></a>
<br/>Modifies one linear coefficient in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putclist"><b>MSK_putclist</b></a>
<br/>Modifies a part of the linear objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putobjsense"><b>MSK_putobjsense</b></a>
<br/>Sets the objective sense. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobj"><b>MSK_putqobj</b></a>
<br/>Replaces all quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobjij"><b>MSK_putqobjij</b></a>
<br/>Replaces one coefficient in the quadratic term in the objective. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274425544">15.2.16. Optimizer statistics</a></h2>

<p> Inspect statistics from the optimizer. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdouinf"><b>MSK_getdouinf</b></a>
<br/>Obtains a double information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getinfindex"><b>MSK_getinfindex</b></a>
<br/>Obtains the index of a named information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getinfmax"><b>MSK_getinfmax</b></a>
<br/>Obtains the maximum index of an information of a given type inftype plus 1. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getinfname"><b>MSK_getinfname</b></a>
<br/>Obtains the name of an information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getintinf"><b>MSK_getintinf</b></a>
<br/>Obtains an integer information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getlintinf"><b>MSK_getlintinf</b></a>
<br/>Obtains an integer information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnadouinf"><b>MSK_getnadouinf</b></a>
<br/>Obtains a double information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnaintinf"><b>MSK_getnaintinf</b></a>
<br/>Obtains an integer information item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnaintparam"><b>MSK_getnaintparam</b></a>
<br/>Obtains an integer parameter. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274428200">15.2.17. Parameters (set/get)</a></h2>

<p> Setting and inspecting solver parameters. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getdouparam"><b>MSK_getdouparam</b></a>
<br/>Obtains a double parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getintparam"><b>MSK_getintparam</b></a>
<br/>Obtains an integer parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnadouparam"><b>MSK_getnadouparam</b></a>
<br/>Obtains a double parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnastrparam"><b>MSK_getnastrparam</b></a>
<br/>Obtains a string parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnastrparamal"><b>MSK_getnastrparamal</b></a>
<br/>Obtains the value of a string parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumparam"><b>MSK_getnumparam</b></a>
<br/>Obtains the number of parameters of a given type. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getparammax"><b>MSK_getparammax</b></a>
<br/>Obtains the maximum index of a parameter of a given type plus 1. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getparamname"><b>MSK_getparamname</b></a>
<br/>Obtains the name of a parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getstrparam"><b>MSK_getstrparam</b></a>
<br/>Obtains the value of a string parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getstrparam64"><b>MSK_getstrparam64</b></a>
<br/>Obtains the value of a string parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getstrparamal"><b>MSK_getstrparamal</b></a>
<br/>Obtains the value a string parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*getsymbcondim"><b>MSK_getsymbcondim</b></a>
<br/>Obtains dimensional information for the defined symbolic constants. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*iparvaltosymnam"><b>MSK_iparvaltosymnam</b></a>
<br/>Obtains the symbolic name corresponding to a value that can be assigned to an integer parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*isdouparname"><b>MSK_isdouparname</b></a>
<br/>Checks a double parameter name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*isintparname"><b>MSK_isintparname</b></a>
<br/>Checks an integer parameter name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*isstrparname"><b>MSK_isstrparname</b></a>
<br/>Checks a string parameter name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putdouparam"><b>MSK_putdouparam</b></a>
<br/>Sets a double parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putintparam"><b>MSK_putintparam</b></a>
<br/>Sets an integer parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putnadouparam"><b>MSK_putnadouparam</b></a>
<br/>Sets a double parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putnaintparam"><b>MSK_putnaintparam</b></a>
<br/>Sets an integer parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putnastrparam"><b>MSK_putnastrparam</b></a>
<br/>Sets a string parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putparam"><b>MSK_putparam</b></a>
<br/>Modifies the value of parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putstrparam"><b>MSK_putstrparam</b></a>
<br/>Sets a string parameter. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*setdefaults"><b>MSK_setdefaults</b></a>
<br/>Resets all parameters values. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*symnamtovalue"><b>MSK_symnamtovalue</b></a>
<br/>Obtains the value corresponding to a symbolic name defined by MOSEK. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*whichparam"><b>MSK_whichparam</b></a>
<br/>Checks a parameter name. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274434528">15.2.18. Naming</a></h2>

<p> Functionality related to naming. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getconname"><b>MSK_getconname</b></a>
<br/>Obtains a name of a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getconname64"><b>MSK_getconname64</b></a>
<br/>Obtains a name of a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnamelen"><b>MSK_getmaxnamelen</b></a>
<br/>Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getname"><b>MSK_getname</b></a>
<br/>Obtains the name of a cone, a variable or a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getname64"><b>MSK_getname64</b></a>
<br/>Obtains the name of a cone, a variable or a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnameapi64"><b>MSK_getnameapi64</b></a>
<br/>Obtains the name of a cone, a variable or a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnameindex"><b>MSK_getnameindex</b></a>
<br/>Checks whether a name has been assigned and returns the index corresponding to the name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnamelen64"><b>MSK_getnamelen64</b></a>
<br/>Obtains the length of a problem item name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjname"><b>MSK_getobjname</b></a>
<br/>Obtains the name assigned to the objective function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getobjname64"><b>MSK_getobjname64</b></a>
<br/>Obtains the name assigned to the objective function. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*gettaskname"><b>MSK_gettaskname</b></a>
<br/>Obtains the task name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*gettaskname64"><b>MSK_gettaskname64</b></a>
<br/>Obtains the task name. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvarname"><b>MSK_getvarname</b></a>
<br/>Obtains a name of a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvarname64"><b>MSK_getvarname64</b></a>
<br/>Obtains a name of a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putname"><b>MSK_putname</b></a>
<br/>Assigns a name to a problem item. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putobjname"><b>MSK_putobjname</b></a>
<br/>Assigns a new name to the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*puttaskname"><b>MSK_puttaskname</b></a>
<br/>Assigns a new name to the task. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274438912">15.2.19. Preallocating space for problem data</a></h2>

<p> Functionality related to preallocating space for problem data. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumanz"><b>MSK_getmaxnumanz</b></a>
<br/>Obtains number of preallocated non-zeros in the linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumanz64"><b>MSK_getmaxnumanz64</b></a>
<br/>Obtains number of preallocated non-zeros in the linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumcon"><b>MSK_getmaxnumcon</b></a>
<br/>Obtains the number of preallocated constraints in the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumcone"><b>MSK_getmaxnumcone</b></a>
<br/>Obtains the number of preallocated cones in the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumqnz"><b>MSK_getmaxnumqnz</b></a>
<br/>Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumqnz64"><b>MSK_getmaxnumqnz64</b></a>
<br/>Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getmaxnumvar"><b>MSK_getmaxnumvar</b></a>
<br/>Obtains the maximum number variables allowed. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumanz"><b>MSK_putmaxnumanz</b></a>
<br/>The function changes the size of the preallocated storage for linear coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumanz64"><b>MSK_putmaxnumanz64</b></a>
<br/>The function changes the size of the preallocated storage for linear coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumcon"><b>MSK_putmaxnumcon</b></a>
<br/>Sets the number of preallocated constraints in the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumcone"><b>MSK_putmaxnumcone</b></a>
<br/>Sets the number of preallocated conic constraints in the optimization task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><b>MSK_putmaxnumqnz</b></a>
<br/>Changes the size of the preallocated storage for quadratic terms. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumqnz64"><b>MSK_putmaxnumqnz64</b></a>
<br/>Changes the size of the preallocated storage for quadratic terms. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putmaxnumvar"><b>MSK_putmaxnumvar</b></a>
<br/>Sets the number of preallocated variables in the optimization task. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274442648">15.2.20. Integer variables</a></h2>

<p> Functionality related to integer variables. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getnumintvar"><b>MSK_getnumintvar</b></a>
<br/>Obtains the number of integer-constrained variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvarbranchdir"><b>MSK_getvarbranchdir</b></a>
<br/>Obtains the branching direction for a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvarbranchorder"><b>MSK_getvarbranchorder</b></a>
<br/>Obtains the branching priority for a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvarbranchpri"><b>MSK_getvarbranchpri</b></a>
<br/>Obtains the branching priority for a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvartype"><b>MSK_getvartype</b></a>
<br/>Gets the variable type of one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getvartypelist"><b>MSK_getvartypelist</b></a>
<br/>Obtains the variable type for one or more variables. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvarbranchorder"><b>MSK_putvarbranchorder</b></a>
<br/>Assigns a branching priority and direction to a variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvartype"><b>MSK_putvartype</b></a>
<br/>Sets the variable type of one variable. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putvartypelist"><b>MSK_putvartypelist</b></a>
<br/>Sets the variable type for one or more variables. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274445304">15.2.21. Quadratic terms</a></h2>

<p> Functionality related to quadratic terms. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqconk"><b>MSK_getqconk</b></a>
<br/>Obtains all the quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqconk64"><b>MSK_getqconk64</b></a>
<br/>Obtains all the quadratic terms in a constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj"><b>MSK_getqobj</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobj64"><b>MSK_getqobj64</b></a>
<br/>Obtains all the quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getqobjij"><b>MSK_getqobjij</b></a>
<br/>Obtains one coefficient from the quadratic term of the objective </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqcon"><b>MSK_putqcon</b></a>
<br/>Replaces all quadratic terms in constraints. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqconk"><b>MSK_putqconk</b></a>
<br/>Replaces all quadratic terms in a single constraint. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobj"><b>MSK_putqobj</b></a>
<br/>Replaces all quadratic terms in the objective. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putqobjij"><b>MSK_putqobjij</b></a>
<br/>Replaces one coefficient in the quadratic term in the objective. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274447896">15.2.22. Diagnosing infeasibility</a></h2>

<p> Functions for diagnosing infeasibility. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*getinfeasiblesubproblem"><b>MSK_getinfeasiblesubproblem</b></a>
<br/>Obtains an infeasible sub problem. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*relaxprimal"><b>MSK_relaxprimal</b></a>
<br/>Creates a problem that finds the minimal change to the bounds that makes an infeasible problem feasible. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274449040">15.2.23. Optimization</a></h2>

<p> Functions for optimization. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*checkdata"><b>MSK_checkdata</b></a>
<br/>Checks data of the task. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*netoptimize"><b>MSK_netoptimize</b></a>
<br/>Optimizes a pure network flow problem. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*optimize"><b>MSK_optimize</b></a>
<br/>Optimizes the problem. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*optimizeconcurrent"><b>MSK_optimizeconcurrent</b></a>
<br/>Optimize a given task with several optimizers concurrently. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*optimizetrm"><b>MSK_optimizetrm</b></a>
<br/>Optimizes the problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274450768">15.2.24. Network optimization</a></h2>

<p> Functions for network optimization. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*netextraction"><b>MSK_netextraction</b></a>
<br/>Finds embedded network structure. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*netoptimize"><b>MSK_netoptimize</b></a>
<br/>Optimizes a pure network flow problem. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274451848">15.2.25. Sensitivity analysis</a></h2>

<p> Functions for sensitivity analysis. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*dualsensitivity"><b>MSK_dualsensitivity</b></a>
<br/>Performs sensitivity analysis on objective coefficients. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*primalsensitivity"><b>MSK_primalsensitivity</b></a>
<br/>Perform sensitivity analysis on bounds. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*sensitivityreport"><b>MSK_sensitivityreport</b></a>
<br/>Creates a sensitivity report. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274453208">15.2.26. Testing data validity</a></h2>

<p> Functions for testing data validity. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*checkconvexity"><b>MSK_checkconvexity</b></a>
<br/>Checks if a quadratic optimization problem is convex. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274454072">15.2.27. Solving with the basis</a></h2>

<p> Functions for solving linear systems with the basis matrix. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*basiscond"><b>MSK_basiscond</b></a>
<br/>Computes conditioning information for the basis matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*initbasissolve"><b>MSK_initbasissolve</b></a>
<br/>Prepare a task for basis solver. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*solvewithbasis"><b>MSK_solvewithbasis</b></a>
<br/>Solve a linear equation system involving a basis matrix. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274455368">15.2.28. Initialization of environment</a></h2>

<p> Creation and initialization of environment. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*checkinlicense"><b>MSK_checkinlicense</b></a>
<br/>Check in a license feature from the license server ahead of time. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*deleteenv"><b>MSK_deleteenv</b></a>
<br/>Delete a MOSEK environment. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*initenv"><b>MSK_initenv</b></a>
<br/>Initialize a MOSEK environment. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*makeenv"><b>MSK_makeenv</b></a>
<br/>Creates a new MOSEK environment. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*putlicensedefaults"><b>MSK_putlicensedefaults</b></a>
<br/>Set defaults used by the license manager. </p>
</dd>
</dl>

</div>

<div>
<h2><a name="274457160">15.2.29. Change <span class="math"><span class="mi">A</span></span></a></h2>

<p> Change elements in the coefficient (<span class="math"><span class="mi">A</span></span>) matrix. </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*env*checkoutlicense"><b>MSK_checkoutlicense</b></a>
<br/>Check out a license feature from the license server ahead of time. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*commitchanges"><b>MSK_commitchanges</b></a>
<br/>Commits all cached problem changes. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaij"><b>MSK_putaij</b></a>
<br/>Changes a single value in the linear coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaijlist"><b>MSK_putaijlist</b></a>
<br/>Changes one or more coefficients in the linear constraint matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putavec"><b>MSK_putavec</b></a>
<br/>Replaces all elements in one row or column of the linear coefficient matrix. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaveclist"><b>MSK_putaveclist</b></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node017.html#common-func*mosek*task*putaveclist64"><b>MSK_putaveclist64</b></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </p>
</dd>
</dl>

</div>

</div>

<div>
<h1><a name="274459824">15.3. Mosek Env</a></h1>

<p><a name="apiclass*mosek*env">&#09;</a><a name="common-apiclass*mosek*env"></a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A Mosek Environment</p>
</dd>
</dl>

<div>
<h2><a name="274460256">15.3.1. Methods</a></h2>

<ul class="itemize">
<li><a href="node017.html#common-func*mosek*env*callocdbgenv"><tt class="tt">MSK_callocdbgenv</tt></a>
<br/>A replacement for the system calloc function. </li>
<li><a href="node017.html#common-func*mosek*env*callocenv"><tt class="tt">MSK_callocenv</tt></a>
<br/>A replacement for the system calloc function. </li>
<li><a href="node017.html#common-func*mosek*env*checkinlicense"><tt class="tt">MSK_checkinlicense</tt></a>
<br/>Check in a license feature from the license server ahead of time. </li>
<li><a href="node017.html#common-func*mosek*env*checkmemenv"><tt class="tt">MSK_checkmemenv</tt></a>
<br/>Checks the memory allocated by the environment. </li>
<li><a href="node017.html#common-func*mosek*env*checkoutlicense"><tt class="tt">MSK_checkoutlicense</tt></a>
<br/>Check out a license feature from the license server ahead of time. </li>
<li><a href="node017.html#common-func*mosek*env*checkversion"><tt class="tt">MSK_checkversion</tt></a>
<br/>Compares a version of the MOSEK DLL with a specified version. </li>
<li><a href="node017.html#common-func*mosek*env*deleteenv"><tt class="tt">MSK_deleteenv</tt></a>
<br/>Delete a MOSEK environment. </li>
<li><a href="node017.html#common-func*mosek*env*echoenv"><tt class="tt">MSK_echoenv</tt></a>
<br/>Sends a message to a given environment stream. </li>
<li><a href="node017.html#common-func*mosek*env*echointro"><tt class="tt">MSK_echointro</tt></a>
<br/>Prints an intro to message stream. </li>
<li><a href="node017.html#common-func*mosek*env*freedbgenv"><tt class="tt">MSK_freedbgenv</tt></a>
<br/>Frees space allocated by MOSEK. </li>
<li><a href="node017.html#common-func*mosek*env*freeenv"><tt class="tt">MSK_freeenv</tt></a>
<br/>Frees space allocated by MOSEK. </li>
<li><a href="node017.html#common-func*mosek*env*getbuildinfo"><tt class="tt">MSK_getbuildinfo</tt></a>
<br/>Obtains build information. </li>
<li><a href="node017.html#common-func*mosek*env*getcodedesc"><tt class="tt">MSK_getcodedesc</tt></a>
<br/>Obtains a short description of a response code. </li>
<li><a href="node017.html#common-func*mosek*env*getcodedisc"><tt class="tt">MSK_getcodedisc</tt></a>
<br/>Obtains a short description of a response code. </li>
<li><a href="node017.html#common-func*mosek*env*getglbdllname"><tt class="tt">MSK_getglbdllname</tt></a>
<br/>Obtains the name of the global optimizer DLL. </li>
<li><a href="node017.html#common-func*mosek*env*getresponseclass"><tt class="tt">MSK_getresponseclass</tt></a>
<br/>Obtain the class of a response code. </li>
<li><a href="node017.html#common-func*mosek*env*getsymbcondim"><tt class="tt">MSK_getsymbcondim</tt></a>
<br/>Obtains dimensional information for the defined symbolic constants. </li>
<li><a href="node017.html#common-func*mosek*env*getversion"><tt class="tt">MSK_getversion</tt></a>
<br/>Obtains MOSEK version information. </li>
<li><a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">MSK_initenv</tt></a>
<br/>Initialize a MOSEK environment. </li>
<li><a href="node017.html#common-func*mosek*env*iparvaltosymnam"><tt class="tt">MSK_iparvaltosymnam</tt></a>
<br/>Obtains the symbolic name corresponding to a value that can be assigned to an integer parameter. </li>
<li><a href="node017.html#common-func*mosek*env*isinfinity"><tt class="tt">MSK_isinfinity</tt></a>
<br/>Return true if value considered infinity by MOSEK. </li>
<li><a href="node017.html#common-func*mosek*env*linkfiletoenvstream"><tt class="tt">MSK_linkfiletoenvstream</tt></a>
<br/>Directs all output from a stream to a file. </li>
<li><a href="node017.html#common-func*mosek*env*linkfunctoenvstream"><tt class="tt">MSK_linkfunctoenvstream</tt></a>
<br/>Connects a user-defined function to a stream. </li>
<li><a href="node017.html#common-func*mosek*env*makeemptytask"><tt class="tt">MSK_makeemptytask</tt></a>
<br/>Creates a new and empty optimization task. </li>
<li><a href="node017.html#common-func*mosek*env*makeenv"><tt class="tt">MSK_makeenv</tt></a>
<br/>Creates a new MOSEK environment. </li>
<li><a href="node017.html#common-func*mosek*env*maketask"><tt class="tt">MSK_maketask</tt></a>
<br/>Creates a new optimization task. </li>
<li><a href="node017.html#common-func*mosek*env*putcpudefaults"><tt class="tt">MSK_putcpudefaults</tt></a>
<br/>Set defaults default CPU type and cache sizes. </li>
<li><a href="node017.html#common-func*mosek*env*putdllpath"><tt class="tt">MSK_putdllpath</tt></a>
<br/>Sets the path to the DLL/shared libraries that MOSEK is loading. </li>
<li><a href="node017.html#common-func*mosek*env*putexitfunc"><tt class="tt">MSK_putexitfunc</tt></a>
<br/>Inputs a user-defined exit function which is called in case of fatal errors. </li>
<li><a href="node017.html#common-func*mosek*env*putkeepdlls"><tt class="tt">MSK_putkeepdlls</tt></a>
<br/>Controls whether explicitly loaded DLLs should be kept. </li>
<li><a href="node017.html#common-func*mosek*env*putlicensedefaults"><tt class="tt">MSK_putlicensedefaults</tt></a>
<br/>Set defaults used by the license manager. </li>
<li><a href="node017.html#common-func*mosek*env*replacefileext"><tt class="tt">MSK_replacefileext</tt></a>
<br/>Replaces the extension of a file by a new one. </li>
<li><a href="node017.html#common-func*mosek*env*strdupdbgenv"><tt class="tt">MSK_strdupdbgenv</tt></a>
<br/>Make a copy of a string. </li>
<li><a href="node017.html#common-func*mosek*env*strdupenv"><tt class="tt">MSK_strdupenv</tt></a>
<br/>Make a copy of a string. </li>
<li><a href="node017.html#common-func*mosek*env*symnamtovalue"><tt class="tt">MSK_symnamtovalue</tt></a>
<br/>Obtains the value corresponding to a symbolic name defined by MOSEK. </li>
<li><a href="node017.html#common-func*mosek*env*unlinkfuncfromenvstream"><tt class="tt">MSK_unlinkfuncfromenvstream</tt></a>
<br/>Disconnects a user-defined function from a stream. </li>
<li><a href="node017.html#common-func*mosek*env*utf8towchar"><tt class="tt">MSK_utf8towchar</tt></a>
<br/>Converts an UTF8 string to a wchar string. </li>
<li><a href="node017.html#common-func*mosek*env*wchartoutf8"><tt class="tt">MSK_wchartoutf8</tt></a>
<br/>Converts a wchar string to an UTF8 string. </li>
</ul>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">MSK_callocdbgenv</tt></span>

<p> <a name="func*mosek*env*callocdbgenv">&#09;</a><a name="common-func*mosek*env*callocdbgenv"></a> <a name="idx-106574768">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">void * MSK_callocdbgenv (
    MSKenv_t env,
    MSKCONST size_t number,
    MSKCONST size_t size,
    MSKCONST char * file,
    MSKCONST unsigned line);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">number</tt> (input)</dt>
<dd>Number of elements.</dd>
<dt><tt class="tt">size</tt> (input)</dt>
<dd>Size of each individual element.</dd>
<dt><tt class="tt">file</tt> (input)</dt>
<dd>File from which the function is called.</dd>
<dt><tt class="tt">line</tt> (input)</dt>
<dd>Line in the file from which the function is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Debug version of <a href="node017.html#common-func*mosek*env*callocenv"><tt class="tt">MSK_callocenv</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_callocenv</tt></span>

<p> <a name="func*mosek*env*callocenv">&#09;</a><a name="common-func*mosek*env*callocenv"></a> <a name="idx-106596328">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">void * MSK_callocenv (
    MSKenv_t env,
    MSKCONST size_t number,
    MSKCONST size_t size);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">number</tt> (input)</dt>
<dd>Number of elements.</dd>
<dt><tt class="tt">size</tt> (input)</dt>
<dd>Size of each individual element.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Equivalent to <tt class="tt">calloc</tt> i.e. allocate space for an array of length number where each element is of size <tt class="tt">size</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_checkinlicense</tt></span>

<p> <a name="func*mosek*env*checkinlicense">&#09;</a><a name="common-func*mosek*env*checkinlicense"></a> <a name="idx-106608400">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_checkinlicense (
    MSKenv_t env,
    MSKfeaturee feature);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><a href="node020.html#common-constclass*mosek*feature"><tt class="tt">feature</tt></a> (input)</dt>
<dd>Feature to check in to the license system.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Check in a license feature to the license server. By default all licenses consumed by functions using a single environment is kept checked out for the lifetime of the MOSEK environment. This function checks in a given license feature to the license server immidiatly.</p>

<p>If the given license feature is not checked out or is in use by a call to <a href="node017.html#common-func*mosek*task*optimizetrm"><tt class="tt">MSK_optimizetrm</tt></a> calling this function has no effect.</p>

<p>Please note that returning a license to the license server incurs a small overhead, so frequent calls to this function should be avoided.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_checkmemenv</tt></span>

<p> <a name="func*mosek*env*checkmemenv">&#09;</a><a name="common-func*mosek*env*checkmemenv"></a> <a name="idx-106604448">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_checkmemenv (
    MSKenv_t env,
    MSKCONST char * file,
    MSKintt line);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">file</tt> (input)</dt>
<dd>File from which the function is called.</dd>
<dt><tt class="tt">line</tt> (input)</dt>
<dd>Line in the file from which the function is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks the memory allocated by the environment.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_checkoutlicense</tt></span>

<p> <a name="func*mosek*env*checkoutlicense">&#09;</a><a name="common-func*mosek*env*checkoutlicense"></a> <a name="idx-106630104">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_checkoutlicense (
    MSKenv_t env,
    MSKfeaturee feature);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><a href="node020.html#common-constclass*mosek*feature"><tt class="tt">feature</tt></a> (input)</dt>
<dd>Feature to check out from the license system.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Check out a license feature from the license server. Normally the required license features will be automatically checked out the first time it is needed by the function <a href="node017.html#common-func*mosek*task*optimizetrm"><tt class="tt">MSK_optimizetrm</tt></a>. This function can be used to check out one or more features ahead of time.</p>

<p>The license will remain checked out until the environment is deleted with <a href="node017.html#common-func*mosek*env*deleteenv"><tt class="tt">MSK_deleteenv</tt></a> or the function <a href="node017.html#common-func*mosek*env*checkinlicense"><tt class="tt">MSK_checkinlicense</tt></a> is called.</p>

<p>If a given feature is already checked out when this function is called, only one feature will be checked out from the license server.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_checkversion</tt></span>

<p> <a name="func*mosek*env*checkversion">&#09;</a><a name="common-func*mosek*env*checkversion"></a> <a name="idx-106654608">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_checkversion (
    MSKenv_t env,
    MSKintt major,
    MSKintt minor,
    MSKintt build,
    MSKintt revision);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">major</tt> (input)</dt>
<dd>Major version number.</dd>
<dt><tt class="tt">minor</tt> (input)</dt>
<dd>Minor version number.</dd>
<dt><tt class="tt">build</tt> (input)</dt>
<dd>Build number.</dd>
<dt><tt class="tt">revision</tt> (input)</dt>
<dd>Revision number.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Compares the version of the MOSEK DLL with a specified version. Normally the specified version is the version at the build time.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_deleteenv</tt></span>

<p> <a name="func*mosek*env*deleteenv">&#09;</a><a name="common-func*mosek*env*deleteenv"></a> <a name="idx-106658416">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_deleteenv (MSKenv_t * env)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input/output)</dt>
<dd>The MOSEK environment.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Deletes a MOSEK environment and all the data associated with it.</p>

<p>Before calling this function it is a good idea to call the function <a href="node017.html#common-func*mosek*env*unlinkfuncfromenvstream"><tt class="tt">MSK_unlinkfuncfromenvstream</tt></a> for each stream that has have had function linked to it.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_echoenv</tt></span>

<p> <a name="func*mosek*env*echoenv">&#09;</a><a name="common-func*mosek*env*echoenv"></a> <a name="idx-106682272">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_echoenv (
    MSKenv_t env,
    MSKstreamtypee whichstream,
    MSKCONST char * format,
    ...);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">format</tt> (input)</dt>
<dd>Is a valid C format string which matches the arguments in `<tt class="tt">...</tt>'.</dd>
<dt><tt class="tt">varnumarg</tt> (input)</dt>
<dd>A variable argument list.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sends a message to a given environment stream.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_echointro</tt></span>

<p> <a name="func*mosek*env*echointro">&#09;</a><a name="common-func*mosek*env*echointro"></a> <a name="idx-106671352">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_echointro (
    MSKenv_t env,
    MSKintt longver);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">longver</tt> (input)</dt>
<dd>If non-zero, then the intro is slightly longer.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints an intro to message stream.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_freedbgenv</tt></span>

<p> <a name="func*mosek*env*freedbgenv">&#09;</a><a name="common-func*mosek*env*freedbgenv"></a> <a name="idx-106704624">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">void MSK_freedbgenv (
    MSKenv_t env,
    MSKCONST void * buffer,
    MSKCONST char * file,
    MSKCONST unsigned line);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">buffer</tt> (input)</dt>
<dd>A pointer.</dd>
<dt><tt class="tt">file</tt> (input)</dt>
<dd>File from which the function is called.</dd>
<dt><tt class="tt">line</tt> (input)</dt>
<dd>Line in the file from which the function is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Frees space allocated by a MOSEK function. Must not be applied to the MOSEK environment and task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_freeenv</tt></span>

<p> <a name="func*mosek*env*freeenv">&#09;</a><a name="common-func*mosek*env*freeenv"></a> <a name="idx-106682488">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">void MSK_freeenv (
    MSKenv_t env,
    MSKCONST void * buffer);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">buffer</tt> (input)</dt>
<dd>A pointer.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Frees space allocated by a MOSEK function. Must not be applied to the MOSEK environment and task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getbuildinfo</tt></span>

<p> <a name="func*mosek*env*getbuildinfo">&#09;</a><a name="common-func*mosek*env*getbuildinfo"></a> <a name="idx-106728696">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getbuildinfo (
    char * buildstate,
    char * builddate,
    char * buildtool);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">buildstate</tt> (output)</dt>
<dd>State of binaries, i.e. a debug, release candidate or final release.</dd>
<dt><tt class="tt">builddate</tt> (output)</dt>
<dd>Date when the binaries were build.</dd>
<dt><tt class="tt">buildtool</tt> (output)</dt>
<dd>Tool(s) used to build the binaries.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains build information.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getcodedesc</tt></span>

<p> <a name="func*mosek*env*getcodedesc">&#09;</a><a name="common-func*mosek*env*getcodedesc"></a> <a name="idx-106723736">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getcodedesc (
    MSKrescodee code,
    char * symname,
    char * str);
</pre>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">code</tt></a> (input)</dt>
<dd>A valid MOSEK response code.</dd>
<dt><tt class="tt">symname</tt> (output)</dt>
<dd>Symbolic name corresponding to <tt class="tt">code</tt>.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>Obtains a short description of a response code.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a short description of the meaning of the response code given by <tt class="tt">code</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getcodedisc</tt></span>

<p> <a name="func*mosek*env*getcodedisc">&#09;</a><a name="common-func*mosek*env*getcodedisc"></a> <a name="idx-108287544">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getcodedisc (
    MSKrescodee code,
    char * symname,
    char * str);
</pre>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">code</tt></a> (input)</dt>
<dd>A valid MOSEK response code.</dd>
<dt><tt class="tt">symname</tt> (output)</dt>
<dd>Symbolic name corresponding to <tt class="tt">code</tt>.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>Obtains a short description of a response code.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a short description of the meaning of the response code given by <tt class="tt">code</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getglbdllname</tt></span>

<p> <a name="func*mosek*env*getglbdllname">&#09;</a><a name="common-func*mosek*env*getglbdllname"></a> <a name="idx-108297680">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getglbdllname (
    MSKenv_t env,
    MSKCONST size_t sizedllname,
    char * dllname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">sizedllname</tt> (input)</dt>
<dd></dd>
<dt><tt class="tt">dllname</tt> (output)</dt>
<dd>The DLL name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name of the global optimizer DLL.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getresponseclass</tt></span>

<p> <a name="func*mosek*env*getresponseclass">&#09;</a><a name="common-func*mosek*env*getresponseclass"></a> <a name="idx-108313632">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getresponseclass (
    MSKrescodee r,
    MSKrescodetypee * rc);
</pre>

<dl class="funcargsdesc">
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">r</tt></a> (input)</dt>
<dd>A response code indicating the result of function call.</dd>
<dt><a href="node020.html#common-constclass*mosek*rescodetype"><tt class="tt">rc</tt></a> (output)</dt>
<dd>The return response class</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtain the class of a response code.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getsymbcondim</tt></span>

<p> <a name="func*mosek*env*getsymbcondim">&#09;</a><a name="common-func*mosek*env*getsymbcondim"></a> <a name="idx-108320528">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getsymbcondim (
    MSKenv_t env,
    MSKintt * num,
    size_t * maxlen);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">num</tt> (output)</dt>
<dd>Number of symbolic constants defined by MOSEK.</dd>
<dt><tt class="tt">maxlen</tt> (output)</dt>
<dd>Maximum length of the name of any symbolic constants.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of symbolic constants defined by MOSEK and the maximum length of the name of any symbolic constant.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getversion</tt></span>

<p> <a name="func*mosek*env*getversion">&#09;</a><a name="common-func*mosek*env*getversion"></a> <a name="idx-108332672">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getversion (
    MSKintt * major,
    MSKintt * minor,
    MSKintt * build,
    MSKintt * revision);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">major</tt> (output)</dt>
<dd>Major version number.</dd>
<dt><tt class="tt">minor</tt> (output)</dt>
<dd>Minor version number.</dd>
<dt><tt class="tt">build</tt> (output)</dt>
<dd>Build number.</dd>
<dt><tt class="tt">revision</tt> (output)</dt>
<dd>Revision number.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains MOSEK version information.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_initenv</tt></span>

<p> <a name="func*mosek*env*initenv">&#09;</a><a name="common-func*mosek*env*initenv"></a> <a name="idx-108338928">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_initenv (MSKenv_t env)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>This function initializes the MOSEK environment.  Among other things the license server will be contacted. Error messages from the license manager can be captured by linking to the environment message stream before calling this function.    </dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_iparvaltosymnam</tt></span>

<p> <a name="func*mosek*env*iparvaltosymnam">&#09;</a><a name="common-func*mosek*env*iparvaltosymnam"></a> <a name="idx-108351216">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_iparvaltosymnam (
    MSKenv_t env,
    MSKiparame whichparam,
    MSKintt whichvalue,
    char * symbolicname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">whichparam</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">whichvalue</tt> (input)</dt>
<dd>Which value.</dd>
<dt><tt class="tt">symbolicname</tt> (output)</dt>
<dd>The symbolic name corresponding to <tt class="tt">whichvalue</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the symbolic name corresponding to a value that can be assigned to an integer parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_isinfinity</tt></span>

<p> <a name="func*mosek*env*isinfinity">&#09;</a><a name="common-func*mosek*env*isinfinity"></a> <a name="idx-108362640">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKbooleant MSK_isinfinity (MSKrealt value)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">value</tt> </dt>
<dd></dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Return true if <tt class="tt">value</tt> considered infinity by MOSEK</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_linkfiletoenvstream</tt></span>

<p> <a name="func*mosek*env*linkfiletoenvstream">&#09;</a><a name="common-func*mosek*env*linkfiletoenvstream"></a> <a name="idx-108375504">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_linkfiletoenvstream (
    MSKenv_t env,
    MSKstreamtypee whichstream,
    MSKCONST char * filename,
    MSKintt append);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Sends all output from the stream defined by <tt class="tt">whichstream</tt> to the file given by <tt class="tt">filename</tt>.</dd>
<dt><tt class="tt">append</tt> (input)</dt>
<dd>If this argument is non-zero, the output is appended to the file.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Directs all output from a stream to a file.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_linkfunctoenvstream</tt></span>

<p> <a name="func*mosek*env*linkfunctoenvstream">&#09;</a><a name="common-func*mosek*env*linkfunctoenvstream"></a> <a name="idx-108386928">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_linkfunctoenvstream (
    MSKenv_t env,
    MSKstreamtypee whichstream,
    MSKuserhandle_t handle,
    MSKstreamfunc func);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">handle</tt> (input)</dt>
<dd>A user-defined handle which is passed to the user-defined function <tt class="tt">func</tt>.</dd>
<dt><tt class="tt">func</tt> (input)</dt>
<dd>All output to the stream <tt class="tt">whichstream</tt> is passed to <tt class="tt">func</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Connects a user-defined function to a stream.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_makeemptytask</tt></span>

<p> <a name="func*mosek*env*makeemptytask">&#09;</a><a name="common-func*mosek*env*makeemptytask"></a> <a name="idx-108372840">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_makeemptytask (
    MSKenv_t env,
    MSKtask_t * task);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">task</tt> (output)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Creates a new optimization task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_makeenv</tt></span>

<p> <a name="func*mosek*env*makeenv">&#09;</a><a name="common-func*mosek*env*makeenv"></a> <a name="idx-108412728">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_makeenv (
    MSKenv_t * env,
    MSKuserhandle_t usrptr,
    MSKmallocfunc usrmalloc,
    MSKfreefunc usrfree,
    MSKCONST char * dbgfile);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (output)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">usrptr</tt> (input)</dt>
<dd>A <tt class="tt">pointer</tt> to user-defined data structure. The pointer is feed into <tt class="tt">usrmalloc</tt> and <tt class="tt">usrfree</tt>.</dd>
<dt><tt class="tt">usrmalloc</tt> (input)</dt>
<dd>A user-defined <tt class="tt">malloc</tt> function or a <tt class="tt">NULL</tt> pointer.</dd>
<dt><tt class="tt">usrfree</tt> (input)</dt>
<dd>A user-defined <tt class="tt">free</tt> function which is used deallocate space allocated by <tt class="tt">usrmalloc</tt>. This function must be defined if <tt class="tt">usrmalloc!=NULL</tt>.</dd>
<dt><tt class="tt">dbgfile</tt> (input)</dt>
<dd>A user-defined file debug file.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Creates a new MOSEK environment. Before the created environment can be used to create a task, then the environment must be initialized using the function <a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">MSK_initenv</tt></a>.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">MSK_initenv</tt></a></dt>
<dd>
<p> Initialize a MOSEK environment.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*env*putdllpath"><tt class="tt">MSK_putdllpath</tt></a></dt>
<dd>
<p> Sets the path to the DLL/shared libraries that MOSEK is loading.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*env*putlicensedefaults"><tt class="tt">MSK_putlicensedefaults</tt></a></dt>
<dd>
<p> Set defaults used by the license manager.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*env*putcpudefaults"><tt class="tt">MSK_putcpudefaults</tt></a></dt>
<dd>
<p> Set defaults default CPU type and cache sizes.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_maketask</tt></span>

<p> <a name="func*mosek*env*maketask">&#09;</a><a name="common-func*mosek*env*maketask"></a> <a name="idx-108396488">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_maketask (
    MSKenv_t env,
    MSKintt maxnumcon,
    MSKintt maxnumvar,
    MSKtask_t * task);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>An optional estimate on the maximum number of constraints in the task. Can e.g be <span class="math"><span class="mn">0</span></span> if no such estimate is known.</dd>
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>An optional estimate on the maximum number of variables in the task. Can be <span class="math"><span class="mn">0</span></span> if no such estimate is known.</dd>
<dt><tt class="tt">task</tt> (output)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Creates a new task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putcpudefaults</tt></span>

<p> <a name="func*mosek*env*putcpudefaults">&#09;</a><a name="common-func*mosek*env*putcpudefaults"></a> <a name="idx-108460152">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putcpudefaults (
    MSKenv_t env,
    int cputype,
    MSKintt sizel1,
    MSKintt sizel2);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><a href="node020.html#common-constclass*mosek*cputype"><tt class="tt">cputype</tt></a> (input)</dt>
<dd>The CPU ID.</dd>
<dt><tt class="tt">sizel1</tt> (input)</dt>
<dd>Size of the L1 cache.</dd>
<dt><tt class="tt">sizel2</tt> (input)</dt>
<dd>Size of the L2 cache.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets default CPU type and cache sizes. This function should be called before <a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">MSK_initenv</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putdllpath</tt></span>

<p> <a name="func*mosek*env*putdllpath">&#09;</a><a name="common-func*mosek*env*putdllpath"></a> <a name="idx-108472080">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putdllpath (
    MSKenv_t env,
    MSKCONST char * dllpath);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">dllpath</tt> (input)</dt>
<dd>A path to where the MOSEK dynamic link/shared libraries are located. If <tt class="tt">dllpath</tt> is <tt class="tt">NULL</tt>, then MOSEK assumes that the operating system can locate the libraries.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the path to the DLL/shared libraries that MOSEK are loading. If needed, then it should normally be called before <a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">MSK_initenv</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putexitfunc</tt></span>

<p> <a name="func*mosek*env*putexitfunc">&#09;</a><a name="common-func*mosek*env*putexitfunc"></a> <a name="idx-108464176">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putexitfunc (
    MSKenv_t env,
    MSKexitfunc exitfunc,
    MSKuserhandle_t handle);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">exitfunc</tt> (input)</dt>
<dd>A user-defined exit function.</dd>
<dt><tt class="tt">handle</tt> (input)</dt>
<dd>A pointer to user-defined data structure which is passed to <tt class="tt">exitfunc</tt> when called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>In case MOSEK has a fatal error, then an exit function is called. The exit function should terminate MOSEK. In general it is not necessary to define an exit function.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putkeepdlls</tt></span>

<p> <a name="func*mosek*env*putkeepdlls">&#09;</a><a name="common-func*mosek*env*putkeepdlls"></a> <a name="idx-108498672">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putkeepdlls (
    MSKenv_t env,
    MSKintt keepdlls);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>Size of the L2 cache.</dd>
<dt><tt class="tt">keepdlls</tt> (input)</dt>
<dd>Controls whether explicitly loaded DLLs should be kept.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Controls whether explicitly loaded DLLs should be kept when they no longer are in use.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putlicensedefaults</tt></span>

<p> <a name="func*mosek*env*putlicensedefaults">&#09;</a><a name="common-func*mosek*env*putlicensedefaults"></a> <a name="idx-108487672">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putlicensedefaults (
    MSKenv_t env,
    MSKCONST char * licensefile,
    MSKCONST MSKintt * licensebuf,
    MSKintt licwait,
    MSKintt licdebug);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">licensefile</tt> (input)</dt>
<dd>Either <tt class="tt">NULL</tt> or the path to a valid MOSEK license file.</dd>
<dt><tt class="tt">licensebuf</tt> (input)</dt>
<dd>This is the license string authorizing the use of MOSEK in the runtime version of MOSEK. Therefore, most frequently this string is a NULL pointer.</dd>
<dt><tt class="tt">licwait</tt> (input)</dt>
<dd>If this argument is non-zero, then MOSEK will wait for a license if no license is available. Moreover, <tt class="tt">licwait-1</tt> is the number of milliseconds to wait between each check for an available license.</dd>
<dt><tt class="tt">licdebug</tt> (input)</dt>
<dd>If this argument is non-zero, then MOSEK will print debug info regarding the license checkout.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets default values for the license manager. This function should be called before <a href="node017.html#common-func*mosek*env*initenv"><tt class="tt">MSK_initenv</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_replacefileext</tt></span>

<p> <a name="func*mosek*env*replacefileext">&#09;</a><a name="common-func*mosek*env*replacefileext"></a> <a name="idx-108520152">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">void MSK_replacefileext (
    char * filename,
    MSKCONST char * newextension);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">filename</tt> (input/output)</dt>
<dd>The filename.</dd>
<dt><tt class="tt">newextension</tt> (input)</dt>
<dd>The new extension.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Replaces the file extension in a file name by a new one.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_strdupdbgenv</tt></span>

<p> <a name="func*mosek*env*strdupdbgenv">&#09;</a><a name="common-func*mosek*env*strdupdbgenv"></a> <a name="idx-110124496">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">char * MSK_strdupdbgenv (
    MSKenv_t env,
    MSKCONST char * str,
    MSKCONST char * file,
    MSKCONST unsigned line);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">str</tt> (input)</dt>
<dd>String that should be copied.</dd>
<dt><tt class="tt">file</tt> (input)</dt>
<dd>File from which the function is called.</dd>
<dt><tt class="tt">line</tt> (input)</dt>
<dd>Line in the file from which the function is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Make a copy of a string. The string created by this procedure must be freed by <a href="node017.html#common-func*mosek*env*freeenv"><tt class="tt">MSK_freeenv</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_strdupenv</tt></span>

<p> <a name="func*mosek*env*strdupenv">&#09;</a><a name="common-func*mosek*env*strdupenv"></a> <a name="idx-110129232">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">char * MSK_strdupenv (
    MSKenv_t env,
    MSKCONST char * str);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><tt class="tt">str</tt> (input)</dt>
<dd>String that should be copied.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Make a copy of a string. The string created by this procedure must be freed by <a href="node017.html#common-func*mosek*env*freeenv"><tt class="tt">MSK_freeenv</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_symnamtovalue</tt></span>

<p> <a name="func*mosek*env*symnamtovalue">&#09;</a><a name="common-func*mosek*env*symnamtovalue"></a> <a name="idx-110153456">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKbooleant MSK_symnamtovalue (
    MSKCONST char * name,
    char * value);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">name</tt> (input)</dt>
<dd>Symbolic name.</dd>
<dt><tt class="tt">value</tt> (output)</dt>
<dd>The corresponding value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value corresponding to a symbolic name defined by MOSEK.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_unlinkfuncfromenvstream</tt></span>

<p> <a name="func*mosek*env*unlinkfuncfromenvstream">&#09;</a><a name="common-func*mosek*env*unlinkfuncfromenvstream"></a> <a name="idx-110151152">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_unlinkfuncfromenvstream (
    MSKenv_t env,
    MSKstreamtypee whichstream);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">env</tt> (input)</dt>
<dd>The MOSEK environment.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Disconnects a user-defined function from a stream.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_utf8towchar</tt></span>

<p> <a name="func*mosek*env*utf8towchar">&#09;</a><a name="common-func*mosek*env*utf8towchar"></a> <a name="idx-110177024">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_utf8towchar (
    MSKCONST size_t outputlen,
    size_t * len,
    size_t * conv,
    MSKwchart * output,
    MSKCONST char * input);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">outputlen</tt> (input)</dt>
<dd>The length of the output buffer.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>The length of the string contained in the output buffer.</dd>
<dt><tt class="tt">conv</tt> (output)</dt>
<dd>Returns the number of characters from converted, i.e. <tt class="tt">input[conv]</tt> is the first char which was not converted. If the whole string was converted, then <tt class="tt">input[conv]=0</tt>.</dd>
<dt><tt class="tt">output</tt> (output)</dt>
<dd>The input string converted to a wchar string.</dd>
<dt><tt class="tt">input</tt> (input)</dt>
<dd>The UTF8 input string.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Converts an UTF8 string to a wchar string.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_wchartoutf8</tt></span>

<p> <a name="func*mosek*env*wchartoutf8">&#09;</a><a name="common-func*mosek*env*wchartoutf8"></a> <a name="idx-110142528">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_wchartoutf8 (
    MSKCONST size_t outputlen,
    size_t * len,
    size_t * conv,
    char * output,
    MSKCONST MSKwchart * input);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">outputlen</tt> (input)</dt>
<dd>The length of the output buffer.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>The length of the string contained in the output buffer.</dd>
<dt><tt class="tt">conv</tt> (output)</dt>
<dd>Returns the number of characters from converted, i.e. <tt class="tt">input[conv]</tt> is the first char which was not converted. If the whole string was converted, then <tt class="tt">input[conv]=0</tt>.</dd>
<dt><tt class="tt">output</tt> (output)</dt>
<dd>The input string converted to a wchar string.</dd>
<dt><tt class="tt">input</tt> (input)</dt>
<dd>The UTF8 input string.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Converts an UTF8 string to a wchar string.</dd>
</dl>
</li>
</ul>

</div>

</div>

<div>
<h1><a name="276790304">15.4. Mosek Task</a></h1>

<p><a name="apiclass*mosek*task">&#09;</a><a name="common-apiclass*mosek*task"></a> </p>

<dl class="description">
<dt>Description:</dt>
<dd>
<p>A Mosek Optimization task</p>
</dd>
</dl>

<div>
<h2><a name="274461040">15.4.1. Methods</a></h2>

<ul class="itemize">
<li><a href="node017.html#common-func*mosek*task*analyzeproblem"><tt class="tt">MSK_analyzeproblem</tt></a>
<br/>Analyze the data of a task. </li>
<li><a href="node017.html#common-func*mosek*task*analyzesolution"><tt class="tt">MSK_analyzesolution</tt></a>
<br/>Print information related to the quality of the solution. </li>
<li><a href="node017.html#common-func*mosek*task*append"><tt class="tt">MSK_append</tt></a>
<br/>Appends a number of variables or constraints to the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*appendcone"><tt class="tt">MSK_appendcone</tt></a>
<br/>Appends a new cone constraint to the problem. </li>
<li><a href="node017.html#common-func*mosek*task*basiscond"><tt class="tt">MSK_basiscond</tt></a>
<br/>Computes conditioning information for the basis matrix. </li>
<li><a href="node017.html#common-func*mosek*task*bktostr"><tt class="tt">MSK_bktostr</tt></a>
<br/>Obtains a bound key string identifier. </li>
<li><a href="node017.html#common-func*mosek*task*callbackcodetostr"><tt class="tt">MSK_callbackcodetostr</tt></a>
<br/>Obtains a call-back code string identifier. </li>
<li><a href="node017.html#common-func*mosek*task*callocdbgtask"><tt class="tt">MSK_callocdbgtask</tt></a>
<br/>A replacement for the system calloc function. </li>
<li><a href="node017.html#common-func*mosek*task*calloctask"><tt class="tt">MSK_calloctask</tt></a>
<br/>A replacement for the system calloc function. </li>
<li><a href="node017.html#common-func*mosek*task*checkconvexity"><tt class="tt">MSK_checkconvexity</tt></a>
<br/>Checks if a quadratic optimization problem is convex. </li>
<li><a href="node017.html#common-func*mosek*task*checkdata"><tt class="tt">MSK_checkdata</tt></a>
<br/>Checks data of the task. </li>
<li><a href="node017.html#common-func*mosek*task*checkmemtask"><tt class="tt">MSK_checkmemtask</tt></a>
<br/>Checks the memory allocated by the task. </li>
<li><a href="node017.html#common-func*mosek*task*chgbound"><tt class="tt">MSK_chgbound</tt></a>
<br/>Changes the bounds for one constraint or variable. </li>
<li><a href="node017.html#common-func*mosek*task*clonetask"><tt class="tt">MSK_clonetask</tt></a>
<br/>Creates a clone of an existing task. </li>
<li><a href="node017.html#common-func*mosek*task*commitchanges"><tt class="tt">MSK_commitchanges</tt></a>
<br/>Commits all cached problem changes. </li>
<li><a href="node017.html#common-func*mosek*task*conetypetostr"><tt class="tt">MSK_conetypetostr</tt></a>
<br/>Obtains a cone type string identifier. </li>
<li><a href="node017.html#common-func*mosek*task*deletesolution"><tt class="tt">MSK_deletesolution</tt></a>
<br/>Undefines a solution and frees the memory it uses. </li>
<li><a href="node017.html#common-func*mosek*task*deletetask"><tt class="tt">MSK_deletetask</tt></a>
<br/>Deletes an optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*dualsensitivity"><tt class="tt">MSK_dualsensitivity</tt></a>
<br/>Performs sensitivity analysis on objective coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*echotask"><tt class="tt">MSK_echotask</tt></a>
<br/>Prints a format string to a task stream. </li>
<li><a href="node017.html#common-func*mosek*task*exceptiontask"><tt class="tt">MSK_exceptiontask</tt></a>
<br/>Echo a response code to a task stream. </li>
<li><a href="node017.html#common-func*mosek*task*freedbgtask"><tt class="tt">MSK_freedbgtask</tt></a>
<br/>Frees space allocated by MOSEK. </li>
<li><a href="node017.html#common-func*mosek*task*freetask"><tt class="tt">MSK_freetask</tt></a>
<br/>Frees space allocated by MOSEK. </li>
<li><a href="node017.html#common-func*mosek*task*getaij"><tt class="tt">MSK_getaij</tt></a>
<br/>Obtains a single coefficient in linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getapiecenumnz"><tt class="tt">MSK_getapiecenumnz</tt></a>
<br/>Obtains the number non-zeros in a rectangular piece of the linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslice"><tt class="tt">MSK_getaslice</tt></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslice64"><tt class="tt">MSK_getaslice64</tt></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslicenumnz"><tt class="tt">MSK_getaslicenumnz</tt></a>
<br/>Obtains the number of non-zeros in a row or column slice of the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslicenumnz64"><tt class="tt">MSK_getaslicenumnz64</tt></a>
<br/>Obtains the number of non-zeros in a slice of rows or columns of the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getaslicetrip"><tt class="tt">MSK_getaslicetrip</tt></a>
<br/>Obtains a sequence of rows or columns from the coefficient matrix in triplet format. </li>
<li><a href="node017.html#common-func*mosek*task*getavec"><tt class="tt">MSK_getavec</tt></a>
<br/>Obtains one row or column of the linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getavecnumnz"><tt class="tt">MSK_getavecnumnz</tt></a>
<br/>Obtains the number of non-zero elements in one row or column of the linear constraint matrix </li>
<li><a href="node017.html#common-func*mosek*task*getbound"><tt class="tt">MSK_getbound</tt></a>
<br/>Obtains bound information for one constraint or variable. </li>
<li><a href="node017.html#common-func*mosek*task*getboundslice"><tt class="tt">MSK_getboundslice</tt></a>
<br/>Obtains bounds information for a sequence of variables or constraints. </li>
<li><a href="node017.html#common-func*mosek*task*getc"><tt class="tt">MSK_getc</tt></a>
<br/>Obtains all objective coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*getcallbackfunc"><tt class="tt">MSK_getcallbackfunc</tt></a>
<br/>Obtains the call-back function and the associated user handle. </li>
<li><a href="node017.html#common-func*mosek*task*getcfix"><tt class="tt">MSK_getcfix</tt></a>
<br/>Obtains the fixed term in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getcone"><tt class="tt">MSK_getcone</tt></a>
<br/>Obtains a conic constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getconeinfo"><tt class="tt">MSK_getconeinfo</tt></a>
<br/>Obtains information about a conic constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getconname"><tt class="tt">MSK_getconname</tt></a>
<br/>Obtains a name of a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getconname64"><tt class="tt">MSK_getconname64</tt></a>
<br/>Obtains a name of a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getcslice"><tt class="tt">MSK_getcslice</tt></a>
<br/>Obtains a sequence of coefficients from the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getdbi"><tt class="tt">MSK_getdbi</tt></a>
<br/>Obtains the dual bound infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getdcni"><tt class="tt">MSK_getdcni</tt></a>
<br/>Obtains the dual cone infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getdeqi"><tt class="tt">MSK_getdeqi</tt></a>
<br/>Optains the dual equation infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getdouinf"><tt class="tt">MSK_getdouinf</tt></a>
<br/>Obtains a double information item. </li>
<li><a href="node017.html#common-func*mosek*task*getdouparam"><tt class="tt">MSK_getdouparam</tt></a>
<br/>Obtains a double parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getdualobj"><tt class="tt">MSK_getdualobj</tt></a>
<br/>Obtains the dual objective value. </li>
<li><a href="node017.html#common-func*mosek*task*getenv"><tt class="tt">MSK_getenv</tt></a>
<br/>Obtains the environment used to create the task. </li>
<li><a href="node017.html#common-func*mosek*task*getinfeasiblesubproblem"><tt class="tt">MSK_getinfeasiblesubproblem</tt></a>
<br/>Obtains an infeasible sub problem. </li>
<li><a href="node017.html#common-func*mosek*task*getinfindex"><tt class="tt">MSK_getinfindex</tt></a>
<br/>Obtains the index of a named information item. </li>
<li><a href="node017.html#common-func*mosek*task*getinfmax"><tt class="tt">MSK_getinfmax</tt></a>
<br/>Obtains the maximum index of an information of a given type inftype plus 1. </li>
<li><a href="node017.html#common-func*mosek*task*getinfname"><tt class="tt">MSK_getinfname</tt></a>
<br/>Obtains the name of an information item. </li>
<li><a href="node017.html#common-func*mosek*task*getinti"><tt class="tt">MSK_getinti</tt></a>
<br/>Obtains the primal equation infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getintinf"><tt class="tt">MSK_getintinf</tt></a>
<br/>Obtains an integer information item. </li>
<li><a href="node017.html#common-func*mosek*task*getintparam"><tt class="tt">MSK_getintparam</tt></a>
<br/>Obtains an integer parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getintpntnumthreads"><tt class="tt">MSK_getintpntnumthreads</tt></a>
<br/>Obtains the number of threads used by the interior-point optimizer. </li>
<li><a href="node017.html#common-func*mosek*task*getlasterror"><tt class="tt">MSK_getlasterror</tt></a>
<br/>Obtains the last error code and error message reported in MOSEK. </li>
<li><a href="node017.html#common-func*mosek*task*getlasterror64"><tt class="tt">MSK_getlasterror64</tt></a>
<br/>Obtains the last error code and error message reported in MOSEK. </li>
<li><a href="node017.html#common-func*mosek*task*getlintinf"><tt class="tt">MSK_getlintinf</tt></a>
<br/>Obtains an integer information item. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnamelen"><tt class="tt">MSK_getmaxnamelen</tt></a>
<br/>Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumanz"><tt class="tt">MSK_getmaxnumanz</tt></a>
<br/>Obtains number of preallocated non-zeros in the linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumanz64"><tt class="tt">MSK_getmaxnumanz64</tt></a>
<br/>Obtains number of preallocated non-zeros in the linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumcon"><tt class="tt">MSK_getmaxnumcon</tt></a>
<br/>Obtains the number of preallocated constraints in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumcone"><tt class="tt">MSK_getmaxnumcone</tt></a>
<br/>Obtains the number of preallocated cones in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumqnz"><tt class="tt">MSK_getmaxnumqnz</tt></a>
<br/>Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumqnz64"><tt class="tt">MSK_getmaxnumqnz64</tt></a>
<br/>Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints. </li>
<li><a href="node017.html#common-func*mosek*task*getmaxnumvar"><tt class="tt">MSK_getmaxnumvar</tt></a>
<br/>Obtains the maximum number variables allowed. </li>
<li><a href="node017.html#common-func*mosek*task*getmemusagetask"><tt class="tt">MSK_getmemusagetask</tt></a>
<br/>Obtains information about the amount of memory used by a task. </li>
<li><a href="node017.html#common-func*mosek*task*getmemusagetask64"><tt class="tt">MSK_getmemusagetask64</tt></a>
<br/>Obtains information about the amount of memory used by a task. </li>
<li><a href="node017.html#common-func*mosek*task*getnadouinf"><tt class="tt">MSK_getnadouinf</tt></a>
<br/>Obtains a double information item. </li>
<li><a href="node017.html#common-func*mosek*task*getnadouparam"><tt class="tt">MSK_getnadouparam</tt></a>
<br/>Obtains a double parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getnaintinf"><tt class="tt">MSK_getnaintinf</tt></a>
<br/>Obtains an integer information item. </li>
<li><a href="node017.html#common-func*mosek*task*getnaintparam"><tt class="tt">MSK_getnaintparam</tt></a>
<br/>Obtains an integer parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getname"><tt class="tt">MSK_getname</tt></a>
<br/>Obtains the name of a cone, a variable or a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getname64"><tt class="tt">MSK_getname64</tt></a>
<br/>Obtains the name of a cone, a variable or a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getnameapi64"><tt class="tt">MSK_getnameapi64</tt></a>
<br/>Obtains the name of a cone, a variable or a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getnameindex"><tt class="tt">MSK_getnameindex</tt></a>
<br/>Checks whether a name has been assigned and returns the index corresponding to the name. </li>
<li><a href="node017.html#common-func*mosek*task*getnamelen64"><tt class="tt">MSK_getnamelen64</tt></a>
<br/>Obtains the length of a problem item name. </li>
<li><a href="node017.html#common-func*mosek*task*getnastrparam"><tt class="tt">MSK_getnastrparam</tt></a>
<br/>Obtains a string parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getnastrparamal"><tt class="tt">MSK_getnastrparamal</tt></a>
<br/>Obtains the value of a string parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getnlfunc"><tt class="tt">MSK_getnlfunc</tt></a>
<br/>Gets nonlinear call-back functions. </li>
<li><a href="node017.html#common-func*mosek*task*getnumanz"><tt class="tt">MSK_getnumanz</tt></a>
<br/>Obtains the number of non-zeros in the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getnumanz64"><tt class="tt">MSK_getnumanz64</tt></a>
<br/>Obtains the number of non-zeros in the coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*getnumcon"><tt class="tt">MSK_getnumcon</tt></a>
<br/>Obtains the number of constraints. </li>
<li><a href="node017.html#common-func*mosek*task*getnumcone"><tt class="tt">MSK_getnumcone</tt></a>
<br/>Obtains the number of cones. </li>
<li><a href="node017.html#common-func*mosek*task*getnumconemem"><tt class="tt">MSK_getnumconemem</tt></a>
<br/>Obtains the number of members in a cone. </li>
<li><a href="node017.html#common-func*mosek*task*getnumintvar"><tt class="tt">MSK_getnumintvar</tt></a>
<br/>Obtains the number of integer-constrained variables. </li>
<li><a href="node017.html#common-func*mosek*task*getnumparam"><tt class="tt">MSK_getnumparam</tt></a>
<br/>Obtains the number of parameters of a given type. </li>
<li><a href="node017.html#common-func*mosek*task*getnumqconknz"><tt class="tt">MSK_getnumqconknz</tt></a>
<br/>Obtains the number of non-zero quadratic terms in a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getnumqconknz64"><tt class="tt">MSK_getnumqconknz64</tt></a>
<br/>Obtains the number of non-zero quadratic terms in a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getnumqobjnz"><tt class="tt">MSK_getnumqobjnz</tt></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getnumqobjnz64"><tt class="tt">MSK_getnumqobjnz64</tt></a>
<br/>Obtains the number of non-zero quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getnumvar"><tt class="tt">MSK_getnumvar</tt></a>
<br/>Obtains the number of variables. </li>
<li><a href="node017.html#common-func*mosek*task*getobjname"><tt class="tt">MSK_getobjname</tt></a>
<br/>Obtains the name assigned to the objective function. </li>
<li><a href="node017.html#common-func*mosek*task*getobjname64"><tt class="tt">MSK_getobjname64</tt></a>
<br/>Obtains the name assigned to the objective function. </li>
<li><a href="node017.html#common-func*mosek*task*getobjsense"><tt class="tt">MSK_getobjsense</tt></a>
<br/>Gets the objective sense. </li>
<li><a href="node017.html#common-func*mosek*task*getparammax"><tt class="tt">MSK_getparammax</tt></a>
<br/>Obtains the maximum index of a parameter of a given type plus 1. </li>
<li><a href="node017.html#common-func*mosek*task*getparamname"><tt class="tt">MSK_getparamname</tt></a>
<br/>Obtains the name of a parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getpbi"><tt class="tt">MSK_getpbi</tt></a>
<br/>Obtains the primal bound infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getpcni"><tt class="tt">MSK_getpcni</tt></a>
<br/>Obtains the primal cone infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getpeqi"><tt class="tt">MSK_getpeqi</tt></a>
<br/>Obtains the primal equation infeasibility. </li>
<li><a href="node017.html#common-func*mosek*task*getprimalobj"><tt class="tt">MSK_getprimalobj</tt></a>
<br/>Obtains the primal objective value. </li>
<li><a href="node017.html#common-func*mosek*task*getprobtype"><tt class="tt">MSK_getprobtype</tt></a>
<br/>Obtains the problem type. </li>
<li><a href="node017.html#common-func*mosek*task*getqconk"><tt class="tt">MSK_getqconk</tt></a>
<br/>Obtains all the quadratic terms in a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getqconk64"><tt class="tt">MSK_getqconk64</tt></a>
<br/>Obtains all the quadratic terms in a constraint. </li>
<li><a href="node017.html#common-func*mosek*task*getqobj"><tt class="tt">MSK_getqobj</tt></a>
<br/>Obtains all the quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getqobj64"><tt class="tt">MSK_getqobj64</tt></a>
<br/>Obtains all the quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*getqobjij"><tt class="tt">MSK_getqobjij</tt></a>
<br/>Obtains one coefficient from the quadratic term of the objective </li>
<li><a href="node017.html#common-func*mosek*task*getreducedcosts"><tt class="tt">MSK_getreducedcosts</tt></a>
<br/>Obtains the difference of (slx-sux) for a sequence of variables. </li>
<li><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">MSK_getsolution</tt></a>
<br/>Obtains the complete solution. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">MSK_getsolutioni</tt></a>
<br/>Obtains the solution for a single constraint or variable. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutionincallback"><tt class="tt">MSK_getsolutionincallback</tt></a>
<br/>Obtains the whole or a part of the solution from the progress call-back function. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a>
<br/>Obtains information about a solution. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutionslice"><tt class="tt">MSK_getsolutionslice</tt></a>
<br/>Obtains a slice of the solution. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">MSK_getsolutionstatus</tt></a>
<br/>Obtains information about the problem and solution statuses. </li>
<li><a href="node017.html#common-func*mosek*task*getsolutionstatuskeyslice"><tt class="tt">MSK_getsolutionstatuskeyslice</tt></a>
<br/>Obtains a slice of the solution status keys. </li>
<li><a href="node017.html#common-func*mosek*task*getstrparam"><tt class="tt">MSK_getstrparam</tt></a>
<br/>Obtains the value of a string parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getstrparam64"><tt class="tt">MSK_getstrparam64</tt></a>
<br/>Obtains the value of a string parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getstrparamal"><tt class="tt">MSK_getstrparamal</tt></a>
<br/>Obtains the value a string parameter. </li>
<li><a href="node017.html#common-func*mosek*task*getsymbcon"><tt class="tt">MSK_getsymbcon</tt></a>
<br/>Obtains a cone type string identifier. </li>
<li><a href="node017.html#common-func*mosek*task*gettaskname"><tt class="tt">MSK_gettaskname</tt></a>
<br/>Obtains the task name. </li>
<li><a href="node017.html#common-func*mosek*task*gettaskname64"><tt class="tt">MSK_gettaskname64</tt></a>
<br/>Obtains the task name. </li>
<li><a href="node017.html#common-func*mosek*task*getvarbranchdir"><tt class="tt">MSK_getvarbranchdir</tt></a>
<br/>Obtains the branching direction for a variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvarbranchorder"><tt class="tt">MSK_getvarbranchorder</tt></a>
<br/>Obtains the branching priority for a variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvarbranchpri"><tt class="tt">MSK_getvarbranchpri</tt></a>
<br/>Obtains the branching priority for a variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvarname"><tt class="tt">MSK_getvarname</tt></a>
<br/>Obtains a name of a variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvarname64"><tt class="tt">MSK_getvarname64</tt></a>
<br/>Obtains a name of a variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvartype"><tt class="tt">MSK_getvartype</tt></a>
<br/>Gets the variable type of one variable. </li>
<li><a href="node017.html#common-func*mosek*task*getvartypelist"><tt class="tt">MSK_getvartypelist</tt></a>
<br/>Obtains the variable type for one or more variables. </li>
<li><a href="node017.html#common-func*mosek*task*initbasissolve"><tt class="tt">MSK_initbasissolve</tt></a>
<br/>Prepare a task for basis solver. </li>
<li><a href="node017.html#common-func*mosek*task*inputdata"><tt class="tt">MSK_inputdata</tt></a>
<br/>Input the linear part of an optimization task in one function call. </li>
<li><a href="node017.html#common-func*mosek*task*inputdata64"><tt class="tt">MSK_inputdata64</tt></a>
<br/>Input the linear part of an optimization task in one function call. </li>
<li><a href="node017.html#common-func*mosek*task*isdouparname"><tt class="tt">MSK_isdouparname</tt></a>
<br/>Checks a double parameter name. </li>
<li><a href="node017.html#common-func*mosek*task*isintparname"><tt class="tt">MSK_isintparname</tt></a>
<br/>Checks an integer parameter name. </li>
<li><a href="node017.html#common-func*mosek*task*isstrparname"><tt class="tt">MSK_isstrparname</tt></a>
<br/>Checks a string parameter name. </li>
<li><a href="node017.html#common-func*mosek*task*linkfiletotaskstream"><tt class="tt">MSK_linkfiletotaskstream</tt></a>
<br/>Directs all output from a task stream to a file. </li>
<li><a href="node017.html#common-func*mosek*task*linkfunctotaskstream"><tt class="tt">MSK_linkfunctotaskstream</tt></a>
<br/>Connects a user-defined function to a task stream. </li>
<li><a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><tt class="tt">MSK_makesolutionstatusunknown</tt></a>
<br/>Sets the solution status to unknown. </li>
<li><a href="node017.html#common-func*mosek*task*netextraction"><tt class="tt">MSK_netextraction</tt></a>
<br/>Finds embedded network structure. </li>
<li><a href="node017.html#common-func*mosek*task*netoptimize"><tt class="tt">MSK_netoptimize</tt></a>
<br/>Optimizes a pure network flow problem. </li>
<li><a href="node017.html#common-func*mosek*task*optimize"><tt class="tt">MSK_optimize</tt></a>
<br/>Optimizes the problem. </li>
<li><a href="node017.html#common-func*mosek*task*optimizeconcurrent"><tt class="tt">MSK_optimizeconcurrent</tt></a>
<br/>Optimize a given task with several optimizers concurrently. </li>
<li><a href="node017.html#common-func*mosek*task*optimizersummary"><tt class="tt">MSK_optimizersummary</tt></a>
<br/>Prints a short summary with optimizer statistics for last optimization. </li>
<li><a href="node017.html#common-func*mosek*task*optimizetrm"><tt class="tt">MSK_optimizetrm</tt></a>
<br/>Optimizes the problem. </li>
<li><a href="node017.html#common-func*mosek*task*primalsensitivity"><tt class="tt">MSK_primalsensitivity</tt></a>
<br/>Perform sensitivity analysis on bounds. </li>
<li><a href="node017.html#common-func*mosek*task*printdata"><tt class="tt">MSK_printdata</tt></a>
<br/>Prints a part of the problem data to a stream. </li>
<li><a href="node017.html#common-func*mosek*task*printparam"><tt class="tt">MSK_printparam</tt></a>
<br/>Prints the current parameter settings. </li>
<li><a href="node017.html#common-func*mosek*task*probtypetostr"><tt class="tt">MSK_probtypetostr</tt></a>
<br/>Obtains a string containing the name of a problem type given. </li>
<li><a href="node017.html#common-func*mosek*task*prostatostr"><tt class="tt">MSK_prostatostr</tt></a>
<br/>Obtains a string containing the name of a problem status given. </li>
<li><a href="node017.html#common-func*mosek*task*putaij"><tt class="tt">MSK_putaij</tt></a>
<br/>Changes a single value in the linear coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*putaijlist"><tt class="tt">MSK_putaijlist</tt></a>
<br/>Changes one or more coefficients in the linear constraint matrix. </li>
<li><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">MSK_putavec</tt></a>
<br/>Replaces all elements in one row or column of the linear coefficient matrix. </li>
<li><a href="node017.html#common-func*mosek*task*putaveclist"><tt class="tt">MSK_putaveclist</tt></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </li>
<li><a href="node017.html#common-func*mosek*task*putaveclist64"><tt class="tt">MSK_putaveclist64</tt></a>
<br/>Replaces all elements in one or more rows or columns in the linear constraint matrix by new values. </li>
<li><a href="node017.html#common-func*mosek*task*putbound"><tt class="tt">MSK_putbound</tt></a>
<br/>Changes the bound for either one constraint or one variable. </li>
<li><a href="node017.html#common-func*mosek*task*putboundlist"><tt class="tt">MSK_putboundlist</tt></a>
<br/>Changes the bounds of constraints or variables. </li>
<li><a href="node017.html#common-func*mosek*task*putboundslice"><tt class="tt">MSK_putboundslice</tt></a>
<br/>Modifies bounds. </li>
<li><a href="node017.html#common-func*mosek*task*putcallbackfunc"><tt class="tt">MSK_putcallbackfunc</tt></a>
<br/>Input the progress call-back function. </li>
<li><a href="node017.html#common-func*mosek*task*putcfix"><tt class="tt">MSK_putcfix</tt></a>
<br/>Replaces the fixed term in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putcj"><tt class="tt">MSK_putcj</tt></a>
<br/>Modifies one linear coefficient in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putclist"><tt class="tt">MSK_putclist</tt></a>
<br/>Modifies a part of the linear objective coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*putcone"><tt class="tt">MSK_putcone</tt></a>
<br/>Replaces a conic constraint. </li>
<li><a href="node017.html#common-func*mosek*task*putdouparam"><tt class="tt">MSK_putdouparam</tt></a>
<br/>Sets a double parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putintparam"><tt class="tt">MSK_putintparam</tt></a>
<br/>Sets an integer parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">MSK_putmaxnumanz</tt></a>
<br/>The function changes the size of the preallocated storage for linear coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumanz64"><tt class="tt">MSK_putmaxnumanz64</tt></a>
<br/>The function changes the size of the preallocated storage for linear coefficients. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumcon"><tt class="tt">MSK_putmaxnumcon</tt></a>
<br/>Sets the number of preallocated constraints in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumcone"><tt class="tt">MSK_putmaxnumcone</tt></a>
<br/>Sets the number of preallocated conic constraints in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><tt class="tt">MSK_putmaxnumqnz</tt></a>
<br/>Changes the size of the preallocated storage for quadratic terms. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumqnz64"><tt class="tt">MSK_putmaxnumqnz64</tt></a>
<br/>Changes the size of the preallocated storage for quadratic terms. </li>
<li><a href="node017.html#common-func*mosek*task*putmaxnumvar"><tt class="tt">MSK_putmaxnumvar</tt></a>
<br/>Sets the number of preallocated variables in the optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*putnadouparam"><tt class="tt">MSK_putnadouparam</tt></a>
<br/>Sets a double parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putnaintparam"><tt class="tt">MSK_putnaintparam</tt></a>
<br/>Sets an integer parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putname"><tt class="tt">MSK_putname</tt></a>
<br/>Assigns a name to a problem item. </li>
<li><a href="node017.html#common-func*mosek*task*putnastrparam"><tt class="tt">MSK_putnastrparam</tt></a>
<br/>Sets a string parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putnlfunc"><tt class="tt">MSK_putnlfunc</tt></a>
<br/>Inputs nonlinear function information. </li>
<li><a href="node017.html#common-func*mosek*task*putobjname"><tt class="tt">MSK_putobjname</tt></a>
<br/>Assigns a new name to the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putobjsense"><tt class="tt">MSK_putobjsense</tt></a>
<br/>Sets the objective sense. </li>
<li><a href="node017.html#common-func*mosek*task*putparam"><tt class="tt">MSK_putparam</tt></a>
<br/>Modifies the value of parameter. </li>
<li><a href="node017.html#common-func*mosek*task*putqcon"><tt class="tt">MSK_putqcon</tt></a>
<br/>Replaces all quadratic terms in constraints. </li>
<li><a href="node017.html#common-func*mosek*task*putqconk"><tt class="tt">MSK_putqconk</tt></a>
<br/>Replaces all quadratic terms in a single constraint. </li>
<li><a href="node017.html#common-func*mosek*task*putqobj"><tt class="tt">MSK_putqobj</tt></a>
<br/>Replaces all quadratic terms in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putqobjij"><tt class="tt">MSK_putqobjij</tt></a>
<br/>Replaces one coefficient in the quadratic term in the objective. </li>
<li><a href="node017.html#common-func*mosek*task*putresponsefunc"><tt class="tt">MSK_putresponsefunc</tt></a>
<br/>Inputs a user-defined error call-back function. </li>
<li><a href="node017.html#common-func*mosek*task*putsolution"><tt class="tt">MSK_putsolution</tt></a>
<br/>Inserts a solution. </li>
<li><a href="node017.html#common-func*mosek*task*putsolutioni"><tt class="tt">MSK_putsolutioni</tt></a>
<br/>Sets the primal and dual solution information for a single constraint or variable. </li>
<li><a href="node017.html#common-func*mosek*task*putsolutionyi"><tt class="tt">MSK_putsolutionyi</tt></a>
<br/>Inputs the dual variable of a solution. </li>
<li><a href="node017.html#common-func*mosek*task*putstrparam"><tt class="tt">MSK_putstrparam</tt></a>
<br/>Sets a string parameter. </li>
<li><a href="node017.html#common-func*mosek*task*puttaskname"><tt class="tt">MSK_puttaskname</tt></a>
<br/>Assigns a new name to the task. </li>
<li><a href="node017.html#common-func*mosek*task*putvarbranchorder"><tt class="tt">MSK_putvarbranchorder</tt></a>
<br/>Assigns a branching priority and direction to a variable. </li>
<li><a href="node017.html#common-func*mosek*task*putvartype"><tt class="tt">MSK_putvartype</tt></a>
<br/>Sets the variable type of one variable. </li>
<li><a href="node017.html#common-func*mosek*task*putvartypelist"><tt class="tt">MSK_putvartypelist</tt></a>
<br/>Sets the variable type for one or more variables. </li>
<li><a href="node017.html#common-func*mosek*task*readbranchpriorities"><tt class="tt">MSK_readbranchpriorities</tt></a>
<br/>Reads branching priority data from a file. </li>
<li><a href="node017.html#common-func*mosek*task*readdata"><tt class="tt">MSK_readdata</tt></a>
<br/>Reads problem data from a file. </li>
<li><a href="node017.html#common-func*mosek*task*readparamfile"><tt class="tt">MSK_readparamfile</tt></a>
<br/>Reads a parameter file. </li>
<li><a href="node017.html#common-func*mosek*task*readsolution"><tt class="tt">MSK_readsolution</tt></a>
<br/>Reads a solution from a file. </li>
<li><a href="node017.html#common-func*mosek*task*readsummary"><tt class="tt">MSK_readsummary</tt></a>
<br/>Prints information about last file read. </li>
<li><a href="node017.html#common-func*mosek*task*relaxprimal"><tt class="tt">MSK_relaxprimal</tt></a>
<br/>Creates a problem that finds the minimal change to the bounds that makes an infeasible problem feasible. </li>
<li><a href="node017.html#common-func*mosek*task*remove"><tt class="tt">MSK_remove</tt></a>
<br/>The function removes a number of constraints or variables. </li>
<li><a href="node017.html#common-func*mosek*task*removecone"><tt class="tt">MSK_removecone</tt></a>
<br/>Removes a conic constraint from the problem. </li>
<li><a href="node017.html#common-func*mosek*task*resizetask"><tt class="tt">MSK_resizetask</tt></a>
<br/>Resizes an optimization task. </li>
<li><a href="node017.html#common-func*mosek*task*sensitivityreport"><tt class="tt">MSK_sensitivityreport</tt></a>
<br/>Creates a sensitivity report. </li>
<li><a href="node017.html#common-func*mosek*task*setdefaults"><tt class="tt">MSK_setdefaults</tt></a>
<br/>Resets all parameters values. </li>
<li><a href="node017.html#common-func*mosek*task*sktostr"><tt class="tt">MSK_sktostr</tt></a>
<br/>Obtains a status key string. </li>
<li><a href="node017.html#common-func*mosek*task*solstatostr"><tt class="tt">MSK_solstatostr</tt></a>
<br/>Obtains a solution status string. </li>
<li><a href="node017.html#common-func*mosek*task*solutiondef"><tt class="tt">MSK_solutiondef</tt></a>
<br/>Checks whether a solution is defined. </li>
<li><a href="node017.html#common-func*mosek*task*solutionsummary"><tt class="tt">MSK_solutionsummary</tt></a>
<br/>Prints a short summary of the current solutions. </li>
<li><a href="node017.html#common-func*mosek*task*solvewithbasis"><tt class="tt">MSK_solvewithbasis</tt></a>
<br/>Solve a linear equation system involving a basis matrix. </li>
<li><a href="node017.html#common-func*mosek*task*strdupdbgtask"><tt class="tt">MSK_strdupdbgtask</tt></a>
<br/>Make a copy of a string. </li>
<li><a href="node017.html#common-func*mosek*task*strduptask"><tt class="tt">MSK_strduptask</tt></a>
<br/>Make a copy of a string. </li>
<li><a href="node017.html#common-func*mosek*task*strtoconetype"><tt class="tt">MSK_strtoconetype</tt></a>
<br/>Obtains a cone type code. </li>
<li><a href="node017.html#common-func*mosek*task*strtosk"><tt class="tt">MSK_strtosk</tt></a>
<br/>Obtains a status key. </li>
<li><a href="node017.html#common-func*mosek*task*undefsolution"><tt class="tt">MSK_undefsolution</tt></a>
<br/>Undefines a solution. </li>
<li><a href="node017.html#common-func*mosek*task*unlinkfuncfromtaskstream"><tt class="tt">MSK_unlinkfuncfromtaskstream</tt></a>
<br/>Disconnects a user-defined function from a task stream. </li>
<li><a href="node017.html#common-func*mosek*task*whichparam"><tt class="tt">MSK_whichparam</tt></a>
<br/>Checks a parameter name. </li>
<li><a href="node017.html#common-func*mosek*task*writebranchpriorities"><tt class="tt">MSK_writebranchpriorities</tt></a>
<br/>Writes branching priority data to a file. </li>
<li><a href="node017.html#common-func*mosek*task*writedata"><tt class="tt">MSK_writedata</tt></a>
<br/>Writes problem data to a file. </li>
<li><a href="node017.html#common-func*mosek*task*writeparamfile"><tt class="tt">MSK_writeparamfile</tt></a>
<br/>Writes all the parameters to a parameter file. </li>
<li><a href="node017.html#common-func*mosek*task*writesolution"><tt class="tt">MSK_writesolution</tt></a>
<br/>Write a solution to a file. </li>
</ul>

<ul class="functionlist">
<li><span class="itemhead"><tt class="tt">MSK_analyzeproblem</tt></span>

<p> <a name="func*mosek*task*analyzeproblem">&#09;</a><a name="common-func*mosek*task*analyzeproblem"></a> <a name="idx-113809024">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_analyzeproblem (
    MSKtask_t task,
    MSKstreamtypee whichstream);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The function analyze the data of task and writes out a report.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_analyzesolution</tt></span>

<p> <a name="func*mosek*task*analyzesolution">&#09;</a><a name="common-func*mosek*task*analyzesolution"></a> <a name="idx-112026472">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_analyzesolution (
    MSKtask_t task,
    MSKstreamtypee whichstream,
    MSKsoltypee whichsol);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Print information related to the quality of the solution and other solution statistics.</p>

<p>By default this function prints information about the largest infeasibilites in the solution, the primal (and possibly dual) objective value and the solution status.</p>

<p>Following parameters can be used to configure the printed statistics: </p>

<ul class="itemize">
<li><a href="node018.html#common-const*mosek*iparam*ana-sol-basis"><tt class="tt">MSK_IPAR_ANA_SOL_BASIS</tt></a>. Enables or disables printing of statistics specific to the basis solution (condition number, number of basic variables etc.). Default is on. </li>
<li><a href="node018.html#common-const*mosek*iparam*ana-sol-print-violated"><tt class="tt">MSK_IPAR_ANA_SOL_PRINT_VIOLATED</tt></a>. Enables or disables listing names of all constraints (both primal and dual) which are violated by the solution. Default is off. </li>
<li><a href="node018.html#common-const*mosek*dparam*ana-sol-infeas-tol"><tt class="tt">MSK_DPAR_ANA_SOL_INFEAS_TOL</tt></a>. The tolerance defining when a constraint is considered violated. If a constraint is violated more than this, it will be listed in the summary. </li>
</ul>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getpeqi"><tt class="tt">MSK_getpeqi</tt></a></dt>
<dd>
<p> Obtains the primal equation infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdeqi"><tt class="tt">MSK_getdeqi</tt></a></dt>
<dd>
<p> Optains the dual equation infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getpbi"><tt class="tt">MSK_getpbi</tt></a></dt>
<dd>
<p> Obtains the primal bound infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdbi"><tt class="tt">MSK_getdbi</tt></a></dt>
<dd>
<p> Obtains the dual bound infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdcni"><tt class="tt">MSK_getdcni</tt></a></dt>
<dd>
<p> Obtains the dual cone infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getpcni"><tt class="tt">MSK_getpcni</tt></a></dt>
<dd>
<p> Obtains the primal cone infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">MSK_getsolutionstatus</tt></a></dt>
<dd>
<p> Obtains information about the problem and solution statuses.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_append</tt></span>

<p> <a name="func*mosek*task*append">&#09;</a><a name="common-func*mosek*task*append"></a> <a name="idx-113821600">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_append (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKintt num);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of constraints or variables which should be appended.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Appends a number of constraints or variables to the model. Appended constraints will be declared free and appended variables will be fixed at the level zero. Please note that MOSEK will automatically expand the problem dimension to accommodate the additional constraints and variables.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*remove"><tt class="tt">MSK_remove</tt></a></dt>
<dd>
<p> The function removes a number of constraints or variables.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_appendcone</tt></span>

<p> <a name="func*mosek*task*appendcone">&#09;</a><a name="common-func*mosek*task*appendcone"></a> <a name="idx-113829000">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_appendcone (
    MSKtask_t task,
    MSKconetypee conetype,
    MSKrealt conepar,
    MSKintt nummem,
    MSKCONST MSKidxt * submem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (input)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (input)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">nummem</tt> (input)</dt>
<dd>Number of member variables in the cone.</dd>
<dt><tt class="tt">submem</tt> (input)</dt>
<dd>Variable subscripts of the members in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Appends a new conic constraint to the problem. Hence, add a constraint  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math872.png" alt="\begin{displaymath}\nonumber{}\bar{x}\in{}\mathcal{C}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  to the problem where <span class="math"><img src="math/math62.png" alt="[[MathCmd 62]]"/></span> is a convex cone. <span class="math"><img src="math/math528.png" alt="[[MathCmd 528]]"/></span> is a subset of the variables which will be specified by the argument <tt class="tt">submem</tt>.</p>

<p>Depending on the value of <tt class="tt">conetype</tt> this function appends a normal (<a href="node020.html#common-const*mosek*conetype*quad"><tt class="tt">MSK_CT_QUAD</tt></a>) or rotated quadratic cone (<a href="node020.html#common-const*mosek*conetype*rquad"><tt class="tt">MSK_CT_RQUAD</tt></a>). Define </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math875.png" alt="\begin{displaymath}\nonumber{}\bar{x}=x_{{\mathtt{submem}[0]}},\ldots ,x_{{\mathtt{submem}[\mathtt{nummem}-1]}}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>. Depending on the value of <tt class="tt">conetype</tt> this function appends one of the constraints: </p>

<ul class="itemize">
<li>
<p>Quadratic cone (<a href="node020.html#common-const*mosek*conetype*quad"><tt class="tt">MSK_CT_QUAD</tt></a>) : </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math876.png" alt="\begin{displaymath}\nonumber{}\bar{x}_{0}\geq{}\sqrt{\sum _{{i=1}}^{{i<\mathtt{nummem}}}\bar{x}_{i}^{2}}\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
<li>
<p>Rotated quadratic cone (<a href="node020.html#common-const*mosek*conetype*rquad"><tt class="tt">MSK_CT_RQUAD</tt></a>) : </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math877.png" alt="\begin{displaymath}\nonumber{}2\bar{x}_{0}\bar{x}_{1}\geq{}\sum _{{i=2}}^{{i<\mathtt{nummem}}}\bar{x}^{2}_{i},\quad{}\bar{x}_{{0}},\bar{x}_{1}\geq{}0\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
</ul>

<p>Please note that the sets of variables appearing in different conic constraints must be disjoint.</p>

<p>For an explained code example see Section <a title="5.4. Conic optimization" href="node007.html#sec:conic-opt">5.4</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_basiscond</tt></span>

<p> <a name="func*mosek*task*basiscond">&#09;</a><a name="common-func*mosek*task*basiscond"></a> <a name="idx-113899136">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_basiscond (
    MSKtask_t task,
    MSKrealt * nrmbasis,
    MSKrealt * nrminvbasis);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">nrmbasis</tt> (output)</dt>
<dd>An estimate for the 1 norm of the basis.</dd>
<dt><tt class="tt">nrminvbasis</tt> (output)</dt>
<dd>An estimate for the 1 norm of the inverse of the basis.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>If a basic solution is available and it defines a nonsingular basis, then this function computes the 1-norm estimate of the basis matrix and an 1-norm estimate for the inverse of the basis matrix. The 1-norm estimates are computed using the method outlined in [<a href="node029.html#STEWART:98:A" class="citation">9</a>, pp. 388-391].</p>

<p>By defintion the 1-norm condition number of a matrix <span class="math"><span class="mi">B</span></span> is defined as  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math878.png" alt="\begin{displaymath}\nonumber{}\kappa _{1}(B):=\left\|B\right\|_{1}\left\|B^{{-1}}\right\|.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Moreover, the larger the condition number is the harder it is to solve linear equation systems involving <span class="math"><span class="mi">B</span></span>. Given estimates for <span class="math"><img src="math/math879.png" alt="[[MathCmd 879]]"/></span> and <span class="math"><img src="math/math880.png" alt="[[MathCmd 880]]"/></span> it is also possible to estimate <span class="math"><img src="math/math881.png" alt="[[MathCmd 881]]"/></span>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_bktostr</tt></span>

<p> <a name="func*mosek*task*bktostr">&#09;</a><a name="common-func*mosek*task*bktostr"></a> <a name="idx-113931184">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_bktostr (
    MSKtask_t task,
    MSKboundkeye bk,
    char * str);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (input)</dt>
<dd>Bound key.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the bound key code <tt class="tt">bk</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an identifier string corresponding to a bound key.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_callbackcodetostr</tt></span>

<p> <a name="func*mosek*task*callbackcodetostr">&#09;</a><a name="common-func*mosek*task*callbackcodetostr"></a> <a name="idx-113939736">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_callbackcodetostr (
    MSKcallbackcodee code,
    char * callbackcodestr);
</pre>

<dl class="funcargsdesc">
<dt><a href="node020.html#common-constclass*mosek*callbackcode"><tt class="tt">code</tt></a> (input)</dt>
<dd>A call-back code.</dd>
<dt><tt class="tt">callbackcodestr</tt> (output)</dt>
<dd>String corresponding to the call-back code.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a the string representation of a corresponding to a call-back code.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_callocdbgtask</tt></span>

<p> <a name="func*mosek*task*callocdbgtask">&#09;</a><a name="common-func*mosek*task*callocdbgtask"></a> <a name="idx-113958784">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">void * MSK_callocdbgtask (
    MSKtask_t task,
    MSKCONST size_t number,
    MSKCONST size_t size,
    MSKCONST char * file,
    MSKCONST unsigned line);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">number</tt> (input)</dt>
<dd>Number of elements.</dd>
<dt><tt class="tt">size</tt> (input)</dt>
<dd>Size of each individual element.</dd>
<dt><tt class="tt">file</tt> (input)</dt>
<dd>File from which the function is called.</dd>
<dt><tt class="tt">line</tt> (input)</dt>
<dd>Line in the file from which the function is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Debug version of <a href="node017.html#common-func*mosek*task*calloctask"><tt class="tt">MSK_calloctask</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_calloctask</tt></span>

<p> <a name="func*mosek*task*calloctask">&#09;</a><a name="common-func*mosek*task*calloctask"></a> <a name="idx-113971000">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">void * MSK_calloctask (
    MSKtask_t task,
    MSKCONST size_t number,
    MSKCONST size_t size);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">number</tt> (input)</dt>
<dd>Number of elements.</dd>
<dt><tt class="tt">size</tt> (input)</dt>
<dd>Size of each individual element.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Equivalent to <tt class="tt">calloc</tt> i.e. allocate space for an array of length number where each element is of size <tt class="tt">size</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_checkconvexity</tt></span>

<p> <a name="func*mosek*task*checkconvexity">&#09;</a><a name="common-func*mosek*task*checkconvexity"></a> <a name="idx-113964240">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_checkconvexity (MSKtask_t task)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>This function checks if a quadratic optimization problem is convex. The amount of checking is controlled by <a href="node018.html#common-const*mosek*iparam*check-convexity"><tt class="tt">MSK_IPAR_CHECK_CONVEXITY</tt></a>.</p>

<p>The function returns an error code other than <a href="#common-const*mosek*rescode*ok"><tt class="tt">MSK_RES_OK</tt></a> if the problem is not convex.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node018.html#common-const*mosek*iparam*check-convexity"><tt class="tt">MSK_IPAR_CHECK_CONVEXITY</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_checkdata</tt></span>

<p> <a name="func*mosek*task*checkdata">&#09;</a><a name="common-func*mosek*task*checkdata"></a> <a name="idx-113992120">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_checkdata (MSKtask_t task)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks the data of the optimization task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_checkmemtask</tt></span>

<p> <a name="func*mosek*task*checkmemtask">&#09;</a><a name="common-func*mosek*task*checkmemtask"></a> <a name="idx-113977392">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_checkmemtask (
    MSKtask_t task,
    MSKCONST char * file,
    MSKintt line);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">file</tt> (input)</dt>
<dd>File from which the function is called.</dd>
<dt><tt class="tt">line</tt> (input)</dt>
<dd>Line in the file from which the function is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks the memory allocated by the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_chgbound</tt></span>

<p> <a name="func*mosek*task*chgbound">&#09;</a><a name="common-func*mosek*task*chgbound"></a> <a name="idx-114013680">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_chgbound (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt i,
    MSKintt lower,
    MSKintt finite,
    MSKrealt value);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable for which the bounds should be changed.</dd>
<dt><tt class="tt">lower</tt> (input)</dt>
<dd>If non-zero, then the lower bound is changed, otherwise the upper bound is changed.</dd>
<dt><tt class="tt">finite</tt> (input)</dt>
<dd>If non-zero, then <tt class="tt">value</tt> is assumed to be finite.</dd>
<dt><tt class="tt">value</tt> (input)</dt>
<dd>New value for the bound.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Changes a bound for one constraint or variable. If <tt class="tt">accmode</tt> equals <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a>, a constraint bound is changed, otherwise a variable bound is changed.</p>

<p>If <tt class="tt">lower</tt> is non-zero, then the lower bound is changed as follows:  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math882.png" alt="\begin{displaymath}\nonumber{}\mbox{new lower bound}=\left\lbrace{}\begin{array}{ll}\nonumber{}-\infty , & \mathtt{finite}=0,\\\nonumber{}\mathtt{value} & \mbox{otherwise}.\end{array}\right.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Otherwise if <tt class="tt">lower</tt> is zero, then </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math883.png" alt="\begin{displaymath}\nonumber{}\mbox{new upper bound}=\left\lbrace{}\begin{array}{ll}\nonumber{}\infty , & \mathtt{finite}=0,\\\nonumber{}\mathtt{value} & \mbox{otherwise}.\end{array}\right.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> Please note that this function automatically updates the bound key for bound, in particular, if the lower and upper bounds are identical, the bound key is changed to <tt class="tt">fixed</tt>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putbound"><tt class="tt">MSK_putbound</tt></a></dt>
<dd>
<p> Changes the bound for either one constraint or one variable.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-inf"><tt class="tt">MSK_DPAR_DATA_TOL_BOUND_INF</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-wrn"><tt class="tt">MSK_DPAR_DATA_TOL_BOUND_WRN</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_clonetask</tt></span>

<p> <a name="func*mosek*task*clonetask">&#09;</a><a name="common-func*mosek*task*clonetask"></a> <a name="idx-115369672">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_clonetask (
    MSKtask_t task,
    MSKtask_t * clonedtask);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">clonedtask</tt> (output)</dt>
<dd>The cloned task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Creates a clone of an existing task copying all problem data and parameter settings to a new task. Call-back functions are not copied, so a task containing nonlinear functions cannot be cloned.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_commitchanges</tt></span>

<p> <a name="func*mosek*task*commitchanges">&#09;</a><a name="common-func*mosek*task*commitchanges"></a> <a name="idx-115353792">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_commitchanges (MSKtask_t task)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Commits all cached problem changes to the task. It is usually not necessary explicitly to call this function since changes will be committed automatically when required.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_conetypetostr</tt></span>

<p> <a name="func*mosek*task*conetypetostr">&#09;</a><a name="common-func*mosek*task*conetypetostr"></a> <a name="idx-115382464">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_conetypetostr (
    MSKtask_t task,
    MSKconetypee conetype,
    char * str);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (input)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the cone type code <tt class="tt">conetype</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the cone string identifier corresponding to a cone type.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_deletesolution</tt></span>

<p> <a name="func*mosek*task*deletesolution">&#09;</a><a name="common-func*mosek*task*deletesolution"></a> <a name="idx-115378224">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_deletesolution (
    MSKtask_t task,
    MSKsoltypee whichsol);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Undefines a solution and frees the memory it uses.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_deletetask</tt></span>

<p> <a name="func*mosek*task*deletetask">&#09;</a><a name="common-func*mosek*task*deletetask"></a> <a name="idx-115406464">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_deletetask (MSKtask_t * task)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input/output)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Deletes a task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_dualsensitivity</tt></span>

<p> <a name="func*mosek*task*dualsensitivity">&#09;</a><a name="common-func*mosek*task*dualsensitivity"></a> <a name="idx-115414296">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_dualsensitivity (
    MSKtask_t task,
    MSKintt numj,
    MSKCONST MSKidxt * subj,
    MSKrealt * leftpricej,
    MSKrealt * rightpricej,
    MSKrealt * leftrangej,
    MSKrealt * rightrangej);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numj</tt> (input)</dt>
<dd>Number of coefficients to be analyzed. Length of <tt class="tt">subj</tt>.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Index of objective coefficients to analyze.</dd>
<dt><tt class="tt">leftpricej</tt> (output)</dt>
<dd><span class="math"><img src="math/math884.png" alt="[[MathCmd 884]]"/></span> is the left shadow price for the coefficients with index <span class="math"><img src="math/math885.png" alt="[[MathCmd 885]]"/></span>.</dd>
<dt><tt class="tt">rightpricej</tt> (output)</dt>
<dd><span class="math"><img src="math/math886.png" alt="[[MathCmd 886]]"/></span> is the right shadow price for the coefficients with index <span class="math"><img src="math/math885.png" alt="[[MathCmd 885]]"/></span>.</dd>
<dt><tt class="tt">leftrangej</tt> (output)</dt>
<dd><span class="math"><img src="math/math888.png" alt="[[MathCmd 888]]"/></span> is the left range <span class="math"><img src="math/math741.png" alt="[[MathCmd 741]]"/></span> for the coefficient with index <span class="math"><img src="math/math885.png" alt="[[MathCmd 885]]"/></span>.</dd>
<dt><tt class="tt">rightrangej</tt> (output)</dt>
<dd><span class="math"><img src="math/math891.png" alt="[[MathCmd 891]]"/></span> is the right range <span class="math"><img src="math/math742.png" alt="[[MathCmd 742]]"/></span> for the coefficient with index <span class="math"><img src="math/math885.png" alt="[[MathCmd 885]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Calculates sensitivity information for objective coefficients. The indexes of the coefficients to analyze are </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math894.png" alt="\begin{displaymath}\nonumber{}\lbrace{}\mathtt{subj}[i]|i\in{}0,\ldots ,\mathtt{numj}-1\rbrace{}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> The results are returned so that e.g <span class="math"><img src="math/math895.png" alt="[[MathCmd 895]]"/></span> is the left shadow price of the objective coefficient with index <span class="math"><img src="math/math896.png" alt="[[MathCmd 896]]"/></span>.</p>

<p>The type of sensitivity analysis to perform (basis or optimal partition) is controlled by the parameter <a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">MSK_IPAR_SENSITIVITY_TYPE</tt></a>.</p>

<p>For an example, please see Section <a title="12.5. Sensitivity analysis from the MOSEK API" href="node014.html#chap-sensitivity-sec-apiex">12.5</a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*primalsensitivity"><tt class="tt">MSK_primalsensitivity</tt></a></dt>
<dd>
<p> Perform sensitivity analysis on bounds.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*sensitivityreport"><tt class="tt">MSK_sensitivityreport</tt></a></dt>
<dd>
<p> Creates a sensitivity report.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">MSK_IPAR_SENSITIVITY_TYPE</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity"><tt class="tt">MSK_IPAR_LOG_SENSITIVITY</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity-opt"><tt class="tt">MSK_IPAR_LOG_SENSITIVITY_OPT</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_echotask</tt></span>

<p> <a name="func*mosek*task*echotask">&#09;</a><a name="common-func*mosek*task*echotask"></a> <a name="idx-115467904">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_echotask (
    MSKtask_t task,
    MSKstreamtypee whichstream,
    MSKCONST char * format,
    ...);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">format</tt> (input)</dt>
<dd></dd>
<dt><tt class="tt">varnumarg</tt> (input)</dt>
<dd></dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints a format string to a task stream.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_exceptiontask</tt></span>

<p> <a name="func*mosek*task*exceptiontask">&#09;</a><a name="common-func*mosek*task*exceptiontask"></a> <a name="idx-115464384">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_exceptiontask (
    MSKtask_t task,
    MSKrescodee code,
    ...);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="/home/eda/mosekprj/brn-6-0/bld/skive/final/default/texlive-2005.0/doc/capi/xhtml-distro/node019.html#common-constclass*mosek*rescode"><tt class="tt">code</tt></a> (input)</dt>
<dd></dd>
<dt><tt class="tt">varnumarg</tt> (input)</dt>
<dd></dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints the <tt class="tt">code</tt> to the error task stream formatted &#8220;nicely&#8221;. <tt class="tt">code</tt> must be a valid response code listed in Appendix <a title="17. Response codes" href="node019.html#chap-rescoderef">17</a>. Moreover, the corresponding response string listed in Appendix <a title="17. Response codes" href="node019.html#chap-rescoderef">17</a> is printed. It is the users responsibility to provide appropriate arguments for the response string listed in Appendix <a title="17. Response codes" href="node019.html#chap-rescoderef">17</a> too.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_freedbgtask</tt></span>

<p> <a name="func*mosek*task*freedbgtask">&#09;</a><a name="common-func*mosek*task*freedbgtask"></a> <a name="idx-115496576">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">void MSK_freedbgtask (
    MSKtask_t task,
    MSKCONST void * buffer,
    MSKCONST char * file,
    MSKCONST unsigned line);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">buffer</tt> (input)</dt>
<dd>A pointer.</dd>
<dt><tt class="tt">file</tt> (input)</dt>
<dd>File from which the function is called.</dd>
<dt><tt class="tt">line</tt> (input)</dt>
<dd>Line in the file from which the function is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Frees space allocated by a MOSEK function. Must not be applied to the MOSEK environment and task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_freetask</tt></span>

<p> <a name="func*mosek*task*freetask">&#09;</a><a name="common-func*mosek*task*freetask"></a> <a name="idx-115507000">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">void MSK_freetask (
    MSKtask_t task,
    MSKCONST void * buffer);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">buffer</tt> (input)</dt>
<dd>A pointer.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Frees space allocated by a MOSEK function. Must not be applied to the MOSEK environment and task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getaij</tt></span>

<p> <a name="func*mosek*task*getaij">&#09;</a><a name="common-func*mosek*task*getaij"></a> <a name="idx-115522232">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getaij (
    MSKtask_t task,
    MSKidxt i,
    MSKidxt j,
    MSKrealt * aij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Row index of the coefficient to be returned.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Column index of the coefficient to be returned.</dd>
<dt><tt class="tt">aij</tt> (output)</dt>
<dd>The required coefficient <span class="math"><img src="math/math897.png" alt="[[MathCmd 897]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a single coefficient in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getapiecenumnz</tt></span>

<p> <a name="func*mosek*task*getapiecenumnz">&#09;</a><a name="common-func*mosek*task*getapiecenumnz"></a> <a name="idx-115530568">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getapiecenumnz (
    MSKtask_t task,
    MSKidxt firsti,
    MSKidxt lasti,
    MSKidxt firstj,
    MSKidxt lastj,
    MSKintt * numnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">firsti</tt> (input)</dt>
<dd>Index of the first row in the rectangular piece.</dd>
<dt><tt class="tt">lasti</tt> (input)</dt>
<dd>Index of the last row plus one in the rectangular piece.</dd>
<dt><tt class="tt">firstj</tt> (input)</dt>
<dd>Index of the first column in the rectangular piece.</dd>
<dt><tt class="tt">lastj</tt> (input)</dt>
<dd>Index of the last column plus one in the rectangular piece.</dd>
<dt><tt class="tt">numnz</tt> (output)</dt>
<dd>Number of non-zero <span class="math"><span class="mi">A</span></span> elements in the rectangular piece.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the number non-zeros in a rectangular piece of <span class="math"><span class="mi">A</span></span>, i.e. the number  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math898.png" alt="\begin{displaymath}\nonumber{}\left|\lbrace{}(i,j):~a_{{i,j}}\not=0,~\mathtt{firsti}\leq{}i\leq{}\mathtt{lasti}-1,~\mathtt{firstj}\leq{}j\leq{}\mathtt{lastj}-1\rbrace{}\right|\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  where <span class="math"><img src="math/math899.png" alt="[[MathCmd 899]]"/></span> means the number of elements in the set <span class="math"><img src="math/math900.png" alt="[[MathCmd 900]]"/></span>.</p>

<p>This function is not an efficient way to obtain the number of non-zeros in one row or column. In that case use the function <a href="node017.html#common-func*mosek*task*getavecnumnz"><tt class="tt">MSK_getavecnumnz</tt></a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getavecnumnz"><tt class="tt">MSK_getavecnumnz</tt></a></dt>
<dd>
<p> Obtains the number of non-zero elements in one row or column of the linear constraint matrix</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getaslicenumnz"><tt class="tt">MSK_getaslicenumnz</tt></a></dt>
<dd>
<p> Obtains the number of non-zeros in a row or column slice of the coefficient matrix.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getaslice</tt></span>

<p> <a name="func*mosek*task*getaslice">&#09;</a><a name="common-func*mosek*task*getaslice"></a> <a name="idx-115565560">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getaslice (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt first,
    MSKidxt last,
    MSKintt maxnumnz,
    MSKintt * surp,
    MSKintt * ptrb,
    MSKlidxt * ptre,
    MSKidxt * sub,
    MSKrealt * val);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether a column-slice or a row-slice is requested.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column in the sequence <b>plus one</b>.</dd>
<dt><tt class="tt">maxnumnz</tt> (input)</dt>
<dd>Denotes the length of the arrays <tt class="tt">sub</tt> and <tt class="tt">val</tt>.</dd>
<dt><tt class="tt">surp</tt> (input/output)</dt>
<dd>The required rows and columns are stored sequentially in <tt class="tt">sub</tt> and <tt class="tt">val</tt> starting from position <tt class="tt">maxnumnz-surp[0]</tt>. Upon return <tt class="tt">surp</tt> has been decremented by the total number of non-zero elements in the rows and columns obtained.</dd>
<dt><tt class="tt">ptrb</tt> (output)</dt>
<dd><tt class="tt">ptrb[t]</tt> is an index pointing to the first element in the <span class="math"><span class="mi">t</span></span>th row or column obtained.</dd>
<dt><tt class="tt">ptre</tt> (output)</dt>
<dd><tt class="tt">ptre[t]</tt> is an index pointing to the last element plus one in the <span class="math"><span class="mi">t</span></span>th row or column obtained.</dd>
<dt><tt class="tt">sub</tt> (output)</dt>
<dd>Contains the row or column subscripts.</dd>
<dt><tt class="tt">val</tt> (output)</dt>
<dd>Contains the coefficient values.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a sequence of rows or columns from <span class="math"><span class="mi">A</span></span> in sparse format.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getaslicenumnz"><tt class="tt">MSK_getaslicenumnz</tt></a></dt>
<dd>
<p> Obtains the number of non-zeros in a row or column slice of the coefficient matrix.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getaslice64</tt></span>

<p> <a name="func*mosek*task*getaslice64">&#09;</a><a name="common-func*mosek*task*getaslice64"></a> <a name="idx-115590136">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getaslice64 (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt first,
    MSKidxt last,
    MSKint64t maxnumnz,
    MSKint64t * surp,
    MSKint64t * ptrb,
    MSKint64t * ptre,
    MSKidxt * sub,
    MSKrealt * val);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether a column slice or a row slice is requested.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column in the sequence <b>plus one</b>.</dd>
<dt><tt class="tt">maxnumnz</tt> (input)</dt>
<dd>Denotes the length of the arrays <tt class="tt">sub</tt> and <tt class="tt">val</tt>.</dd>
<dt><tt class="tt">surp</tt> (input/output)</dt>
<dd>The required rows and columns are stored sequentially in <tt class="tt">sub</tt> and <tt class="tt">val</tt> starting from position <tt class="tt">maxnumnz-surp[0]</tt>. Upon return <tt class="tt">surp</tt> has been decremented by the total number of non-zero elements in the rows and columns obtained.</dd>
<dt><tt class="tt">ptrb</tt> (output)</dt>
<dd><tt class="tt">ptrb[t]</tt> is an index pointing to the first element in the <span class="math"><span class="mi">t</span></span>th row or column obtained.</dd>
<dt><tt class="tt">ptre</tt> (output)</dt>
<dd><tt class="tt">ptre[t]</tt> is an index pointing to the last element plus one in the <span class="math"><span class="mi">t</span></span>th row or column obtained.</dd>
<dt><tt class="tt">sub</tt> (output)</dt>
<dd>Contains the row or column subscripts.</dd>
<dt><tt class="tt">val</tt> (output)</dt>
<dd>Contains the coefficient values.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a sequence of rows or columns from <span class="math"><span class="mi">A</span></span> in sparse format.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getaslicenumnz64"><tt class="tt">MSK_getaslicenumnz64</tt></a></dt>
<dd>
<p> Obtains the number of non-zeros in a slice of rows or columns of the coefficient matrix.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getaslicenumnz</tt></span>

<p> <a name="func*mosek*task*getaslicenumnz">&#09;</a><a name="common-func*mosek*task*getaslicenumnz"></a> <a name="idx-117188008">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getaslicenumnz (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt first,
    MSKidxt last,
    MSKintt * numnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether non-zeros are counted in a column-slice or a row-slice.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column <b>plus one</b> in the sequence.</dd>
<dt><tt class="tt">numnz</tt> (output)</dt>
<dd>Number of non-zeros in the slice.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zeros in a row or column slice of <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getaslicenumnz64</tt></span>

<p> <a name="func*mosek*task*getaslicenumnz64">&#09;</a><a name="common-func*mosek*task*getaslicenumnz64"></a> <a name="idx-117200440">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getaslicenumnz64 (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt first,
    MSKidxt last,
    MSKint64t * numnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether non-zeros are counted in a column slice or a row slice.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column <b>plus one</b> in the sequence.</dd>
<dt><tt class="tt">numnz</tt> (output)</dt>
<dd>Number of non-zeros in the slice.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zeros in a slice of rows or columns of <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getaslicetrip</tt></span>

<p> <a name="func*mosek*task*getaslicetrip">&#09;</a><a name="common-func*mosek*task*getaslicetrip"></a> <a name="idx-117195120">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getaslicetrip (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt first,
    MSKidxt last,
    MSKintt maxnumnz,
    MSKintt * surp,
    MSKidxt * subi,
    MSKidxt * subj,
    MSKrealt * val);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether a column-slice or a row-slice is requested.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first row or column in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Index of the last row or column in the sequence <b>plus one</b>.</dd>
<dt><tt class="tt">maxnumnz</tt> (input)</dt>
<dd>Denotes the length of the arrays <tt class="tt">subi</tt>, <tt class="tt">subj</tt>, and <tt class="tt">aval</tt>.</dd>
<dt><tt class="tt">surp</tt> (input/output)</dt>
<dd>The required rows and columns are stored sequentially in <tt class="tt">subi</tt> and <tt class="tt">val</tt> starting from position <tt class="tt">maxnumnz-surp[0]</tt>. On return <tt class="tt">surp</tt> has been decremented by the total number of non-zero elements in the rows and columns obtained.</dd>
<dt><tt class="tt">subi</tt> (output)</dt>
<dd>Constraint subscripts.</dd>
<dt><tt class="tt">subj</tt> (output)</dt>
<dd>Variable subscripts.</dd>
<dt><tt class="tt">val</tt> (output)</dt>
<dd>Values.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains a sequence of rows or columns from <span class="math"><span class="mi">A</span></span> in a sparse triplet format.</p>

<p>Define <span class="math"><img src="math/math901.png" alt="[[MathCmd 901]]"/></span> as  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math902.png" alt="\begin{displaymath}\nonumber{}p^{1}=\mathtt{maxnumnz-surp[0]}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  when the function is called and <span class="math"><img src="math/math903.png" alt="[[MathCmd 903]]"/></span> by  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math904.png" alt="\begin{displaymath}\nonumber{}p^{2}=\mathtt{maxnumnz-surp[0]},\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  where <tt class="tt">surp[0]</tt> is the value upon termination. Using this notation then  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math905.png" alt="\begin{displaymath}\nonumber{}\mathtt{val}[k]=a_{{\mathtt{subi[k]},\mathtt{subj[k]}}},\quad{}k=p^{1},\ldots ,p^{2}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getaslicenumnz"><tt class="tt">MSK_getaslicenumnz</tt></a></dt>
<dd>
<p> Obtains the number of non-zeros in a row or column slice of the coefficient matrix.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getavec</tt></span>

<p> <a name="func*mosek*task*getavec">&#09;</a><a name="common-func*mosek*task*getavec"></a> <a name="idx-117245856">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getavec (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt i,
    MSKintt * nzi,
    MSKidxt * subi,
    MSKrealt * vali);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the row or column.</dd>
<dt><tt class="tt">nzi</tt> (output)</dt>
<dd>Number of non-zeros in the vector obtained.</dd>
<dt><tt class="tt">subi</tt> (output)</dt>
<dd>Index of the non-zeros in the vector obtained.</dd>
<dt><tt class="tt">vali</tt> (output)</dt>
<dd>Numerical values of the vector to be obtained.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains one row or column of <span class="math"><span class="mi">A</span></span> in a sparse format. If <tt class="tt">accmode</tt> equals <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a> a row is returned and hence:  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math906.png" alt="\begin{displaymath}\nonumber{}\mathtt{vali}[k]=a_{{i,\mathtt{subi}[k]}},\quad{}k=0,\ldots ,\mathtt{nzi[0]}-1\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  If <tt class="tt">accmode</tt> equals <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">MSK_ACC_VAR</tt></a> a column is returned, that is:  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math907.png" alt="\begin{displaymath}\nonumber{}\mathtt{vali}[k]=a_{{\mathtt{subi}[k],i}},\quad{}k=0,\ldots ,\mathtt{nzi[0]}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getavecnumnz</tt></span>

<p> <a name="func*mosek*task*getavecnumnz">&#09;</a><a name="common-func*mosek*task*getavecnumnz"></a> <a name="idx-117282360">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getavecnumnz (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt i,
    MSKintt * nzj);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether non-zeros are counted by columns or by rows.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the row or column.</dd>
<dt><tt class="tt">nzj</tt> (output)</dt>
<dd>Number of non-zeros in the <span class="math"><span class="mi">i</span></span>th row or column of <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero elements in one row or column of <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getbound</tt></span>

<p> <a name="func*mosek*task*getbound">&#09;</a><a name="common-func*mosek*task*getbound"></a> <a name="idx-117279992">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getbound (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt i,
    MSKboundkeye * bk,
    MSKrealt * bl,
    MSKrealt * bu);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable for which the bound information should be obtained.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (output)</dt>
<dd>Bound keys.</dd>
<dt><tt class="tt">bl</tt> (output)</dt>
<dd>Values for lower bounds.</dd>
<dt><tt class="tt">bu</tt> (output)</dt>
<dd>Values for upper bounds.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains bound information for one constraint or variable.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getboundslice</tt></span>

<p> <a name="func*mosek*task*getboundslice">&#09;</a><a name="common-func*mosek*task*getboundslice"></a> <a name="idx-117316568">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getboundslice (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt first,
    MSKidxt last,
    MSKboundkeye * bk,
    MSKrealt * bl,
    MSKrealt * bu);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>First index in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Last index plus 1 in the sequence.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (output)</dt>
<dd>Bound keys.</dd>
<dt><tt class="tt">bl</tt> (output)</dt>
<dd>Values for lower bounds.</dd>
<dt><tt class="tt">bu</tt> (output)</dt>
<dd>Values for upper bounds.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains bounds information for a sequence of variables or constraints.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getc</tt></span>

<p> <a name="func*mosek*task*getc">&#09;</a><a name="common-func*mosek*task*getc"></a> <a name="idx-117337336">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getc (
    MSKtask_t task,
    MSKrealt * c);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">c</tt> (output)</dt>
<dd>Linear terms of the objective as a dense vector. The lengths is the number of variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains all objective coefficients <span class="math"><span class="mi">c</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getcallbackfunc</tt></span>

<p> <a name="func*mosek*task*getcallbackfunc">&#09;</a><a name="common-func*mosek*task*getcallbackfunc"></a> <a name="idx-117305000">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getcallbackfunc (
    MSKtask_t task,
    MSKcallbackfunc * func,
    MSKuserhandle_t * handle);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">func</tt> (output)</dt>
<dd>Get the user-defined progress call-back function <a href="node017.html#common-typedef*mosek*callbackfunc"><tt class="tt">MSK_callbackfunc</tt></a> associated with <tt class="tt">task</tt>. If <tt class="tt">func</tt> is identical to <tt class="tt">NULL</tt>, then no call-back function is associated with the <tt class="tt">task</tt>.</dd>
<dt><tt class="tt">handle</tt> (output)</dt>
<dd>The user-defined pointer associated with the user-defined call-back function.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the current user-defined call-back function and associated <tt class="tt">userhandle</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getcfix</tt></span>

<p> <a name="func*mosek*task*getcfix">&#09;</a><a name="common-func*mosek*task*getcfix"></a> <a name="idx-117352136">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getcfix (
    MSKtask_t task,
    MSKrealt * cfix);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">cfix</tt> (output)</dt>
<dd>Fixed term in the objective.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the fixed term in the objective.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getcone</tt></span>

<p> <a name="func*mosek*task*getcone">&#09;</a><a name="common-func*mosek*task*getcone"></a> <a name="idx-117364208">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getcone (
    MSKtask_t task,
    MSKidxt k,
    MSKconetypee * conetype,
    MSKrealt * conepar,
    MSKintt * nummem,
    MSKidxt * submem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the cone constraint.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (output)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (output)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">nummem</tt> (output)</dt>
<dd>Number of member variables in the cone.</dd>
<dt><tt class="tt">submem</tt> (output)</dt>
<dd>Variable subscripts of the members in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a conic constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getconeinfo</tt></span>

<p> <a name="func*mosek*task*getconeinfo">&#09;</a><a name="common-func*mosek*task*getconeinfo"></a> <a name="idx-117363128">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getconeinfo (
    MSKtask_t task,
    MSKidxt k,
    MSKconetypee * conetype,
    MSKrealt * conepar,
    MSKintt * nummem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the conic constraint.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (output)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (output)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">nummem</tt> (output)</dt>
<dd>Number of member variables in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains information about a conic constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getconname</tt></span>

<p> <a name="func*mosek*task*getconname">&#09;</a><a name="common-func*mosek*task*getconname"></a> <a name="idx-117403448">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getconname (
    MSKtask_t task,
    MSKidxt i,
    MSKCONST size_t maxlen,
    char * name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Maximum length of name that can be stored in <tt class="tt">name</tt>.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a constraint.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getmaxnamelen"><tt class="tt">MSK_getmaxnamelen</tt></a></dt>
<dd>
<p> Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getconname64</tt></span>

<p> <a name="func*mosek*task*getconname64">&#09;</a><a name="common-func*mosek*task*getconname64"></a> <a name="idx-118941384">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getconname64 (
    MSKtask_t task,
    MSKidxt i,
    MSKint64t maxlen,
    char * name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Maximum length of name that can be stored in <tt class="tt">name</tt>.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a constraint.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getmaxnamelen"><tt class="tt">MSK_getmaxnamelen</tt></a></dt>
<dd>
<p> Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getcslice</tt></span>

<p> <a name="func*mosek*task*getcslice">&#09;</a><a name="common-func*mosek*task*getcslice"></a> <a name="idx-118955832">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getcslice (
    MSKtask_t task,
    MSKidxt first,
    MSKidxt last,
    MSKrealt * c);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>First index in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Last index plus 1 in the sequence.</dd>
<dt><tt class="tt">c</tt> (output)</dt>
<dd>Linear terms of the objective as a dense vector. The lengths is the number of variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a sequence of elements in <span class="math"><span class="mi">c</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getdbi</tt></span>

<p> <a name="func*mosek*task*getdbi">&#09;</a><a name="common-func*mosek*task*getdbi"></a> <a name="idx-118977960">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getdbi (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKaccmodee accmode,
    MSKCONST MSKidxt * sub,
    MSKintt len,
    MSKrealt * dbi);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a> then <tt class="tt">sub</tt> contains constraint indexes, otherwise variable indexes.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of constraints or variables.</dd>
<dt><tt class="tt">len</tt> (input)</dt>
<dd>Length of <tt class="tt">sub</tt></dd>
<dt><tt class="tt">dbi</tt> (output)</dt>
<dd>
<p>Dual bound infeasibility. If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math908.png" alt="\begin{math}\nonumber{}{dbi}[i]=\max (-(s_{l}^{c})_{{{sub}[i]}},-(s_{u}^{c})_{{{sub}[i]}},0)\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.4.1)</td></tr>
</tbody>
</table>

<p> else </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math909.png" alt="\begin{math}\nonumber{}{dbi}[i]=\max (-(s_{l}^{x})_{{{sub}[i]}},-(s_{u}^{x})_{{{sub}[i]}},0)\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}.\end{math}"/></td>
<td>(15.4.2)</td></tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the dual bound infeasibility.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getdcni</tt></span>

<p> <a name="func*mosek*task*getdcni">&#09;</a><a name="common-func*mosek*task*getdcni"></a> <a name="idx-119009008">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getdcni (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKCONST MSKidxt * sub,
    MSKintt len,
    MSKrealt * dcni);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Constraint indexes to calculate equation infeasibility for.</dd>
<dt><tt class="tt">len</tt> (input)</dt>
<dd>Length of <tt class="tt">sub</tt> and <tt class="tt">dcni</tt></dd>
<dt><tt class="tt">dcni</tt> (output)</dt>
<dd><tt class="tt">dcni[i]</tt> contains dual cone infeasibility for the cone with index <tt class="tt">sub[i]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the dual cone infeasibility.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getdeqi</tt></span>

<p> <a name="func*mosek*task*getdeqi">&#09;</a><a name="common-func*mosek*task*getdeqi"></a> <a name="idx-119031136">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getdeqi (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKaccmodee accmode,
    MSKCONST MSKidxt * sub,
    MSKintt len,
    MSKrealt * deqi,
    MSKintt normalize);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a> the dual equation infeasibilitys corresponding to constraints are retrieved. Otherwise for a variables.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of constraints or variables.</dd>
<dt><tt class="tt">len</tt> (input)</dt>
<dd>Length of <tt class="tt">sub</tt> and <tt class="tt">deqi</tt>.</dd>
<dt><tt class="tt">deqi</tt> (output)</dt>
<dd>Dual equation infeasibilitys corresponding to constraints or variables.</dd>
<dt><tt class="tt">normalize</tt> (input)</dt>
<dd>If non-zero, normalize with largest absolute value of the input data used to compute the individual infeasibility.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Optains the dual equation infeasibility. If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math910.png" alt="\begin{math}\nonumber{}{pbi}[i]=\left|(-y+s_{l}^{c}-s_{u}^{c})_{{{sub}[i]}}\right|\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.4.3)</td></tr>
</tbody>
</table>

<p> If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">MSK_ACC_VAR</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math911.png" alt="\begin{math}\nonumber{}{pbi}[i]=\left|(A^{T}y+s_{l}^{x}-s_{u}^{x}-c)_{{{sub}[i]}}\right|\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.4.4)</td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getdouinf</tt></span>

<p> <a name="func*mosek*task*getdouinf">&#09;</a><a name="common-func*mosek*task*getdouinf"></a> <a name="idx-119078352">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getdouinf (
    MSKtask_t task,
    MSKdinfiteme whichdinf,
    MSKrealt * dvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*dinfitem"><tt class="tt">whichdinf</tt></a> (input)</dt>
<dd>A <tt class="tt">double</tt> information item. See section <a title="18.13. Double information items" href="node020.html#constclass*mosek*dinfitem">18.13</a> for the possible values.</dd>
<dt><tt class="tt">dvalue</tt> (output)</dt>
<dd>The value of the required double information item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a double information item from the task information database.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getdouparam</tt></span>

<p> <a name="func*mosek*task*getdouparam">&#09;</a><a name="common-func*mosek*task*getdouparam"></a> <a name="idx-119038896">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getdouparam (
    MSKtask_t task,
    MSKdparame param,
    MSKrealt * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node018.html#common-constclass*mosek*dparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (output)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of a double parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getdualobj</tt></span>

<p> <a name="func*mosek*task*getdualobj">&#09;</a><a name="common-func*mosek*task*getdualobj"></a> <a name="idx-119108600">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getdualobj (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKrealt * dualobj);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">dualobj</tt> (output)</dt>
<dd>Objective value corresponding to the dual solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the current objective value of the dual problem for <tt class="tt">whichsol</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getenv</tt></span>

<p> <a name="func*mosek*task*getenv">&#09;</a><a name="common-func*mosek*task*getenv"></a> <a name="idx-119116792">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getenv (
    MSKtask_t task,
    MSKenv_t * env);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">env</tt> (output)</dt>
<dd>The MOSEK environment.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the environment used to create the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getinfeasiblesubproblem</tt></span>

<p> <a name="func*mosek*task*getinfeasiblesubproblem">&#09;</a><a name="common-func*mosek*task*getinfeasiblesubproblem"></a> <a name="idx-119130592">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getinfeasiblesubproblem (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKtask_t * inftask);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Which solution to use when determining the infeasible subproblem.</dd>
<dt><tt class="tt">inftask</tt> (output)</dt>
<dd>A new task containing the infeasible subproblem.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an infeasible subproblem. The infeasible subproblem is a problem consisting of a subset of the original constraints such that the problem is still infeasible. For more information see Section <a title="10.2. Analyzing infeasible problems" href="node012.html#sec-analysing-infeasible-problems">10.2</a>.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node018.html#common-const*mosek*iparam*infeas-prefer-primal"><tt class="tt">MSK_IPAR_INFEAS_PREFER_PRIMAL</tt></a></dt>
<dd></dd>
<dt><a href="node017.html#common-func*mosek*task*relaxprimal"><tt class="tt">MSK_relaxprimal</tt></a></dt>
<dd>
<p> Creates a problem that finds the minimal change to the bounds that makes an infeasible problem feasible.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getinfindex</tt></span>

<p> <a name="func*mosek*task*getinfindex">&#09;</a><a name="common-func*mosek*task*getinfindex"></a> <a name="idx-119154160">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getinfindex (
    MSKtask_t task,
    MSKinftypee inftype,
    MSKCONST char * infname,
    MSKintt * infindex);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*inftype"><tt class="tt">inftype</tt></a> (input)</dt>
<dd>Type of the information item.</dd>
<dt><tt class="tt">infname</tt> (input)</dt>
<dd>Name of the information item.</dd>
<dt><tt class="tt">infindex</tt> (output)</dt>
<dd>The item index.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the index of a named information item.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getinfmax</tt></span>

<p> <a name="func*mosek*task*getinfmax">&#09;</a><a name="common-func*mosek*task*getinfmax"></a> <a name="idx-119042200">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getinfmax (
    MSKtask_t task,
    MSKinftypee inftype,
    MSKintt * infmax);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*inftype"><tt class="tt">inftype</tt></a> (input)</dt>
<dd>Type of the information item.</dd>
<dt><tt class="tt">infmax</tt> (output)</dt>
<dd></dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the maximum index of an information of a given type <tt class="tt">inftype</tt> plus 1.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getinfname</tt></span>

<p> <a name="func*mosek*task*getinfname">&#09;</a><a name="common-func*mosek*task*getinfname"></a> <a name="idx-119180968">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getinfname (
    MSKtask_t task,
    MSKinftypee inftype,
    MSKintt whichinf,
    char * infname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*inftype"><tt class="tt">inftype</tt></a> (input)</dt>
<dd>Type of the information item.</dd>
<dt><tt class="tt">whichinf</tt> (input)</dt>
<dd>An information item. See section <a title="18.13. Double information items" href="node020.html#constclass*mosek*dinfitem">18.13</a> and section <a title="18.16. Integer information items." href="node020.html#constclass*mosek*iinfitem">18.16</a> for the possible values.</dd>
<dt><tt class="tt">infname</tt> (output)</dt>
<dd>Name of the information item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name of an information item.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getinti</tt></span>

<p> <a name="func*mosek*task*getinti">&#09;</a><a name="common-func*mosek*task*getinti"></a> <a name="idx-119186496">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getinti (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKCONST MSKidxt * sub,
    MSKintt len,
    MSKrealt * inti);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Variable indexes for which to calculate the integer infeasibility.</dd>
<dt><tt class="tt">len</tt> (input)</dt>
<dd>Length of <tt class="tt">sub</tt> and <tt class="tt">inti</tt></dd>
<dt><tt class="tt">inti</tt> (output)</dt>
<dd><tt class="tt">inti[i]</tt> contains integer infeasibility of variable <tt class="tt">sub[i]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the primal equation infeasibility. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math912.png" alt="\begin{math}\nonumber{}{peqi}[i]=\left|(\right|(Ax-x^{c})_{{{sub}[i]}})\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len}-1.\end{math}"/></td>
<td>(15.4.5)</td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getintinf</tt></span>

<p> <a name="func*mosek*task*getintinf">&#09;</a><a name="common-func*mosek*task*getintinf"></a> <a name="idx-120602280">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getintinf (
    MSKtask_t task,
    MSKiinfiteme whichiinf,
    MSKintt * ivalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*iinfitem"><tt class="tt">whichiinf</tt></a> (input)</dt>
<dd>Specifies an information item.</dd>
<dt><tt class="tt">ivalue</tt> (output)</dt>
<dd>The value of the required integer information item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an integer information item from the task information database.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getintparam</tt></span>

<p> <a name="func*mosek*task*getintparam">&#09;</a><a name="common-func*mosek*task*getintparam"></a> <a name="idx-119190880">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getintparam (
    MSKtask_t task,
    MSKiparame param,
    MSKintt * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (output)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of an integer parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getintpntnumthreads</tt></span>

<p> <a name="func*mosek*task*getintpntnumthreads">&#09;</a><a name="common-func*mosek*task*getintpntnumthreads"></a> <a name="idx-120626784">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getintpntnumthreads (
    MSKtask_t task,
    MSKintt * numthreads);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numthreads</tt> (output)</dt>
<dd>The number of threads.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of threads used by the interior-point optimizer. If <a href="node018.html#common-const*mosek*iparam*intpnt-num-threads"><tt class="tt">MSK_IPAR_INTPNT_NUM_THREADS</tt></a> is set to zero this function will return the number of cores on the system. Otherwise it return the value of <a href="node018.html#common-const*mosek*iparam*intpnt-num-threads"><tt class="tt">MSK_IPAR_INTPNT_NUM_THREADS</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getlasterror</tt></span>

<p> <a name="func*mosek*task*getlasterror">&#09;</a><a name="common-func*mosek*task*getlasterror"></a> <a name="idx-120638424">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getlasterror (
    MSKtask_t task,
    MSKrescodee * lastrescode,
    MSKCONST size_t maxlen,
    size_t * lastmsglen,
    char * lastmsg);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">lastrescode</tt></a> (output)</dt>
<dd>Returns the last error code reported in the task.</dd>
<dt><tt class="tt">maxlen</tt> </dt>
<dd>The length if the lastmsg buffer.</dd>
<dt><tt class="tt">lastmsglen</tt> (output)</dt>
<dd>Returns the length of the last error message reported in the task.</dd>
<dt><tt class="tt">lastmsg</tt> (output)</dt>
<dd>Returns the the last error message reported in the task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the last response code and corresponding message reported in MOSEK.</p>

<p>If there is no previous error, warning or termination code for this task, <tt class="tt">lastrescode</tt> returns <a href="#common-const*mosek*rescode*ok"><tt class="tt">MSK_RES_OK</tt></a> and <tt class="tt">lastmsg</tt> returns an empty string, otherwise the last response code different from <a href="#common-const*mosek*rescode*ok"><tt class="tt">MSK_RES_OK</tt></a> and the corresponding message are returned.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getlasterror64</tt></span>

<p> <a name="func*mosek*task*getlasterror64">&#09;</a><a name="common-func*mosek*task*getlasterror64"></a> <a name="idx-120658688">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getlasterror64 (
    MSKtask_t task,
    MSKrescodee * lastrescode,
    MSKint64t maxlen,
    MSKint64t * lastmsglen,
    char * lastmsg);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">lastrescode</tt></a> (output)</dt>
<dd>Returns the last error code reported in the task.</dd>
<dt><tt class="tt">maxlen</tt> </dt>
<dd>The length if the lastmsg buffer.</dd>
<dt><tt class="tt">lastmsglen</tt> (output)</dt>
<dd>Returns the length of the last error message reported in the task.</dd>
<dt><tt class="tt">lastmsg</tt> (output)</dt>
<dd>Returns the the last error message reported in the task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the last response code and corresponding message reported in MOSEK.</p>

<p>If there is no previous error, warning or termination code for this task, <tt class="tt">lastrescode</tt> returns <a href="#common-const*mosek*rescode*ok"><tt class="tt">MSK_RES_OK</tt></a> and <tt class="tt">lastmsg</tt> returns an empty string, otherwise the last response code different from <a href="#common-const*mosek*rescode*ok"><tt class="tt">MSK_RES_OK</tt></a> and the corresponding message are returned.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getlintinf</tt></span>

<p> <a name="func*mosek*task*getlintinf">&#09;</a><a name="common-func*mosek*task*getlintinf"></a> <a name="idx-120678088">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getlintinf (
    MSKtask_t task,
    MSKliinfiteme whichliinf,
    MSKint64t * ivalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*liinfitem"><tt class="tt">whichliinf</tt></a> (input)</dt>
<dd>Specifies an information item.</dd>
<dt><tt class="tt">ivalue</tt> (output)</dt>
<dd>The value of the required integer information item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an integer information item from the task information database.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmaxnamelen</tt></span>

<p> <a name="func*mosek*task*getmaxnamelen">&#09;</a><a name="common-func*mosek*task*getmaxnamelen"></a> <a name="idx-120689152">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmaxnamelen (
    MSKtask_t task,
    size_t * maxlen);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxlen</tt> (output)</dt>
<dd>The maximum length of any name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmaxnumanz</tt></span>

<p> <a name="func*mosek*task*getmaxnumanz">&#09;</a><a name="common-func*mosek*task*getmaxnumanz"></a> <a name="idx-120696128">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmaxnumanz (
    MSKtask_t task,
    MSKintt * maxnumanz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumanz</tt> (output)</dt>
<dd>Number of preallocated non-zero elements in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains number of preallocated non-zeros in <span class="math"><span class="mi">A</span></span>. When this number of non-zeros is reached MOSEK will automatically allocate more space for <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmaxnumanz64</tt></span>

<p> <a name="func*mosek*task*getmaxnumanz64">&#09;</a><a name="common-func*mosek*task*getmaxnumanz64"></a> <a name="idx-120715456">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmaxnumanz64 (
    MSKtask_t task,
    MSKint64t * maxnumanz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumanz</tt> (output)</dt>
<dd>Number of preallocated non-zero elements in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains number of preallocated non-zeros in <span class="math"><span class="mi">A</span></span>. When this number of non-zeros is reached MOSEK will automatically allocate more space for <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmaxnumcon</tt></span>

<p> <a name="func*mosek*task*getmaxnumcon">&#09;</a><a name="common-func*mosek*task*getmaxnumcon"></a> <a name="idx-120720632">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmaxnumcon (
    MSKtask_t task,
    MSKintt * maxnumcon);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumcon</tt> (output)</dt>
<dd>Number of preallocated constraints in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of preallocated constraints in the optimization task. When this number of constraints is reached MOSEK will automatically allocate more space for constraints.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmaxnumcone</tt></span>

<p> <a name="func*mosek*task*getmaxnumcone">&#09;</a><a name="common-func*mosek*task*getmaxnumcone"></a> <a name="idx-120735360">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmaxnumcone (
    MSKtask_t task,
    MSKintt * maxnumcone);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumcone</tt> (output)</dt>
<dd>Number of preallocated conic constraints in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of preallocated cones in the optimization task. When this number of cones is reached MOSEK will automatically allocate space for more cones.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmaxnumqnz</tt></span>

<p> <a name="func*mosek*task*getmaxnumqnz">&#09;</a><a name="common-func*mosek*task*getmaxnumqnz"></a> <a name="idx-120721776">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmaxnumqnz (
    MSKtask_t task,
    MSKintt * maxnumqnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumqnz</tt> (output)</dt>
<dd>Number of non-zero elements preallocated in quadratic coefficient matrices.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of preallocated non-zeros for <span class="math"><span class="mi">Q</span></span> (both objective and constraints). When this number of non-zeros is reached MOSEK will automatically allocate more space for <span class="math"><span class="mi">Q</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmaxnumqnz64</tt></span>

<p> <a name="func*mosek*task*getmaxnumqnz64">&#09;</a><a name="common-func*mosek*task*getmaxnumqnz64"></a> <a name="idx-120759144">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmaxnumqnz64 (
    MSKtask_t task,
    MSKint64t * maxnumqnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumqnz</tt> (output)</dt>
<dd>Number of non-zero elements preallocated in quadratic coefficient matrices.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of preallocated non-zeros for <span class="math"><span class="mi">Q</span></span> (both objective and constraints). When this number of non-zeros is reached MOSEK will automatically allocate more space for <span class="math"><span class="mi">Q</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmaxnumvar</tt></span>

<p> <a name="func*mosek*task*getmaxnumvar">&#09;</a><a name="common-func*mosek*task*getmaxnumvar"></a> <a name="idx-120758424">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmaxnumvar (
    MSKtask_t task,
    MSKintt * maxnumvar);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumvar</tt> (output)</dt>
<dd>Number of preallocated variables in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of preallocated variables in the optimization task. When this number of variables is reached MOSEK will automatically allocate more space for constraints.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmemusagetask</tt></span>

<p> <a name="func*mosek*task*getmemusagetask">&#09;</a><a name="common-func*mosek*task*getmemusagetask"></a> <a name="idx-120778192">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmemusagetask (
    MSKtask_t task,
    size_t * meminuse,
    size_t * maxmemuse);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">meminuse</tt> (output)</dt>
<dd>Amount of memory currently used by the <tt class="tt">task</tt>.</dd>
<dt><tt class="tt">maxmemuse</tt> (output)</dt>
<dd>Maximum amount of memory used by the <tt class="tt">task</tt> until now.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains information about the amount of memory used by a task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getmemusagetask64</tt></span>

<p> <a name="func*mosek*task*getmemusagetask64">&#09;</a><a name="common-func*mosek*task*getmemusagetask64"></a> <a name="idx-120783432">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getmemusagetask64 (
    MSKtask_t task,
    MSKint64t * meminuse,
    MSKint64t * maxmemuse);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">meminuse</tt> (output)</dt>
<dd>Amount of memory currently used by the <tt class="tt">task</tt>.</dd>
<dt><tt class="tt">maxmemuse</tt> (output)</dt>
<dd>Maximum amount of memory used by the <tt class="tt">task</tt> until now.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains information about the amount of memory used by a task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnadouinf</tt></span>

<p> <a name="func*mosek*task*getnadouinf">&#09;</a><a name="common-func*mosek*task*getnadouinf"></a> <a name="idx-120802840">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnadouinf (
    MSKtask_t task,
    MSKCONST char * whichdinf,
    MSKrealt * dvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">whichdinf</tt> (input)</dt>
<dd>A <tt class="tt">double</tt> information item. See section <a title="18.13. Double information items" href="node020.html#constclass*mosek*dinfitem">18.13</a> for the possible values.</dd>
<dt><tt class="tt">dvalue</tt> (output)</dt>
<dd>The value of the required double information item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a double information item from task information database.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnadouparam</tt></span>

<p> <a name="func*mosek*task*getnadouparam">&#09;</a><a name="common-func*mosek*task*getnadouparam"></a> <a name="idx-120807648">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnadouparam (
    MSKtask_t task,
    MSKCONST char * paramname,
    MSKrealt * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">parvalue</tt> (output)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of a named double parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnaintinf</tt></span>

<p> <a name="func*mosek*task*getnaintinf">&#09;</a><a name="common-func*mosek*task*getnaintinf"></a> <a name="idx-120826048">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnaintinf (
    MSKtask_t task,
    MSKCONST char * infitemname,
    MSKintt * ivalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">infitemname</tt> (input)</dt>
<dd></dd>
<dt><tt class="tt">ivalue</tt> (output)</dt>
<dd>The value of the required integer information item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an integer information item from the task information database.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnaintparam</tt></span>

<p> <a name="func*mosek*task*getnaintparam">&#09;</a><a name="common-func*mosek*task*getnaintparam"></a> <a name="idx-120832584">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnaintparam (
    MSKtask_t task,
    MSKCONST char * paramname,
    MSKintt * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">parvalue</tt> (output)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of a named integer parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getname</tt></span>

<p> <a name="func*mosek*task*getname">&#09;</a><a name="common-func*mosek*task*getname"></a> <a name="idx-122412208">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getname (
    MSKtask_t task,
    MSKproblemiteme whichitem,
    MSKidxt i,
    MSKCONST size_t maxlen,
    size_t * len,
    char * name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Maximum length of name that can be stored in <tt class="tt">name</tt>. The buffer <tt class="tt">name</tt> must be be able to hold the name including a terminating zero character.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the required name.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a problem item, i.e. a cone, a variable or a constraint.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getmaxnamelen"><tt class="tt">MSK_getmaxnamelen</tt></a></dt>
<dd>
<p> Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getname64</tt></span>

<p> <a name="func*mosek*task*getname64">&#09;</a><a name="common-func*mosek*task*getname64"></a> <a name="idx-122433480">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getname64 (
    MSKtask_t task,
    MSKproblemiteme whichitem,
    MSKidxt i,
    MSKint64t maxlen,
    MSKint64t * len,
    char * name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Maximum length of name that can be stored in <tt class="tt">name</tt>. The buffer <tt class="tt">name</tt> must be be able to hold the name including a terminating zero character.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the required name.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a problem item, i.e. a cone, a variable or a constraint.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getmaxnamelen"><tt class="tt">MSK_getmaxnamelen</tt></a></dt>
<dd>
<p> Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnameapi64</tt></span>

<p> <a name="func*mosek*task*getnameapi64">&#09;</a><a name="common-func*mosek*task*getnameapi64"></a> <a name="idx-122453672">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnameapi64 (
    MSKtask_t task,
    MSKproblemiteme whichitem,
    MSKidxt i,
    MSKint64t maxlen,
    char * name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Maximum length of name that can be stored in <tt class="tt">name</tt>. The buffer <tt class="tt">name</tt> must be be able to hold the name including a terminating zero character.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a problem item, i.e. a cone, a variable or a constraint.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getmaxnamelen"><tt class="tt">MSK_getmaxnamelen</tt></a></dt>
<dd>
<p> Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnameindex</tt></span>

<p> <a name="func*mosek*task*getnameindex">&#09;</a><a name="common-func*mosek*task*getnameindex"></a> <a name="idx-122472784">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnameindex (
    MSKtask_t task,
    MSKproblemiteme whichitem,
    MSKCONST char * name,
    MSKintt * asgn,
    MSKidxt * index);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">name</tt> (input)</dt>
<dd>The name which should be checked.</dd>
<dt><tt class="tt">asgn</tt> (output)</dt>
<dd>Is non-zero if <tt class="tt">name</tt> is assigned.</dd>
<dt><tt class="tt">index</tt> (output)</dt>
<dd>If the <tt class="tt">name</tt> identifies an item in the task, then <tt class="tt">index</tt> is assigned the index of that item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks if a given name identifies a cone, a constraint or a variable in the <tt class="tt">task</tt>. If it does, the index of that item is assigned to <tt class="tt">index</tt>, and a non-zero value is assigned to <tt class="tt">asgn</tt>. If the name does not identify a problem item, <tt class="tt">asgn</tt> is assigned a zero.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnamelen64</tt></span>

<p> <a name="func*mosek*task*getnamelen64">&#09;</a><a name="common-func*mosek*task*getnamelen64"></a> <a name="idx-122451800">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnamelen64 (
    MSKtask_t task,
    MSKproblemiteme whichitem,
    MSKidxt i,
    MSKint64t * len);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the length of a problem item name.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getmaxnamelen"><tt class="tt">MSK_getmaxnamelen</tt></a></dt>
<dd>
<p> Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getname"><tt class="tt">MSK_getname</tt></a></dt>
<dd>
<p> Obtains the name of a cone, a variable or a constraint.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getname64"><tt class="tt">MSK_getname64</tt></a></dt>
<dd>
<p> Obtains the name of a cone, a variable or a constraint.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnastrparam</tt></span>

<p> <a name="func*mosek*task*getnastrparam">&#09;</a><a name="common-func*mosek*task*getnastrparam"></a> <a name="idx-122482488">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnastrparam (
    MSKtask_t task,
    MSKCONST char * paramname,
    MSKCONST size_t maxlen,
    size_t * len,
    char * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Length of <tt class="tt">parvalue</tt>.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Identical to length of string hold by <tt class="tt">parvalue</tt>.</dd>
<dt><tt class="tt">parvalue</tt> (output)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of a named string parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnastrparamal</tt></span>

<p> <a name="func*mosek*task*getnastrparamal">&#09;</a><a name="common-func*mosek*task*getnastrparamal"></a> <a name="idx-122543496">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnastrparamal (
    MSKtask_t task,
    MSKCONST char * paramname,
    MSKCONST size_t numaddchr,
    MSKstring_t * value);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">numaddchr</tt> (input)</dt>
<dd>Number of additional characters that is made room for in <tt class="tt">value[0]</tt>.</dd>
<dt><tt class="tt">value</tt> (input/output)</dt>
<dd>Is the value corresponding to string parameter <tt class="tt">param</tt>. <tt class="tt">value[0]</tt> is char buffer allocated MOSEK and it must be freed by <a href="node017.html#common-func*mosek*task*freetask"><tt class="tt">MSK_freetask</tt></a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of a string parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnlfunc</tt></span>

<p> <a name="func*mosek*task*getnlfunc">&#09;</a><a name="common-func*mosek*task*getnlfunc"></a> <a name="idx-122555712">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnlfunc (
    MSKtask_t task,
    MSKuserhandle_t * nlhandle,
    MSKnlgetspfunc * nlgetsp,
    MSKnlgetvafunc * nlgetva);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">nlhandle</tt> (input/output)</dt>
<dd>Retrieve the pointer to the user-defined data structure. This structure is passed to the functions <tt class="tt">nlgetsp</tt> and <tt class="tt">nlgetva</tt> whenever those two functions called.</dd>
<dt><tt class="tt">nlgetsp</tt> (output)</dt>
<dd>Retrieve the function which provide information about the structure of the nonlinear functions in the optimization problem.</dd>
<dt><tt class="tt">nlgetva</tt> (output)</dt>
<dd>Retrieve the function which is used to evaluate the nonlinear function in the optimization problem at a given point.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>This function is used to retrieve the nonlinear call-back functions. If NULL no nonlinear call-back function exists.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumanz</tt></span>

<p> <a name="func*mosek*task*getnumanz">&#09;</a><a name="common-func*mosek*task*getnumanz"></a> <a name="idx-122531568">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumanz (
    MSKtask_t task,
    MSKintt * numanz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numanz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zeros in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumanz64</tt></span>

<p> <a name="func*mosek*task*getnumanz64">&#09;</a><a name="common-func*mosek*task*getnumanz64"></a> <a name="idx-122579568">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumanz64 (
    MSKtask_t task,
    MSKint64t * numanz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numanz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zeros in <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumcon</tt></span>

<p> <a name="func*mosek*task*getnumcon">&#09;</a><a name="common-func*mosek*task*getnumcon"></a> <a name="idx-122565480">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumcon (
    MSKtask_t task,
    MSKintt * numcon);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numcon</tt> (output)</dt>
<dd>Number of constraints.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of constraints.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumcone</tt></span>

<p> <a name="func*mosek*task*getnumcone">&#09;</a><a name="common-func*mosek*task*getnumcone"></a> <a name="idx-122597176">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumcone (
    MSKtask_t task,
    MSKintt * numcone);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numcone</tt> (output)</dt>
<dd>Number conic constraints.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of cones.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumconemem</tt></span>

<p> <a name="func*mosek*task*getnumconemem">&#09;</a><a name="common-func*mosek*task*getnumconemem"></a> <a name="idx-122601912">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumconemem (
    MSKtask_t task,
    MSKidxt k,
    MSKintt * nummem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the cone.</dd>
<dt><tt class="tt">nummem</tt> (output)</dt>
<dd>Number of member variables in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of members in a cone.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumintvar</tt></span>

<p> <a name="func*mosek*task*getnumintvar">&#09;</a><a name="common-func*mosek*task*getnumintvar"></a> <a name="idx-122617368">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumintvar (
    MSKtask_t task,
    MSKintt * numintvar);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numintvar</tt> (output)</dt>
<dd>Number of integer variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of integer-constrained variables.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumparam</tt></span>

<p> <a name="func*mosek*task*getnumparam">&#09;</a><a name="common-func*mosek*task*getnumparam"></a> <a name="idx-122631664">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumparam (
    MSKtask_t task,
    MSKparametertypee partype,
    MSKintt * numparam);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*parametertype"><tt class="tt">partype</tt></a> (input)</dt>
<dd>Parameter type.</dd>
<dt><tt class="tt">numparam</tt> (output)</dt>
<dd>Identical to the number of parameters of the type <tt class="tt">partype</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of parameters of a given type.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumqconknz</tt></span>

<p> <a name="func*mosek*task*getnumqconknz">&#09;</a><a name="common-func*mosek*task*getnumqconknz"></a> <a name="idx-122640864">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumqconknz (
    MSKtask_t task,
    MSKidxt k,
    MSKintt * numqcnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the constraint for which the number of non-zero quadratic terms should be obtained.</dd>
<dt><tt class="tt">numqcnz</tt> (output)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero quadratic terms in a constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumqconknz64</tt></span>

<p> <a name="func*mosek*task*getnumqconknz64">&#09;</a><a name="common-func*mosek*task*getnumqconknz64"></a> <a name="idx-122647544">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumqconknz64 (
    MSKtask_t task,
    MSKidxt k,
    MSKint64t * numqcnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the constraint for which the number quadratic terms should be obtained.</dd>
<dt><tt class="tt">numqcnz</tt> (output)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero quadratic terms in a constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumqobjnz</tt></span>

<p> <a name="func*mosek*task*getnumqobjnz">&#09;</a><a name="common-func*mosek*task*getnumqobjnz"></a> <a name="idx-122662712">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumqobjnz (
    MSKtask_t task,
    MSKintt * numqonz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numqonz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math36.png" alt="[[MathCmd 36]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero quadratic terms in the objective.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumqobjnz64</tt></span>

<p> <a name="func*mosek*task*getnumqobjnz64">&#09;</a><a name="common-func*mosek*task*getnumqobjnz64"></a> <a name="idx-113326056">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumqobjnz64 (
    MSKtask_t task,
    MSKint64t * numqonz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numqonz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math36.png" alt="[[MathCmd 36]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of non-zero quadratic terms in the objective.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getnumvar</tt></span>

<p> <a name="func*mosek*task*getnumvar">&#09;</a><a name="common-func*mosek*task*getnumvar"></a> <a name="idx-113331160">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getnumvar (
    MSKtask_t task,
    MSKintt * numvar);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numvar</tt> (output)</dt>
<dd>Number of variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the number of variables.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getobjname</tt></span>

<p> <a name="func*mosek*task*getobjname">&#09;</a><a name="common-func*mosek*task*getobjname"></a> <a name="idx-113347904">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getobjname (
    MSKtask_t task,
    MSKCONST size_t maxlen,
    size_t * len,
    char * objname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Length of <tt class="tt">objname</tt>.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Assigned the length of the objective name.</dd>
<dt><tt class="tt">objname</tt> (output)</dt>
<dd>Assigned the objective name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name assigned to the objective function.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getobjname64</tt></span>

<p> <a name="func*mosek*task*getobjname64">&#09;</a><a name="common-func*mosek*task*getobjname64"></a> <a name="idx-113358392">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getobjname64 (
    MSKtask_t task,
    MSKint64t maxlen,
    MSKint64t * len,
    char * objname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Length of <tt class="tt">objname</tt>.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Assigned the length of the objective name.</dd>
<dt><tt class="tt">objname</tt> (output)</dt>
<dd>Assigned the objective name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name assigned to the objective function.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getobjsense</tt></span>

<p> <a name="func*mosek*task*getobjsense">&#09;</a><a name="common-func*mosek*task*getobjsense"></a> <a name="idx-113381104">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getobjsense (
    MSKtask_t task,
    MSKobjsensee * sense);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*objsense"><tt class="tt">sense</tt></a> (output)</dt>
<dd>The returned objective sense.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Gets the objective sense of the task.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putobjsense"><tt class="tt">MSK_putobjsense</tt></a></dt>
<dd>
<p> Sets the objective sense.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getparammax</tt></span>

<p> <a name="func*mosek*task*getparammax">&#09;</a><a name="common-func*mosek*task*getparammax"></a> <a name="idx-113393104">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getparammax (
    MSKtask_t task,
    MSKparametertypee partype,
    MSKCONST MSKintt * parammax);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*parametertype"><tt class="tt">partype</tt></a> (input)</dt>
<dd>Parameter type.</dd>
<dt><tt class="tt">parammax</tt> (input)</dt>
<dd></dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the maximum index of a parameter of a given type plus 1.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getparamname</tt></span>

<p> <a name="func*mosek*task*getparamname">&#09;</a><a name="common-func*mosek*task*getparamname"></a> <a name="idx-113386416">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getparamname (
    MSKtask_t task,
    MSKparametertypee partype,
    MSKintt param,
    char * parname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*parametertype"><tt class="tt">partype</tt></a> (input)</dt>
<dd>Parameter type.</dd>
<dt><tt class="tt">param</tt> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parname</tt> (output)</dt>
<dd>Parameter name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name for a parameter <tt class="tt">param</tt> of type <tt class="tt">partype</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getpbi</tt></span>

<p> <a name="func*mosek*task*getpbi">&#09;</a><a name="common-func*mosek*task*getpbi"></a> <a name="idx-113421056">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getpbi (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKaccmodee accmode,
    MSKCONST MSKidxt * sub,
    MSKintt len,
    MSKrealt * pbi,
    MSKintt normalize);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">MSK_ACC_VAR</tt></a> return bound infeasibility for <span class="math"><span class="mi">x</span></span> otherwise for <span class="math"><img src="math/math289.png" alt="[[MathCmd 289]]"/></span>.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>An array of constraint or variable indexes.</dd>
<dt><tt class="tt">len</tt> (input)</dt>
<dd>Length of <tt class="tt">sub</tt> and <tt class="tt">pbi</tt></dd>
<dt><tt class="tt">pbi</tt> (output)</dt>
<dd>Bound infeasibility for <span class="math"><span class="mi">x</span></span> or <span class="math"><img src="math/math289.png" alt="[[MathCmd 289]]"/></span>.</dd>
<dt><tt class="tt">normalize</tt> (input)</dt>
<dd>If non-zero, normalize with largest absolute value of the input data used to compute the individual infeasibility.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the primal bound infeasibility. If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math917.png" alt="\begin{math}\nonumber{}{pbi}[i]=\max (x^{c}_{{{sub[i]}}}-u^{c}_{{{sub[i]}}},l^{c}_{{{sub[i]}}}-x^{c}_{{{sub[i]}}},0)\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.4.6)</td></tr>
</tbody>
</table>

<p> If <tt class="tt">acmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">MSK_ACC_VAR</tt></a> then </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math918.png" alt="\begin{math}\nonumber{}{pbi}[i]=\max (x_{{{sub[i]}}}-u^{x}_{{{sub[i]}}},l^{x}_{{{sub[i]}}}-x_{{{sub[i]}}},0)\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len-1}\end{math}"/></td>
<td>(15.4.7)</td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getpcni</tt></span>

<p> <a name="func*mosek*task*getpcni">&#09;</a><a name="common-func*mosek*task*getpcni"></a> <a name="idx-113460576">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getpcni (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKCONST MSKidxt * sub,
    MSKintt len,
    MSKrealt * pcni);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Constraint indexes for which to calculate the equation infeasibility.</dd>
<dt><tt class="tt">len</tt> (input)</dt>
<dd>Length of <tt class="tt">sub</tt> and <tt class="tt">pcni</tt></dd>
<dt><tt class="tt">pcni</tt> (output)</dt>
<dd><tt class="tt">pcni[i]</tt> contains primal cone infeasibility for the cone with index <tt class="tt">sub[i]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the primal cone infeasibility.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getpeqi</tt></span>

<p> <a name="func*mosek*task*getpeqi">&#09;</a><a name="common-func*mosek*task*getpeqi"></a> <a name="idx-113484360">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getpeqi (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKCONST MSKidxt * sub,
    MSKintt len,
    MSKrealt * peqi,
    MSKintt normalize);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Constraint indexes for which to calculate the equation infeasibility.</dd>
<dt><tt class="tt">len</tt> (input)</dt>
<dd>Length of <tt class="tt">sub</tt> and <tt class="tt">peqi</tt></dd>
<dt><tt class="tt">peqi</tt> (output)</dt>
<dd><tt class="tt">peqi[i]</tt> contains equation infeasibility of constraint <tt class="tt">sub[i]</tt>.</dd>
<dt><tt class="tt">normalize</tt> (input)</dt>
<dd>If non-zero, normalize with largest absolute value of the input data used to compute the individual infeasibility.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the primal equation infeasibility. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math912.png" alt="\begin{math}\nonumber{}{peqi}[i]=\left|(\right|(Ax-x^{c})_{{{sub}[i]}})\quad{}\mathtt{for}\quad{}i=0,\ldots ,{len}-1.\end{math}"/></td>
<td>(15.4.8)</td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getprimalobj</tt></span>

<p> <a name="func*mosek*task*getprimalobj">&#09;</a><a name="common-func*mosek*task*getprimalobj"></a> <a name="idx-113483720">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getprimalobj (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKrealt * primalobj);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">primalobj</tt> (output)</dt>
<dd>Objective value corresponding to the primal solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the primal objective value for a solution.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getprobtype</tt></span>

<p> <a name="func*mosek*task*getprobtype">&#09;</a><a name="common-func*mosek*task*getprobtype"></a> <a name="idx-113536680">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getprobtype (
    MSKtask_t task,
    MSKproblemtypee * probtype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*problemtype"><tt class="tt">probtype</tt></a> (output)</dt>
<dd>The problem type.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the problem type.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getqconk</tt></span>

<p> <a name="func*mosek*task*getqconk">&#09;</a><a name="common-func*mosek*task*getqconk"></a> <a name="idx-113540776">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getqconk (
    MSKtask_t task,
    MSKidxt k,
    MSKintt maxnumqcnz,
    MSKintt * qcsurp,
    MSKintt * numqcnz,
    MSKidxt * qcsubi,
    MSKidxt * qcsubj,
    MSKrealt * qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Which constraint.</dd>
<dt><tt class="tt">maxnumqcnz</tt> (input)</dt>
<dd>Length of the arrays <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
<dt><tt class="tt">qcsurp</tt> (input/output)</dt>
<dd>When entering the function it is assumed that the last <tt class="tt">qcsurp[0]</tt> positions in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt> are free. Hence, the quadratic terms are stored in this area, and upon return <tt class="tt">qcsurp</tt> is number of free positions left in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
<dt><tt class="tt">numqcnz</tt> (output)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains all the quadratic terms in a constraint. The quadratic terms are stored sequentially <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getqconk64</tt></span>

<p> <a name="func*mosek*task*getqconk64">&#09;</a><a name="common-func*mosek*task*getqconk64"></a> <a name="idx-125967464">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getqconk64 (
    MSKtask_t task,
    MSKidxt k,
    MSKint64t maxnumqcnz,
    MSKint64t * qcsurp,
    MSKint64t * numqcnz,
    MSKidxt * qcsubi,
    MSKidxt * qcsubj,
    MSKrealt * qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Which constraint.</dd>
<dt><tt class="tt">maxnumqcnz</tt> (input)</dt>
<dd>Length of the arrays <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
<dt><tt class="tt">qcsurp</tt> (input/output)</dt>
<dd>When entering the function it is assumed that the last <tt class="tt">qcsurp[0]</tt> positions in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt> are free. Hence, the quadratic terms are stored in this area, and upon return <tt class="tt">qcsurp</tt> is number of free positions left in <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
<dt><tt class="tt">numqcnz</tt> (output)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains all the quadratic terms in a constraint. The quadratic terms are stored sequentially <tt class="tt">qcsubi</tt>, <tt class="tt">qcsubj</tt>, and <tt class="tt">qcval</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getqobj</tt></span>

<p> <a name="func*mosek*task*getqobj">&#09;</a><a name="common-func*mosek*task*getqobj"></a> <a name="idx-113381248">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getqobj (
    MSKtask_t task,
    MSKintt maxnumqonz,
    MSKintt * qosurp,
    MSKintt * numqonz,
    MSKidxt * qosubi,
    MSKidxt * qosubj,
    MSKrealt * qoval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumqonz</tt> (input)</dt>
<dd>The length of the arrays <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>.</dd>
<dt><tt class="tt">qosurp</tt> (input/output)</dt>
<dd>When entering the function <tt class="tt">qosurp[0]</tt> is the number of free positions at the end of the arrays <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>, and upon return <tt class="tt">qosurp</tt> is the updated number of free positions left in those arrays.</dd>
<dt><tt class="tt">numqonz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math36.png" alt="[[MathCmd 36]]"/></span>.</dd>
<dt><tt class="tt">qosubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscript for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
<dt><tt class="tt">qosubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscript for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
<dt><tt class="tt">qoval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the quadratic terms in the objective. The required quadratic terms are stored sequentially in <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getqobj64</tt></span>

<p> <a name="func*mosek*task*getqobj64">&#09;</a><a name="common-func*mosek*task*getqobj64"></a> <a name="idx-126029264">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getqobj64 (
    MSKtask_t task,
    MSKint64t maxnumqonz,
    MSKint64t * qosurp,
    MSKint64t * numqonz,
    MSKidxt * qosubi,
    MSKidxt * qosubj,
    MSKrealt * qoval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumqonz</tt> (input)</dt>
<dd>The length of the arrays <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>.</dd>
<dt><tt class="tt">qosurp</tt> (input/output)</dt>
<dd>When entering the function <tt class="tt">qosurp[0]</tt> is the number of free positions at the end of the arrays <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>, and upon return <tt class="tt">qosurp</tt> is the updated number of free positions left in those arrays.</dd>
<dt><tt class="tt">numqonz</tt> (output)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math36.png" alt="[[MathCmd 36]]"/></span>.</dd>
<dt><tt class="tt">qosubi</tt> (output)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscript for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
<dt><tt class="tt">qosubj</tt> (output)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscript for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
<dt><tt class="tt">qoval</tt> (output)</dt>
<dd>Numerical value for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the quadratic terms in the objective. The required quadratic terms are stored sequentially in <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getqobjij</tt></span>

<p> <a name="func*mosek*task*getqobjij">&#09;</a><a name="common-func*mosek*task*getqobjij"></a> <a name="idx-126057864">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getqobjij (
    MSKtask_t task,
    MSKidxt i,
    MSKidxt j,
    MSKrealt * qoij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Row index of the coefficient.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Column index of coefficient.</dd>
<dt><tt class="tt">qoij</tt> (output)</dt>
<dd>The required coefficient.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains one coefficient <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span> in the quadratic term of the objective.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getreducedcosts</tt></span>

<p> <a name="func*mosek*task*getreducedcosts">&#09;</a><a name="common-func*mosek*task*getreducedcosts"></a> <a name="idx-126038456">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getreducedcosts (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKidxt first,
    MSKidxt last,
    MSKrealt * redcosts);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>See formula (<a href="node017.html#ais-eq-redcost">15.4.9</a>) for the definition.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>See formula (<a href="node017.html#ais-eq-redcost">15.4.9</a>) for the definition.</dd>
<dt><tt class="tt">redcosts</tt> (output)</dt>
<dd>The reduced costs in the required sequence of variables are stored sequentially in <tt class="tt">redcosts</tt> starting at <tt class="tt">redcosts[0]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Computes the reduced costs for a sequence of variables and return them in the variable <tt class="tt">redcosts</tt> i.e. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math935.png" alt="\begin{math}\nonumber{}\mathtt{redcosts}[j-\mathtt{first}]=(s_{l}^{x})_{j}-(s_{u}^{x})_{j},~j=\mathtt{first},\ldots ,\mathtt{last}-1.\end{math}"/></td>
<td><a name="ais-eq-redcost">&#09;</a>(15.4.9)</td></tr>
</tbody>
</table>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getsolution</tt></span>

<p> <a name="func*mosek*task*getsolution">&#09;</a><a name="common-func*mosek*task*getsolution"></a> <a name="idx-126055344">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getsolution (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKprostae * prosta,
    MSKsolstae * solsta,
    MSKstakeye * skc,
    MSKstakeye * skx,
    MSKstakeye * skn,
    MSKrealt * xc,
    MSKrealt * xx,
    MSKrealt * y,
    MSKrealt * slc,
    MSKrealt * suc,
    MSKrealt * slx,
    MSKrealt * sux,
    MSKrealt * snx);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skc</tt></a> (output)</dt>
<dd>Status keys for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skx</tt></a> (output)</dt>
<dd>Status keys for the variables.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skn</tt></a> (output)</dt>
<dd>Status keys for the conic constraints.</dd>
<dt><tt class="tt">xc</tt> (output)</dt>
<dd>Primal constraint solution.</dd>
<dt><tt class="tt">xx</tt> (output)</dt>
<dd>Primal variable solution (<span class="math"><span class="mi">x</span></span>).</dd>
<dt><tt class="tt">y</tt> (output)</dt>
<dd>Vector of dual variables corresponding to the constraints.</dd>
<dt><tt class="tt">slc</tt> (output)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (<span class="math"><img src="math/math936.png" alt="[[MathCmd 936]]"/></span>).</dd>
<dt><tt class="tt">suc</tt> (output)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (<span class="math"><img src="math/math937.png" alt="[[MathCmd 937]]"/></span>).</dd>
<dt><tt class="tt">slx</tt> (output)</dt>
<dd>Dual variables corresponding to the lower bounds on the variables (<span class="math"><img src="math/math938.png" alt="[[MathCmd 938]]"/></span>).</dd>
<dt><tt class="tt">sux</tt> (output)</dt>
<dd>Dual variables corresponding to the upper bounds on the variables (appears as <span class="math"><img src="math/math939.png" alt="[[MathCmd 939]]"/></span>).</dd>
<dt><tt class="tt">snx</tt> (output)</dt>
<dd>Dual variables corresponding to the conic constraints on the variables (<span class="math"><img src="math/math940.png" alt="[[MathCmd 940]]"/></span>).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the complete solution.</p>

<p>Consider the case of linear programming. The primal problem is given by </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math941.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x+c^{f} &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x & \leq{} & u^{x}.\end{array}\end{math}"/></td>
<td>(15.4.10)</td></tr>
</tbody>
</table>

<p> and the corresponding dual problem is </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math280.png" alt="\begin{math}\nonumber{}\begin{array}{lccl}\nonumber{}\mbox{maximize} & (l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c} &  & \\\nonumber{} & +(l^{x})^{T}s_{l}^{x}-(u^{x})^{T}s_{u}^{x}+c^{f} &  & \\\nonumber{}\mbox{subject to} & A^{T}y+s_{l}^{x}-s_{u}^{x} & = & c,\\\nonumber{} & -y+s_{l}^{c}-s_{u}^{c} & = & 0,\\\nonumber{} & s_{l}^{c},s_{u}^{c},s_{l}^{x},s_{u}^{x}\geq{}0. &  &\end{array}\end{math}"/></td>
<td>(15.4.11)</td></tr>
</tbody>
</table>

<p> In this case the mapping between variables and arguments to the function is as follows: </p>

<dl class="description">
<dt></dt>
<dd>
<p><tt class="tt">xx</tt>: Corresponds to variable <span class="math"><span class="mi">x</span></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">y</tt>: Corresponds to variable <span class="math"><span class="mi">y</span></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">slc</tt>: Corresponds to variable <span class="math"><img src="math/math936.png" alt="[[MathCmd 936]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">suc</tt>: Corresponds to variable <span class="math"><img src="math/math937.png" alt="[[MathCmd 937]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">slx</tt>: Corresponds to variable <span class="math"><img src="math/math938.png" alt="[[MathCmd 938]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">sux</tt>: Corresponds to variable <span class="math"><img src="math/math939.png" alt="[[MathCmd 939]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><tt class="tt">xc</tt>: Corresponds to <span class="math"><span class="mi">A</span><span class="mi">x</span></span>. </p>
</dd>
</dl>

<p> The meaning of the values returned by this function depend on the <em>solution status</em> returned in the argument <tt class="tt">solsta</tt>. The most important possible values of <tt class="tt">solsta</tt> are: </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*optimal"><tt class="tt">MSK_SOL_STA_OPTIMAL</tt></a> An optimal solution satisfying the optimality criteria for continuous problems is returned. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*integer-optimal"><tt class="tt">MSK_SOL_STA_INTEGER_OPTIMAL</tt></a> An optimal solution satisfying the optimality criteria for integer problems is returned. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*prim-feas"><tt class="tt">MSK_SOL_STA_PRIM_FEAS</tt></a> A solution satisfying the feasibility criteria. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*prim-infeas-cer"><tt class="tt">MSK_SOL_STA_PRIM_INFEAS_CER</tt></a> A primal certificate of infeasibility is returned. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*dual-infeas-cer"><tt class="tt">MSK_SOL_STA_DUAL_INFEAS_CER</tt></a> A dual certificate of infeasibility is returned. </p>
</dd>
</dl>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">MSK_getsolutioni</tt></a></dt>
<dd>
<p> Obtains the solution for a single constraint or variable.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutionslice"><tt class="tt">MSK_getsolutionslice</tt></a></dt>
<dd>
<p> Obtains a slice of the solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getsolutioni</tt></span>

<p> <a name="func*mosek*task*getsolutioni">&#09;</a><a name="common-func*mosek*task*getsolutioni"></a> <a name="idx-126173128">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getsolutioni (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt i,
    MSKsoltypee whichsol,
    MSKstakeye * sk,
    MSKrealt * x,
    MSKrealt * sl,
    MSKrealt * su,
    MSKrealt * sn);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a> the solution information for a constraint is retrieved. Otherwise for a variable.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">sk</tt></a> (output)</dt>
<dd>Status key of the constraint of variable.</dd>
<dt><tt class="tt">x</tt> (output)</dt>
<dd>Solution value of the primal variable.</dd>
<dt><tt class="tt">sl</tt> (output)</dt>
<dd>Solution value of the dual variable associated with the lower bound.</dd>
<dt><tt class="tt">su</tt> (output)</dt>
<dd>Solution value of the dual variable associated with the upper bound.</dd>
<dt><tt class="tt">sn</tt> (output)</dt>
<dd>Solution value of the dual variable associated with the cone constraint.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the primal and dual solution information for a single constraint or variable.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">MSK_getsolution</tt></a></dt>
<dd>
<p> Obtains the complete solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutionslice"><tt class="tt">MSK_getsolutionslice</tt></a></dt>
<dd>
<p> Obtains a slice of the solution.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getsolutionincallback</tt></span>

<p> <a name="func*mosek*task*getsolutionincallback">&#09;</a><a name="common-func*mosek*task*getsolutionincallback"></a> <a name="idx-126204600">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getsolutionincallback (
    MSKtask_t task,
    MSKcallbackcodee where,
    MSKsoltypee whichsol,
    MSKprostae * prosta,
    MSKsolstae * solsta,
    MSKstakeye * skc,
    MSKstakeye * skx,
    MSKstakeye * skn,
    MSKrealt * xc,
    MSKrealt * xx,
    MSKrealt * y,
    MSKrealt * slc,
    MSKrealt * suc,
    MSKrealt * slx,
    MSKrealt * sux,
    MSKrealt * snx);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*callbackcode"><tt class="tt">where</tt></a> (input)</dt>
<dd>The call-back-key from the current call-back</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skc</tt></a> (output)</dt>
<dd>Status keys for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skx</tt></a> (output)</dt>
<dd>Status keys for the variables.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skn</tt></a> (output)</dt>
<dd>Status keys for the conic constraints.</dd>
<dt><tt class="tt">xc</tt> (output)</dt>
<dd>Primal constraint solution.</dd>
<dt><tt class="tt">xx</tt> (output)</dt>
<dd>Primal variable solution (<span class="math"><span class="mi">x</span></span>).</dd>
<dt><tt class="tt">y</tt> (output)</dt>
<dd>Vector of dual variables corresponding to the constraints.</dd>
<dt><tt class="tt">slc</tt> (output)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (<span class="math"><img src="math/math936.png" alt="[[MathCmd 936]]"/></span>).</dd>
<dt><tt class="tt">suc</tt> (output)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (<span class="math"><img src="math/math937.png" alt="[[MathCmd 937]]"/></span>).</dd>
<dt><tt class="tt">slx</tt> (output)</dt>
<dd>Dual variables corresponding to the lower bounds on the variables (<span class="math"><img src="math/math938.png" alt="[[MathCmd 938]]"/></span>).</dd>
<dt><tt class="tt">sux</tt> (output)</dt>
<dd>Dual variables corresponding to the upper bounds on the variables (appears as <span class="math"><img src="math/math939.png" alt="[[MathCmd 939]]"/></span>).</dd>
<dt><tt class="tt">snx</tt> (output)</dt>
<dd>Dual variables corresponding to the conic constraints on the variables (<span class="math"><img src="math/math940.png" alt="[[MathCmd 940]]"/></span>).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the whole or a part of the solution from within a progress call-back. This function must only be called from a progress call-back function.</p>

<p>This is an experimental feature. Please contact MOSEK support before using this function.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getsolutioninf</tt></span>

<p> <a name="func*mosek*task*getsolutioninf">&#09;</a><a name="common-func*mosek*task*getsolutioninf"></a> <a name="idx-127685480">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getsolutioninf (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKprostae * prosta,
    MSKsolstae * solsta,
    MSKrealt * primalobj,
    MSKrealt * maxpbi,
    MSKrealt * maxpcni,
    MSKrealt * maxpeqi,
    MSKrealt * maxinti,
    MSKrealt * dualobj,
    MSKrealt * maxdbi,
    MSKrealt * maxdcni,
    MSKrealt * maxdeqi);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
<dt><tt class="tt">primalobj</tt> (output)</dt>
<dd>
<p>Value of the primal objective. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math952.png" alt="\begin{math}\nonumber{}c^{T}x+c^{f}\end{math}"/></td>
<td>(15.4.12)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxpbi</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in primal bounds on variables. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math953.png" alt="\begin{math}\nonumber{}\max \left\lbrace{}0,\max _{{i\in{}{1,\ldots ,n-1}}}(x_{i}-u^{x}_{i}),\max _{{i\in{}{1,\ldots ,n-1}}}(l^{x}_{i}-x_{i}),\max _{{i\in{}{1,\ldots ,n-1}}}(x^{c}_{i}-u^{c}_{i}),\max _{{i\in{}{1,\ldots ,n-1}}}(l^{c}_{i}-x^{c}_{i})\right\rbrace{}\end{math}"/></td>
<td>(15.4.13)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxpcni</tt> (output)</dt>
<dd>Maximum infeasibility in the primal conic constraints.</dd>
<dt><tt class="tt">maxpeqi</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in primal equality constraints. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math954.png" alt="\begin{math}\nonumber{}\left\|Ax-x^{c}\right\|_{\infty }\end{math}"/></td>
<td>(15.4.14)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxinti</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in integer constraints. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math955.png" alt="\begin{math}\nonumber{}\max _{{i\in{}\lbrace{}0,\ldots ,n-1\rbrace{}}}(\min (x_{i}-\lfloor x_{i}\rfloor ,\lceil x_{i}\rceil -x_{i})).\end{math}"/></td>
<td>(15.4.15)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">dualobj</tt> (output)</dt>
<dd>
<p>Value of the dual objective. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math956.png" alt="\begin{math}\nonumber{}(l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c}+c^{f}\end{math}"/></td>
<td>(15.4.16)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxdbi</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in bounds on dual variables. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math957.png" alt="\begin{math}\nonumber{}\max \lbrace{}0,\max _{{i\in{}\lbrace{}0,\ldots ,n-1\rbrace{}}}-(s_{l}^{x})_{i},\max _{{i\in{}\lbrace{}0,\ldots ,n-1\rbrace{}}}-(s_{u}^{x})_{i},\max _{{i\in{}\lbrace{}0,\ldots ,m-1\rbrace{}}}-(s_{l}^{c})_{i},\max _{{i\in{}\lbrace{}0,\ldots ,m-1\rbrace{}}}-(s_{u}^{c})_{i}\rbrace{}\end{math}"/></td>
<td>(15.4.17)</td></tr>
</tbody>
</table>
</dd>
<dt><tt class="tt">maxdcni</tt> (output)</dt>
<dd>Maximum infeasibility in the dual conic constraints.</dd>
<dt><tt class="tt">maxdeqi</tt> (output)</dt>
<dd>
<p>Maximum infeasibility in the dual equality constraints. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math958.png" alt="\begin{math}\nonumber{}\max \left\lbrace{}\left\|A^{T}y+s_{l}^{x}-s_{u}^{x}-c\right\|_{\infty },\left\|-y+s_{l}^{c}-s_{u}^{c}\right\|_{\infty }\right\rbrace{}\end{math}"/></td>
<td>(15.4.18)</td></tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains information about the quality of a solution. Part of the following documentation is restricted to the linear case, it should be clear how to extend to other problem classes.</p>

<p>When optimizing MOSEK solves a reformulated problem with only equality constraints. </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math959.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x+c^{f} &  & \\\nonumber{}\mbox{subject to} &  &  & Ax-x^{c} & = & 0\\\nonumber{} & l^{x} & \leq{} & x & \leq{} & u^{x},\\\nonumber{} & l^{c} & \leq{} & x^{c} & \leq{} & u^{c}.\end{array}\end{math}"/></td>
<td><a name="ais-ch-apiex-basissolve-eq-primal">&#09;</a>(15.4.19)</td></tr>
</tbody>
</table>

<p>  where  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math244.png" alt="\begin{displaymath}\nonumber{}x^{c}\in{}\mathbb{R}^{{m}}\mbox{ and }x\in{}\mathbb{R}^{n}.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> and the corresponding dual problem is </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math961.png" alt="\begin{math}\nonumber{}\begin{array}{lccl}\nonumber{}\mbox{maximize} & (l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c}+c^{f} &  & \\\nonumber{} & +(l^{x})^{T}s_{l}^{x}-(u^{x})^{T}s_{u}^{x}+c^{f} &  & \\\nonumber{}\mbox{subject to} & A^{T}y+s_{l}^{x}-s_{u}^{x} & = & c,\\\nonumber{} & -y+s_{l}^{c}-s_{u}^{c} & = & 0,\\\nonumber{} & s_{l}^{c},s_{u}^{c},s_{l}^{x},s_{u}^{x}\geq{}0. &  &\end{array}\end{math}"/></td>
<td>(15.4.20)</td></tr>
</tbody>
</table>

<p>  The values returned by this function refers to these problems.</p>

<p>Please note that this function computes the objective value and other values every time it is called. Hence, for efficiency reasons this function should not be used too frequently.</p>

<p>If only the problem status or the solution status is required then use <a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">MSK_getsolutionstatus</tt></a> instead.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getpeqi"><tt class="tt">MSK_getpeqi</tt></a></dt>
<dd>
<p> Obtains the primal equation infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdeqi"><tt class="tt">MSK_getdeqi</tt></a></dt>
<dd>
<p> Optains the dual equation infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getpbi"><tt class="tt">MSK_getpbi</tt></a></dt>
<dd>
<p> Obtains the primal bound infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdbi"><tt class="tt">MSK_getdbi</tt></a></dt>
<dd>
<p> Obtains the dual bound infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getdcni"><tt class="tt">MSK_getdcni</tt></a></dt>
<dd>
<p> Obtains the dual cone infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getpcni"><tt class="tt">MSK_getpcni</tt></a></dt>
<dd>
<p> Obtains the primal cone infeasibility.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*analyzesolution"><tt class="tt">MSK_analyzesolution</tt></a></dt>
<dd>
<p> Print information related to the quality of the solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">MSK_getsolutionstatus</tt></a></dt>
<dd>
<p> Obtains information about the problem and solution statuses.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getsolutionslice</tt></span>

<p> <a name="func*mosek*task*getsolutionslice">&#09;</a><a name="common-func*mosek*task*getsolutionslice"></a> <a name="idx-127762512">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getsolutionslice (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKsoliteme solitem,
    MSKidxt first,
    MSKidxt last,
    MSKrealt * values);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*solitem"><tt class="tt">solitem</tt></a> (input)</dt>
<dd>Which part of the solution is required.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first value in the slice.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Value of the last index+1 in the slice, e.g. if <span class="math"><img src="math/math962.png" alt="[[MathCmd 962]]"/></span> is required <tt class="tt">last</tt> should be <span class="math"><span class="mn">10</span></span>.</dd>
<dt><tt class="tt">values</tt> (output)</dt>
<dd>The values in the required sequence are stored sequentially in <tt class="tt">values</tt> starting at <tt class="tt">values[0]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains a slice of the solution.</p>

<p>Consider the case of linear programming. The primal problem is given by </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math941.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x+c^{f} &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x & \leq{} & u^{x}.\end{array}\end{math}"/></td>
<td>(15.4.21)</td></tr>
</tbody>
</table>

<p> and the corresponding dual problem is </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math280.png" alt="\begin{math}\nonumber{}\begin{array}{lccl}\nonumber{}\mbox{maximize} & (l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c} &  & \\\nonumber{} & +(l^{x})^{T}s_{l}^{x}-(u^{x})^{T}s_{u}^{x}+c^{f} &  & \\\nonumber{}\mbox{subject to} & A^{T}y+s_{l}^{x}-s_{u}^{x} & = & c,\\\nonumber{} & -y+s_{l}^{c}-s_{u}^{c} & = & 0,\\\nonumber{} & s_{l}^{c},s_{u}^{c},s_{l}^{x},s_{u}^{x}\geq{}0. &  &\end{array}\end{math}"/></td>
<td>(15.4.22)</td></tr>
</tbody>
</table>

<p> The <tt class="tt">solitem</tt> argument determines which part of the solution is returned: </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*xx"><tt class="tt">MSK_SOL_ITEM_XX</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><span class="mi">x</span></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*y"><tt class="tt">MSK_SOL_ITEM_Y</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><span class="mi">y</span></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*slc"><tt class="tt">MSK_SOL_ITEM_SLC</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><img src="math/math936.png" alt="[[MathCmd 936]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*suc"><tt class="tt">MSK_SOL_ITEM_SUC</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><img src="math/math937.png" alt="[[MathCmd 937]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*slx"><tt class="tt">MSK_SOL_ITEM_SLX</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><img src="math/math938.png" alt="[[MathCmd 938]]"/></span>. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solitem*sux"><tt class="tt">MSK_SOL_ITEM_SUX</tt></a>: The variable <tt class="tt">values</tt> return <span class="math"><img src="math/math939.png" alt="[[MathCmd 939]]"/></span>. </p>
</dd>
</dl>

<p> A conic optimization problem has the same primal variables as in the linear case. Recall that the dual of a conic optimization problem is given by: </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math332.png" alt="\begin{math}\nonumber{}\begin{array}{lccccc}\nonumber{}\mbox{maximize} & (l^{c})^{T}s_{l}^{c}-(u^{c})^{T}s_{u}^{c} &  & \\\nonumber{} & +(l^{x})^{T}s_{l}^{x}-(u^{x})^{T}s_{u}^{x}+c^{f} &  & \\\nonumber{}\mbox{subject to} & A^{T}y+s_{l}^{x}-s_{u}^{x}+s_{n}^{x} & = & c,\\\nonumber{} & -y+s_{l}^{c}-s_{u}^{c} & = & 0,\\\nonumber{} & s_{l}^{c},s_{u}^{c},s_{l}^{x},s_{u}^{x} & \geq{} & 0,\\\nonumber{} & s_{n}^{x}\in{}\mathcal{C}^{*} &  &\end{array}\end{math}"/></td>
<td>(15.4.23)</td></tr>
</tbody>
</table>

<p> This introduces one additional dual variable <span class="math"><img src="math/math940.png" alt="[[MathCmd 940]]"/></span>. This variable can be acceded by selecting <tt class="tt">solitem</tt> as <a href="node020.html#common-const*mosek*solitem*snx"><tt class="tt">MSK_SOL_ITEM_SNX</tt></a>.</p>

<p>The meaning of the values returned by this function also depends on the <em>solution status</em> which can be obtained with <a href="node017.html#common-func*mosek*task*getsolutionstatus"><tt class="tt">MSK_getsolutionstatus</tt></a>. Depending on the solution status <tt class="tt">value</tt> will be: </p>

<dl class="description">
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*optimal"><tt class="tt">MSK_SOL_STA_OPTIMAL</tt></a> A part of the optimal solution satisfying the optimality criteria for continuous problems. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*integer-optimal"><tt class="tt">MSK_SOL_STA_INTEGER_OPTIMAL</tt></a> A part of the optimal solution satisfying the optimality criteria for integer problems. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*prim-feas"><tt class="tt">MSK_SOL_STA_PRIM_FEAS</tt></a> A part of the solution satisfying the feasibility criteria. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*prim-infeas-cer"><tt class="tt">MSK_SOL_STA_PRIM_INFEAS_CER</tt></a> A part of the primal certificate of infeasibility. </p>
</dd>
<dt></dt>
<dd>
<p><a href="node020.html#common-const*mosek*solsta*dual-infeas-cer"><tt class="tt">MSK_SOL_STA_DUAL_INFEAS_CER</tt></a> A part of the dual certificate of infeasibility. </p>
</dd>
</dl>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">MSK_getsolution</tt></a></dt>
<dd>
<p> Obtains the complete solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">MSK_getsolutioni</tt></a></dt>
<dd>
<p> Obtains the solution for a single constraint or variable.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getsolutionstatus</tt></span>

<p> <a name="func*mosek*task*getsolutionstatus">&#09;</a><a name="common-func*mosek*task*getsolutionstatus"></a> <a name="idx-127856720">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getsolutionstatus (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKprostae * prosta,
    MSKsolstae * solsta);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains information about the problem and solution statuses.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getsolutionstatuskeyslice</tt></span>

<p> <a name="func*mosek*task*getsolutionstatuskeyslice">&#09;</a><a name="common-func*mosek*task*getsolutionstatuskeyslice"></a> <a name="idx-127872752">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getsolutionstatuskeyslice (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKsoltypee whichsol,
    MSKidxt first,
    MSKidxt last,
    MSKstakeye * sk);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>Index of the first value in the slice.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Value of the last index+1 in the slice, e.g. if <span class="math"><img src="math/math962.png" alt="[[MathCmd 962]]"/></span> is required <tt class="tt">last</tt> should be <span class="math"><span class="mn">10</span></span>.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">sk</tt></a> (output)</dt>
<dd>The status keys in the required sequence are stored sequentially in <tt class="tt">sk</tt> starting at <tt class="tt">sk[0]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a slice of the solution status keys.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">MSK_getsolution</tt></a></dt>
<dd>
<p> Obtains the complete solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">MSK_getsolutioni</tt></a></dt>
<dd>
<p> Obtains the solution for a single constraint or variable.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getstrparam</tt></span>

<p> <a name="func*mosek*task*getstrparam">&#09;</a><a name="common-func*mosek*task*getstrparam"></a> <a name="idx-127837104">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getstrparam (
    MSKtask_t task,
    MSKsparame param,
    MSKCONST size_t maxlen,
    size_t * len,
    char * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node018.html#common-constclass*mosek*sparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Length of the <tt class="tt">parvalue</tt> buffer.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>The length of the parameter value.</dd>
<dt><tt class="tt">parvalue</tt> (output)</dt>
<dd>If this is not NULL, the parameter value is stored here.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of a string parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getstrparam64</tt></span>

<p> <a name="func*mosek*task*getstrparam64">&#09;</a><a name="common-func*mosek*task*getstrparam64"></a> <a name="idx-129333656">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getstrparam64 (
    MSKtask_t task,
    MSKsparame param,
    MSKint64t maxlen,
    MSKint64t * len,
    char * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node018.html#common-constclass*mosek*sparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Length of the <tt class="tt">parvalue</tt> buffer.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>The length of the parameter value.</dd>
<dt><tt class="tt">parvalue</tt> (output)</dt>
<dd>If this is not NULL, the parameter value is stored here.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of a string parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getstrparamal</tt></span>

<p> <a name="func*mosek*task*getstrparamal">&#09;</a><a name="common-func*mosek*task*getstrparamal"></a> <a name="idx-129357080">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getstrparamal (
    MSKtask_t task,
    MSKsparame param,
    MSKCONST size_t numaddchr,
    MSKstring_t * value);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node018.html#common-constclass*mosek*sparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">numaddchr</tt> (input)</dt>
<dd>Number of additional characters that is made room for in <tt class="tt">value[0]</tt>.</dd>
<dt><tt class="tt">value</tt> (input/output)</dt>
<dd>Is the value corresponding to string parameter <tt class="tt">param</tt>. <tt class="tt">value[0]</tt> is char buffer allocated MOSEK and it must be freed by <a href="node017.html#common-func*mosek*task*freetask"><tt class="tt">MSK_freetask</tt></a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the value of a string parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getsymbcon</tt></span>

<p> <a name="func*mosek*task*getsymbcon">&#09;</a><a name="common-func*mosek*task*getsymbcon"></a> <a name="idx-129374616">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getsymbcon (
    MSKtask_t task,
    MSKidxt i,
    MSKCONST size_t maxlen,
    char * name,
    MSKintt * value);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>The length of the buffer pointed to by the <tt class="tt">value</tt> argument.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Name of the <span class="math"><span class="mi">i</span></span>th symbolic constant.</dd>
<dt><tt class="tt">value</tt> (output)</dt>
<dd>The corresponding value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name and corresponding value for the <span class="math"><span class="mi">i</span></span>th symbolic constant.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_gettaskname</tt></span>

<p> <a name="func*mosek*task*gettaskname">&#09;</a><a name="common-func*mosek*task*gettaskname"></a> <a name="idx-129361752">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_gettaskname (
    MSKtask_t task,
    MSKCONST size_t maxlen,
    size_t * len,
    char * taskname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Length of the <tt class="tt">taskname</tt> array.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the task name.</dd>
<dt><tt class="tt">taskname</tt> (output)</dt>
<dd>Is assigned the task name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name assigned to the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_gettaskname64</tt></span>

<p> <a name="func*mosek*task*gettaskname64">&#09;</a><a name="common-func*mosek*task*gettaskname64"></a> <a name="idx-129406160">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_gettaskname64 (
    MSKtask_t task,
    MSKint64t maxlen,
    MSKint64t * len,
    char * taskname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>Length of the <tt class="tt">taskname</tt> array.</dd>
<dt><tt class="tt">len</tt> (output)</dt>
<dd>Is assigned the length of the task name.</dd>
<dt><tt class="tt">taskname</tt> (output)</dt>
<dd>Is assigned the task name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the name assigned to the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getvarbranchdir</tt></span>

<p> <a name="func*mosek*task*getvarbranchdir">&#09;</a><a name="common-func*mosek*task*getvarbranchdir"></a> <a name="idx-129414712">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getvarbranchdir (
    MSKtask_t task,
    MSKidxt j,
    MSKbranchdire * direction);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*branchdir"><tt class="tt">direction</tt></a> (output)</dt>
<dd>The branching direction assigned to variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the branching direction for a given variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getvarbranchorder</tt></span>

<p> <a name="func*mosek*task*getvarbranchorder">&#09;</a><a name="common-func*mosek*task*getvarbranchorder"></a> <a name="idx-129421392">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getvarbranchorder (
    MSKtask_t task,
    MSKidxt j,
    MSKintt * priority,
    MSKbranchdire * direction);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><tt class="tt">priority</tt> (output)</dt>
<dd>The branching priority assigned to variable <span class="math"><span class="mi">j</span></span>.</dd>
<dt><a href="node020.html#common-constclass*mosek*branchdir"><tt class="tt">direction</tt></a> (output)</dt>
<dd>The preferred branching direction for the j'th variable.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the branching priority and direction for a given variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getvarbranchpri</tt></span>

<p> <a name="func*mosek*task*getvarbranchpri">&#09;</a><a name="common-func*mosek*task*getvarbranchpri"></a> <a name="idx-129448200">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getvarbranchpri (
    MSKtask_t task,
    MSKidxt j,
    MSKintt * priority);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><tt class="tt">priority</tt> (output)</dt>
<dd>The branching priority assigned to variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the branching priority for a given variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getvarname</tt></span>

<p> <a name="func*mosek*task*getvarname">&#09;</a><a name="common-func*mosek*task*getvarname"></a> <a name="idx-129441872">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getvarname (
    MSKtask_t task,
    MSKidxt i,
    MSKCONST size_t maxlen,
    char * name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>The length of the buffer pointed to by the <tt class="tt">name</tt> argument.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a variable.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getmaxnamelen"><tt class="tt">MSK_getmaxnamelen</tt></a></dt>
<dd>
<p> Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getvarname64</tt></span>

<p> <a name="func*mosek*task*getvarname64">&#09;</a><a name="common-func*mosek*task*getvarname64"></a> <a name="idx-129478168">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getvarname64 (
    MSKtask_t task,
    MSKidxt i,
    MSKint64t maxlen,
    char * name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">maxlen</tt> (input)</dt>
<dd>The length of the buffer pointed to by the <tt class="tt">name</tt> argument.</dd>
<dt><tt class="tt">name</tt> (output)</dt>
<dd>Is assigned the required name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a name of a variable.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getmaxnamelen"><tt class="tt">MSK_getmaxnamelen</tt></a></dt>
<dd>
<p> Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable or cone name.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getvartype</tt></span>

<p> <a name="func*mosek*task*getvartype">&#09;</a><a name="common-func*mosek*task*getvartype"></a> <a name="idx-129493400">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getvartype (
    MSKtask_t task,
    MSKidxt j,
    MSKvariabletypee * vartype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*variabletype"><tt class="tt">vartype</tt></a> (output)</dt>
<dd>Variable type of variable <tt class="tt">j</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Gets the variable type of one variable.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_getvartypelist</tt></span>

<p> <a name="func*mosek*task*getvartypelist">&#09;</a><a name="common-func*mosek*task*getvartypelist"></a> <a name="idx-129466240">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_getvartypelist (
    MSKtask_t task,
    MSKintt num,
    MSKCONST MSKidxt * subj,
    MSKvariabletypee * vartype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of variables for which the variable type should be obtained.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>A list of variable indexes.</dd>
<dt><a href="node020.html#common-constclass*mosek*variabletype"><tt class="tt">vartype</tt></a> (output)</dt>
<dd>The variables types corresponding to the variables specified by <tt class="tt">subj</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Obtains the variable type of one or more variables.</p>

<p>Upon return <tt class="tt">vartype[k]</tt> is the variable type of variable <tt class="tt">subj[k]</tt>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_initbasissolve</tt></span>

<p> <a name="func*mosek*task*initbasissolve">&#09;</a><a name="common-func*mosek*task*initbasissolve"></a> <a name="idx-129526168">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_initbasissolve (
    MSKtask_t task,
    MSKidxt * basis);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">basis</tt> (output)</dt>
<dd>
<p>The array of basis indexes to use.</p>

<p>The array is interpreted as follows: If <span class="math"><img src="math/math972.png" alt="[[MathCmd 972]]"/></span>, then <span class="math"><img src="math/math973.png" alt="[[MathCmd 973]]"/></span> is in the basis at position <span class="math"><span class="mi">i</span></span>, otherwise <span class="math"><img src="math/math974.png" alt="[[MathCmd 974]]"/></span> is in the basis at position <span class="math"><span class="mi">i</span></span>.</p>
</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Prepare a task for use with the <a href="node017.html#common-func*mosek*task*solvewithbasis"><tt class="tt">MSK_solvewithbasis</tt></a> function.</p>

<p>This function should be called </p>

<ul class="itemize">
<li>immediately before the first call to <a href="node017.html#common-func*mosek*task*solvewithbasis"><tt class="tt">MSK_solvewithbasis</tt></a>, and </li>
<li>immediately before any subsequent call to <a href="node017.html#common-func*mosek*task*solvewithbasis"><tt class="tt">MSK_solvewithbasis</tt></a> if the task has been modified. </li>
</ul>

<p> If the basis is singular i.e. not invertible, then  the response code <a href="#common-const*mosek*rescode*err-basis-singular"><tt class="tt">MSK_RES_ERR_BASIS_SINGULAR</tt></a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_inputdata</tt></span>

<p> <a name="func*mosek*task*inputdata">&#09;</a><a name="common-func*mosek*task*inputdata"></a> <a name="idx-129536152">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_inputdata (
    MSKtask_t task,
    MSKintt maxnumcon,
    MSKintt maxnumvar,
    MSKintt numcon,
    MSKintt numvar,
    MSKCONST MSKrealt * c,
    MSKrealt cfix,
    MSKCONST MSKintt * aptrb,
    MSKCONST MSKintt * aptre,
    MSKCONST MSKidxt * asub,
    MSKCONST MSKrealt * aval,
    MSKCONST MSKboundkeye * bkc,
    MSKCONST MSKrealt * blc,
    MSKCONST MSKrealt * buc,
    MSKCONST MSKboundkeye * bkx,
    MSKCONST MSKrealt * blx,
    MSKCONST MSKrealt * bux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>Number of preallocated constraints in the optimization task.</dd>
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>Number of preallocated variables in the optimization task.</dd>
<dt><tt class="tt">numcon</tt> (input)</dt>
<dd>Number of constraints.</dd>
<dt><tt class="tt">numvar</tt> (input)</dt>
<dd>Number of variables.</dd>
<dt><tt class="tt">c</tt> (input)</dt>
<dd>Linear terms of the objective as a dense vector. The lengths is the number of variables.</dd>
<dt><tt class="tt">cfix</tt> (input)</dt>
<dd>Fixed term in the objective.</dd>
<dt><tt class="tt">aptrb</tt> (input)</dt>
<dd>Pointer to the first element in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aptre</tt> (input)</dt>
<dd>Pointers to the last element + 1 in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a></dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>Coefficient subscripts. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (input)</dt>
<dd>Bound keys for the constraints.</dd>
<dt><tt class="tt">blc</tt> (input)</dt>
<dd>Lower bounds for the constraints.</dd>
<dt><tt class="tt">buc</tt> (input)</dt>
<dd>Upper bounds for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (input)</dt>
<dd>Bound keys for the variables.</dd>
<dt><tt class="tt">blx</tt> (input)</dt>
<dd>Lower bounds for the variables.</dd>
<dt><tt class="tt">bux</tt> (input)</dt>
<dd>Upper bounds for the variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Input the linear part of an optimization problem.</p>

<p>The non-zeros of <span class="math"><span class="mi">A</span></span> are inputted column-wise in the format described in Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</p>

<p>For an explained code example see Section <a title="5.2. Linear optimization" href="node007.html#chap-apiintro-sec-linear-optimization">5.2</a> and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_inputdata64</tt></span>

<p> <a name="func*mosek*task*inputdata64">&#09;</a><a name="common-func*mosek*task*inputdata64"></a> <a name="idx-130955240">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_inputdata64 (
    MSKtask_t task,
    MSKintt maxnumcon,
    MSKintt maxnumvar,
    MSKintt numcon,
    MSKintt numvar,
    MSKCONST MSKrealt * c,
    MSKrealt cfix,
    MSKCONST MSKint64t * aptrb,
    MSKCONST MSKint64t * aptre,
    MSKCONST MSKidxt * asub,
    MSKCONST MSKrealt * aval,
    MSKCONST MSKboundkeye * bkc,
    MSKCONST MSKrealt * blc,
    MSKCONST MSKrealt * buc,
    MSKCONST MSKboundkeye * bkx,
    MSKCONST MSKrealt * blx,
    MSKCONST MSKrealt * bux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>Number of preallocated constraints in the optimization task.</dd>
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>Number of preallocated variables in the optimization task.</dd>
<dt><tt class="tt">numcon</tt> (input)</dt>
<dd>Number of constraints.</dd>
<dt><tt class="tt">numvar</tt> (input)</dt>
<dd>Number of variables.</dd>
<dt><tt class="tt">c</tt> (input)</dt>
<dd>Linear terms of the objective as a dense vector. The lengths is the number of variables.</dd>
<dt><tt class="tt">cfix</tt> (input)</dt>
<dd>Fixed term in the objective.</dd>
<dt><tt class="tt">aptrb</tt> (input)</dt>
<dd>Pointer to the first element in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aptre</tt> (input)</dt>
<dd>Pointers to the last element + 1 in the rows or the columns of <span class="math"><span class="mi">A</span></span>. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a></dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>Coefficient subscripts. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (input)</dt>
<dd>Bound keys for the constraints.</dd>
<dt><tt class="tt">blc</tt> (input)</dt>
<dd>Lower bounds for the constraints.</dd>
<dt><tt class="tt">buc</tt> (input)</dt>
<dd>Upper bounds for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (input)</dt>
<dd>Bound keys for the variables.</dd>
<dt><tt class="tt">blx</tt> (input)</dt>
<dd>Lower bounds for the variables.</dd>
<dt><tt class="tt">bux</tt> (input)</dt>
<dd>Upper bounds for the variables.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Input the linear part of an optimization problem.</p>

<p>The non-zeros of <span class="math"><span class="mi">A</span></span> are inputted column-wise in the format described in Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</p>

<p>For an explained code example see Section <a title="5.2. Linear optimization" href="node007.html#chap-apiintro-sec-linear-optimization">5.2</a> and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_isdouparname</tt></span>

<p> <a name="func*mosek*task*isdouparname">&#09;</a><a name="common-func*mosek*task*isdouparname"></a> <a name="idx-131009784">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_isdouparname (
    MSKtask_t task,
    MSKCONST char * parname,
    MSKdparame * param);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">parname</tt> (input)</dt>
<dd>Parameter name.</dd>
<dt><a href="node018.html#common-constclass*mosek*dparam"><tt class="tt">param</tt></a> (output)</dt>
<dd>Which parameter.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks whether <tt class="tt">parname</tt> is a valid double parameter name.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_isintparname</tt></span>

<p> <a name="func*mosek*task*isintparname">&#09;</a><a name="common-func*mosek*task*isintparname"></a> <a name="idx-131017904">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_isintparname (
    MSKtask_t task,
    MSKCONST char * parname,
    MSKiparame * param);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">parname</tt> (input)</dt>
<dd>Parameter name.</dd>
<dt><a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">param</tt></a> (output)</dt>
<dd>Which parameter.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks whether <tt class="tt">parname</tt> is a valid integer parameter name.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_isstrparname</tt></span>

<p> <a name="func*mosek*task*isstrparname">&#09;</a><a name="common-func*mosek*task*isstrparname"></a> <a name="idx-131020200">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_isstrparname (
    MSKtask_t task,
    MSKCONST char * parname,
    MSKsparame * param);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">parname</tt> (input)</dt>
<dd>Parameter name.</dd>
<dt><a href="node018.html#common-constclass*mosek*sparam"><tt class="tt">param</tt></a> (output)</dt>
<dd>Which parameter.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks whether <tt class="tt">parname</tt> is a valid string parameter name.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_linkfiletotaskstream</tt></span>

<p> <a name="func*mosek*task*linkfiletotaskstream">&#09;</a><a name="common-func*mosek*task*linkfiletotaskstream"></a> <a name="idx-131048368">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_linkfiletotaskstream (
    MSKtask_t task,
    MSKstreamtypee whichstream,
    MSKCONST char * filename,
    MSKintt append);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>The name of the file where text from the stream defined by <tt class="tt">whichstream</tt> is written.</dd>
<dt><tt class="tt">append</tt> (input)</dt>
<dd>If this argument is 0 the output file will be overwritten, otherwise text is append to the output file.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Directs all output from a task stream to a file.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_linkfunctotaskstream</tt></span>

<p> <a name="func*mosek*task*linkfunctotaskstream">&#09;</a><a name="common-func*mosek*task*linkfunctotaskstream"></a> <a name="idx-131028176">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_linkfunctotaskstream (
    MSKtask_t task,
    MSKstreamtypee whichstream,
    MSKuserhandle_t handle,
    MSKstreamfunc func);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">handle</tt> (input)</dt>
<dd>A user-defined handle which is passed to the user-defined function <tt class="tt">func</tt>.</dd>
<dt><tt class="tt">func</tt> (input)</dt>
<dd>All output to the stream <tt class="tt">whichstream</tt> is passed to <tt class="tt">func</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Connects a user-defined function to a task stream.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_makesolutionstatusunknown</tt></span>

<p> <a name="func*mosek*task*makesolutionstatusunknown">&#09;</a><a name="common-func*mosek*task*makesolutionstatusunknown"></a> <a name="idx-131082648">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_makesolutionstatusunknown (
    MSKtask_t task,
    MSKsoltypee whichsol);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the solution status to unknown. Also all the status keys for the constraints and the variables are set to unknown.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_netextraction</tt></span>

<p> <a name="func*mosek*task*netextraction">&#09;</a><a name="common-func*mosek*task*netextraction"></a> <a name="idx-131089976">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_netextraction (
    MSKtask_t task,
    MSKintt * numcon,
    MSKintt * numvar,
    MSKidxt * netcon,
    MSKidxt * netvar,
    MSKrealt * scalcon,
    MSKrealt * scalvar,
    MSKrealt * cx,
    MSKboundkeye * bkc,
    MSKrealt * blc,
    MSKrealt * buc,
    MSKboundkeye * bkx,
    MSKrealt * blx,
    MSKrealt * bux,
    MSKidxt * from,
    MSKidxt * to);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>Task containing the linear problem the network extraction heuristics should be performed on.</dd>
<dt><tt class="tt">numcon</tt> (output)</dt>
<dd>Number of network constraints (nodes) in the embedded network.</dd>
<dt><tt class="tt">numvar</tt> (output)</dt>
<dd>Number of network variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">netcon</tt> (output)</dt>
<dd>Indexes of network constraints (nodes) in the embedded network.</dd>
<dt><tt class="tt">netvar</tt> (output)</dt>
<dd>Indexes of network variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">scalcon</tt> (output)</dt>
<dd>Scaling values on constraints, used to convert the original part of the problem into network form.</dd>
<dt><tt class="tt">scalvar</tt> (output)</dt>
<dd>Scaling values on variables, used to convert the original part of the problem into network form.</dd>
<dt><tt class="tt">cx</tt> (output)</dt>
<dd>Linear terms of the objective for variables (arcs) in the embedded network as a dense vector.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (output)</dt>
<dd>Bound keys for the constraints (nodes) in the embedded network.</dd>
<dt><tt class="tt">blc</tt> (output)</dt>
<dd>Lower bounds for the constraints (nodes) in the embedded network.</dd>
<dt><tt class="tt">buc</tt> (output)</dt>
<dd>Upper bounds for the constraints (nodes) in the embedded network.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (output)</dt>
<dd>Bound keys for the variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">blx</tt> (output)</dt>
<dd>Lower bounds for the variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">bux</tt> (output)</dt>
<dd>Upper bounds for the variables (arcs) in the embedded network.</dd>
<dt><tt class="tt">from</tt> (output)</dt>
<dd>Defines the origins of the arcs in the embedded network.</dd>
<dt><tt class="tt">to</tt> (output)</dt>
<dd>Defines the destinations of the arcs in the embedded network.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Uses a heuristic to find an embedded network in the problem specified in task. The returned network is a pure network flow problem and can be solved with a direct call to the network optimizer <a href="node017.html#common-func*mosek*task*netoptimize"><tt class="tt">MSK_netoptimize</tt></a>. 
<br/>Each arc <span class="math"><span class="mi">a</span></span> in the network corresponds to a scaled subset of elements in column <span class="math"><img src="math/math975.png" alt="[[MathCmd 975]]"/></span> from the constraint matrix <span class="math"><span class="mi">A</span></span> stored in <tt class="tt">task</tt>. Each node <span class="math"><span class="mi">n</span></span> in the network corresponds to a scaled subset of elements in constraint <span class="math"><span class="mi">i</span><span class="mo">=</span><span class="mi">n</span><span class="mi">e</span><span class="mi">t</span><span class="mi">c</span><span class="mi">o</span><span class="mi">n</span><span class="mo">[</span><span class="mi">n</span><span class="mo">]</span></span> from <span class="math"><span class="mi">A</span></span>. Data structures for network problems is explained in <a title="5.2. Linear optimization" href="node007.html#chap-apiintro-sec-linear-optimization">5.2</a> and <a title="6.6. Embedded network flow problems" href="node008.html#advanced-embedded-network">6.6</a>. The relation between <span class="math"><span class="mi">A</span></span> and the extracted embedded network can be explained as follows: </p>

<ul class="itemize">
<li><span class="math"><img src="math/math976.png" alt="[[MathCmd 976]]"/></span> </li>
<li><span class="math"><img src="math/math977.png" alt="[[MathCmd 977]]"/></span> </li>
<li>The scaled matrix has at most two non-zeroes in each column in <tt class="tt">netvar</tt> over the indexes in <tt class="tt">netcon</tt> (i.e defines a pure network flow matrix). </li>
</ul>

<p> Please note if a column <span class="math"><span class="mi">j</span><span class="mo">=</span><span class="mi">n</span><span class="mi">e</span><span class="mi">t</span><span class="mi">v</span><span class="mi">a</span><span class="mi">r</span><span class="mo">[</span><span class="mi">a</span><span class="mo">]</span></span> is only represented by one non-zero in the embedded network, then either <span class="math"><span class="mi">f</span><span class="mi">r</span><span class="mi">o</span><span class="mi">m</span><span class="mo">[</span><span class="mi">a</span><span class="mo">]</span><span class="mo">=</span><span class="mi">n</span><span class="mi">e</span><span class="mi">t</span><span class="mi">c</span><span class="mi">o</span><span class="mi">n</span></span> or <span class="math"><span class="mi">t</span><span class="mi">o</span><span class="mo">[</span><span class="mi">a</span><span class="mo">]</span><span class="mo">=</span><span class="mi">n</span><span class="mi">e</span><span class="mi">t</span><span class="mi">c</span><span class="mi">o</span><span class="mi">n</span></span>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*netoptimize"><tt class="tt">MSK_netoptimize</tt></a></dt>
<dd>
<p> Optimizes a pure network flow problem.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_netoptimize</tt></span>

<p> <a name="func*mosek*task*netoptimize">&#09;</a><a name="common-func*mosek*task*netoptimize"></a> <a name="idx-131127488">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_netoptimize (
    MSKtask_t task,
    MSKintt numcon,
    MSKintt numvar,
    MSKCONST MSKrealt * cc,
    MSKCONST MSKrealt * cx,
    MSKCONST MSKboundkeye * bkc,
    MSKCONST MSKrealt * blc,
    MSKCONST MSKrealt * buc,
    MSKCONST MSKboundkeye * bkx,
    MSKCONST MSKrealt * blx,
    MSKCONST MSKrealt * bux,
    MSKCONST MSKidxt * from,
    MSKCONST MSKidxt * to,
    MSKprostae * prosta,
    MSKsolstae * solsta,
    MSKbooleant hotstart,
    MSKstakeye * skc,
    MSKstakeye * skx,
    MSKrealt * xc,
    MSKrealt * xx,
    MSKrealt * y,
    MSKrealt * slc,
    MSKrealt * suc,
    MSKrealt * slx,
    MSKrealt * sux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numcon</tt> (input)</dt>
<dd>Number of network constraints (nodes) in the network.</dd>
<dt><tt class="tt">numvar</tt> (input)</dt>
<dd>Number of network variables (arcs) in the network.</dd>
<dt><tt class="tt">cc</tt> (input)</dt>
<dd>Linear terms of the objective for constraints (nodes) as a dense vector.</dd>
<dt><tt class="tt">cx</tt> (input)</dt>
<dd>Linear terms of the objective for variables (arcs) as a dense vector.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkc</tt></a> (input)</dt>
<dd>Bound keys for the constraints (nodes).</dd>
<dt><tt class="tt">blc</tt> (input)</dt>
<dd>Lower bounds for the constraints (nodes).</dd>
<dt><tt class="tt">buc</tt> (input)</dt>
<dd>Upper bounds for the constraints (nodes).</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bkx</tt></a> (input)</dt>
<dd>Bound keys for the variables (arcs).</dd>
<dt><tt class="tt">blx</tt> (input)</dt>
<dd>Lower bounds for the variables (arcs).</dd>
<dt><tt class="tt">bux</tt> (input)</dt>
<dd>Upper bounds for the variables (arcs).</dd>
<dt><tt class="tt">from</tt> (input)</dt>
<dd>Defines the origins of the arcs in the network.</dd>
<dt><tt class="tt">to</tt> (input)</dt>
<dd>Defines the destinations of the arcs in the network.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (output)</dt>
<dd>Problem status.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (output)</dt>
<dd>Solution status.</dd>
<dt><tt class="tt">hotstart</tt> (input)</dt>
<dd>If zero the network optimizer will not use hot-starts, if non-zero a solution must be defined in the solution variables below, which will be used to hot-start the network optimizer.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skc</tt></a> (input/output)</dt>
<dd>Status keys for the constraints (nodes).</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skx</tt></a> (input/output)</dt>
<dd>Status keys for the variables (arcs).</dd>
<dt><tt class="tt">xc</tt> (input/output)</dt>
<dd>Primal constraint solution (nodes).</dd>
<dt><tt class="tt">xx</tt> (input/output)</dt>
<dd>Primal variable solution (arcs).</dd>
<dt><tt class="tt">y</tt> (input/output)</dt>
<dd>Vector of dual variables corresponding to the constraints (nodes).</dd>
<dt><tt class="tt">slc</tt> (input/output)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (nodes).</dd>
<dt><tt class="tt">suc</tt> (input/output)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (nodes).</dd>
<dt><tt class="tt">slx</tt> (input/output)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (arcs).</dd>
<dt><tt class="tt">sux</tt> (input/output)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (arcs).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Uses the network optimizer to solve the given network problem. The problem must be a pure network flow problem. If <tt class="tt">hotstart</tt> is zero the network optimizer will not use hot-starts, if non-zero a solution must be defined in the solution variables <tt class="tt">skc</tt>,<tt class="tt">skx</tt>,<tt class="tt">xc</tt>,<tt class="tt">xx</tt>,<tt class="tt">y</tt>,<tt class="tt">slc</tt>,<tt class="tt">suc</tt>,<tt class="tt">slx</tt> and <tt class="tt">sux</tt>, which will be used to hot-start the network optimizer. Please note <tt class="tt">task</tt> only acts as a dummy task, where parameters and streams can be set for the network optimizer. No other data in <tt class="tt">task</tt> is used.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*netextraction"><tt class="tt">MSK_netextraction</tt></a></dt>
<dd>
<p> Finds embedded network structure.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_optimize</tt></span>

<p> <a name="func*mosek*task*optimize">&#09;</a><a name="common-func*mosek*task*optimize"></a> <a name="idx-132678648">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_optimize (MSKtask_t task)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Calls the optimizer. Depending on the problem type and the selected optimizer this will call one of the optimizers in MOSEK. By default the interior point optimizer will be selected for continuous problems. The optimizer may be selected manually by setting the parameter <a href="node018.html#common-const*mosek*iparam*optimizer"><tt class="tt">MSK_IPAR_OPTIMIZER</tt></a>.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*optimizeconcurrent"><tt class="tt">MSK_optimizeconcurrent</tt></a></dt>
<dd>
<p> Optimize a given task with several optimizers concurrently.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">MSK_getsolution</tt></a></dt>
<dd>
<p> Obtains the complete solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">MSK_getsolutioni</tt></a></dt>
<dd>
<p> Obtains the solution for a single constraint or variable.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*optimizer"><tt class="tt">MSK_IPAR_OPTIMIZER</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_optimizeconcurrent</tt></span>

<p> <a name="func*mosek*task*optimizeconcurrent">&#09;</a><a name="common-func*mosek*task*optimizeconcurrent"></a> <a name="idx-132700208">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_optimizeconcurrent (
    MSKtask_t task,
    MSKCONST MSKtask_t * taskarray,
    MSKintt num);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">taskarray</tt> (input)</dt>
<dd>An array of <tt class="tt">num</tt> tasks.</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Length of <tt class="tt">taskarray</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Solves several instances of the same problem in parallel, with unique parameter settings for each task. The argument <tt class="tt">task</tt> contains the problem to be solved. <tt class="tt">taskarray</tt> is a pointer to an array of <tt class="tt">num</tt> empty tasks. The task <tt class="tt">task</tt> and the <tt class="tt">num</tt> tasks pointed to by <tt class="tt">taskarray</tt> are solved in parallel. That is <span class="math"><img src="math/math978.png" alt="[[MathCmd 978]]"/></span> threads are started with one optimizer in each. Each of the tasks can be initialized with different parameters, e.g different selection of solver.</p>

<p>All the concurrently running tasks are stopped when the optimizer successfully terminates for one of the tasks. After the function returns <tt class="tt">task</tt> contains the solution found by the task that finished first.</p>

<p>After <a href="node017.html#common-func*mosek*task*optimizeconcurrent"><tt class="tt">MSK_optimizeconcurrent</tt></a> returns <tt class="tt">task</tt> holds the optimal solution of the task which finished first. If all the concurrent optimizations finished without providing an optimal solution the error code from the solution of the task <tt class="tt">task</tt> is returned.</p>

<p>In summary a call to <a href="node017.html#common-func*mosek*task*optimizeconcurrent"><tt class="tt">MSK_optimizeconcurrent</tt></a> does the following:</p>

<ol class="enumerate">
<li>All data except task parameters (<a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">MSKiparam</tt></a>, <a href="node018.html#common-constclass*mosek*dparam"><tt class="tt">MSKdparam</tt></a> and <a href="node018.html#common-constclass*mosek*sparam"><tt class="tt">MSKsparam</tt></a>) in <tt class="tt">task</tt> is copied to each of the tasks in <tt class="tt">taskarray</tt>. In particular this means that any solution in <tt class="tt">task</tt> is copied to the other tasks. Call-back functions are not copied. </li>
<li>The tasks <tt class="tt">task</tt> and the <tt class="tt">num</tt> tasks in <tt class="tt">taskarray</tt> are started in parallel. </li>
<li>When a task finishes providing an optimal solution (or a certificate of infeasibility) its solution is copied to <tt class="tt">task</tt> and all other tasks are stopped. </li>
</ol>

<p> For an explained code example see Section <a title="8.6.4. A more flexible concurrent optimizer" href="node010.html#ch-concurrentopt-sec-flex">8.6.4</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_optimizersummary</tt></span>

<p> <a name="func*mosek*task*optimizersummary">&#09;</a><a name="common-func*mosek*task*optimizersummary"></a> <a name="idx-132745336">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_optimizersummary (
    MSKtask_t task,
    MSKstreamtypee whichstream);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints a short summary with optimizer statistics for last optimization.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_optimizetrm</tt></span>

<p> <a name="func*mosek*task*optimizetrm">&#09;</a><a name="common-func*mosek*task*optimizetrm"></a> <a name="idx-132746632">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_optimizetrm (
    MSKtask_t task,
    MSKrescodee * trmcode);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node019.html#common-constclass*mosek*rescode"><tt class="tt">trmcode</tt></a> (output)</dt>
<dd>Is either <a href="#common-const*mosek*rescode*ok"><tt class="tt">MSK_RES_OK</tt></a> or a termination response code.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Calls the optimizer. Depending on the problem type and the selected optimizer this will call one of the optimizers in MOSEK. By default the interior point optimizer will be selected for continuous problems. The optimizer may be selected manually by setting the parameter <a href="node018.html#common-const*mosek*iparam*optimizer"><tt class="tt">MSK_IPAR_OPTIMIZER</tt></a>.</p>

<p>This function is equivalent to <a href="node017.html#common-func*mosek*task*optimize"><tt class="tt">MSK_optimize</tt></a> except in the case where <a href="node017.html#common-func*mosek*task*optimize"><tt class="tt">MSK_optimize</tt></a> would have returned a termination response code such as  </p>

<ul class="itemize">
<li><a href="#common-const*mosek*rescode*trm-max-iterations"><tt class="tt">MSK_RES_TRM_MAX_ITERATIONS</tt></a> or </li>
<li><a href="#common-const*mosek*rescode*trm-stall"><tt class="tt">MSK_RES_TRM_STALL</tt></a>. </li>
</ul>

<p> Response codes comes in three categories: </p>

<ul class="itemize">
<li>Errors: Indicate that an error has occurred during the optimization. E.g that the optimizer has run out of memory (<a href="#common-const*mosek*rescode*err-space"><tt class="tt">MSK_RES_ERR_SPACE</tt></a>). </li>
<li>Warnings: Less fatal than errors. E.g <a href="#common-const*mosek*rescode*wrn-large-cj"><tt class="tt">MSK_RES_WRN_LARGE_CJ</tt></a> indicating possibly problematic problem data.</li>
<li>Termination codes: Relaying information about the conditions under which the optimizer terminated. E.g <a href="#common-const*mosek*rescode*trm-max-iterations"><tt class="tt">MSK_RES_TRM_MAX_ITERATIONS</tt></a> indicates that the optimizer finished because it reached the maximum number of iterations specified by the user. </li>
</ul>

<p> This function returns errors on the left hand side. Warnings are not returned and termination codes are returned in the separate argument <tt class="tt">trmcode</tt>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*optimize"><tt class="tt">MSK_optimize</tt></a></dt>
<dd>
<p> Optimizes the problem.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*optimizeconcurrent"><tt class="tt">MSK_optimizeconcurrent</tt></a></dt>
<dd>
<p> Optimize a given task with several optimizers concurrently.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolution"><tt class="tt">MSK_getsolution</tt></a></dt>
<dd>
<p> Obtains the complete solution.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioni"><tt class="tt">MSK_getsolutioni</tt></a></dt>
<dd>
<p> Obtains the solution for a single constraint or variable.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*getsolutioninf"><tt class="tt">MSK_getsolutioninf</tt></a></dt>
<dd>
<p> Obtains information about a solution.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*optimizer"><tt class="tt">MSK_IPAR_OPTIMIZER</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_primalsensitivity</tt></span>

<p> <a name="func*mosek*task*primalsensitivity">&#09;</a><a name="common-func*mosek*task*primalsensitivity"></a> <a name="idx-132810728">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_primalsensitivity (
    MSKtask_t task,
    MSKintt numi,
    MSKCONST MSKidxt * subi,
    MSKCONST MSKmarke * marki,
    MSKintt numj,
    MSKCONST MSKidxt * subj,
    MSKCONST MSKmarke * markj,
    MSKrealt * leftpricei,
    MSKrealt * rightpricei,
    MSKrealt * leftrangei,
    MSKrealt * rightrangei,
    MSKrealt * leftpricej,
    MSKrealt * rightpricej,
    MSKrealt * leftrangej,
    MSKrealt * rightrangej);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numi</tt> (input)</dt>
<dd>Number of bounds on constraints to be analyzed. Length of <tt class="tt">subi</tt> and <tt class="tt">marki</tt>.</dd>
<dt><tt class="tt">subi</tt> (input)</dt>
<dd>Indexes of bounds on constraints to analyze.</dd>
<dt><a href="node020.html#common-constclass*mosek*mark"><tt class="tt">marki</tt></a> (input)</dt>
<dd>The value of <tt class="tt">marki[i]</tt> specifies for which bound (upper or lower) on constraint <tt class="tt">subi[i]</tt> sensitivity analysis should be performed.</dd>
<dt><tt class="tt">numj</tt> (input)</dt>
<dd>Number of bounds on variables to be analyzed. Length of <tt class="tt">subj</tt> and <tt class="tt">markj</tt>.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Indexes of bounds on variables to analyze.</dd>
<dt><a href="node020.html#common-constclass*mosek*mark"><tt class="tt">markj</tt></a> (input)</dt>
<dd>The value of <tt class="tt">markj[j]</tt> specifies for which bound (upper or lower) on variable <tt class="tt">subj[j]</tt> sensitivity analysis should be performed.</dd>
<dt><tt class="tt">leftpricei</tt> (output)</dt>
<dd><tt class="tt">leftpricei[i]</tt> is the left shadow price for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">rightpricei</tt> (output)</dt>
<dd><tt class="tt">rightpricei[i]</tt> is the right shadow price for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">leftrangei</tt> (output)</dt>
<dd><tt class="tt">leftrangei[i]</tt> is the left range for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">rightrangei</tt> (output)</dt>
<dd><tt class="tt">rightrangei[i]</tt> is the right range for the upper/lower bound (indicated by <tt class="tt">marki[i]</tt>) of the constraint with index <tt class="tt">subi[i]</tt>.</dd>
<dt><tt class="tt">leftpricej</tt> (output)</dt>
<dd><tt class="tt">leftpricej[j]</tt> is the left shadow price for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt>.</dd>
<dt><tt class="tt">rightpricej</tt> (output)</dt>
<dd><tt class="tt">rightpricej[j]</tt> is the right shadow price for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt> .</dd>
<dt><tt class="tt">leftrangej</tt> (output)</dt>
<dd><tt class="tt">leftrangej[j]</tt> is the left range for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt>.</dd>
<dt><tt class="tt">rightrangej</tt> (output)</dt>
<dd><tt class="tt">rightrangej[j]</tt> is the right range for the upper/lower bound (indicated by <tt class="tt">marki[j]</tt>) on variable <tt class="tt">subj[j]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Calculates sensitivity information for bounds on variables and constraints.</p>

<p>For details on sensitivity analysis and the definitions of <em>shadow price</em> and <em>linearity interval</em> see chapter <a title="12. Sensitivity analysis" href="node014.html#chap-sensitivity-analysis">12</a>.</p>

<p>The constraints for which sensitivity analysis is performed are given by the data structures:</p>

<ol class="enumerate">
<li><tt class="tt">subi</tt> Index of constraint to analyze.</li>
<li><tt class="tt">marki</tt> Indicate for which bound of constraint <tt class="tt">subi[i]</tt> sensitivity analysis is performed. If <tt class="tt">marki[i] = <a href="node020.html#common-const*mosek*mark*up"><tt class="tt">MSK_MARK_UP</tt></a></tt> the upper bound of constraint <tt class="tt">subi[i]</tt> is analyzed, and if <tt class="tt">marki[i] = <a href="node020.html#common-const*mosek*mark*lo"><tt class="tt">MSK_MARK_LO</tt></a></tt> the lower bound is analyzed. If <tt class="tt">subi[i]</tt> is an equality constraint, either <tt class="tt"><a href="node020.html#common-const*mosek*mark*lo"><tt class="tt">MSK_MARK_LO</tt></a></tt> or <tt class="tt"><a href="node020.html#common-const*mosek*mark*up"><tt class="tt">MSK_MARK_UP</tt></a></tt> can be used to select the constraint for sensitivity analysis. </li>
</ol>

<p> Consider the problem:</p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math979.png" alt="\begin{math}\nonumber{}\begin{array}{lccl}\nonumber{}\mbox{minimize} & x_{1}+x_{2} &  & \\\nonumber{}\mbox{subject to}-1\leq{} & x_{1}-x_{2} & \leq{} & 1,\\\nonumber{} & x_{1} & = & 0,\\\nonumber{} & x_{1}\geq{}0,x_{2}\geq{}0 &  &\end{array}\end{math}"/></td>
<td>(15.4.24)</td></tr>
</tbody>
</table>

<p> Suppose that </p>

<pre class="verbatim">                    numi = 1;
                    subi = [0];
                    marki = [MSK_MARK_UP]                    
                    </pre>

<p> then</p>

<p><tt class="tt">leftpricei[0]</tt>, <tt class="tt">rightpricei[0]</tt>, <tt class="tt">leftrangei[0]</tt> and <tt class="tt">rightrangei[0]</tt> will contain the sensitivity information for the upper bound on constraint <span class="math"><span class="mn">0</span></span> given by the expression: </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math980.png" alt="\begin{math}\nonumber{}x_{1}-x_{2}\leq{}1\end{math}"/></td>
<td>(15.4.25)</td></tr>
</tbody>
</table>

<p> Similarly, the variables for which to perform sensitivity analysis are given by the structures: </p>

<ol class="enumerate">
<li><tt class="tt">subj</tt> Index of variables to analyze. </li>
<li><tt class="tt">markj</tt> Indicate for which bound of variable <tt class="tt">subi[j]</tt> sensitivity analysis is performed. If <tt class="tt">markj[j] = <a href="node020.html#common-const*mosek*mark*up"><tt class="tt">MSK_MARK_UP</tt></a></tt> the upper bound of constraint <tt class="tt">subi[j]</tt> is analyzed, and if <tt class="tt">markj[j] = <a href="node020.html#common-const*mosek*mark*lo"><tt class="tt">MSK_MARK_LO</tt></a></tt> the lower bound is analyzed. If <tt class="tt">subi[j]</tt> is an equality constraint, either <tt class="tt"><a href="node020.html#common-const*mosek*mark*lo"><tt class="tt">MSK_MARK_LO</tt></a></tt> or <tt class="tt"><a href="node020.html#common-const*mosek*mark*up"><tt class="tt">MSK_MARK_UP</tt></a></tt> can be used to select the constraint for sensitivity analysis. </li>
</ol>

<p> For an example, please see Section <a title="12.5. Sensitivity analysis from the MOSEK API" href="node014.html#chap-sensitivity-sec-apiex">12.5</a>.</p>

<p>The type of sensitivity analysis to be performed (basis or optimal partition) is controlled by the parameter <a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">MSK_IPAR_SENSITIVITY_TYPE</tt></a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*dualsensitivity"><tt class="tt">MSK_dualsensitivity</tt></a></dt>
<dd>
<p> Performs sensitivity analysis on objective coefficients.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*sensitivityreport"><tt class="tt">MSK_sensitivityreport</tt></a></dt>
<dd>
<p> Creates a sensitivity report.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">MSK_IPAR_SENSITIVITY_TYPE</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity"><tt class="tt">MSK_IPAR_LOG_SENSITIVITY</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity-opt"><tt class="tt">MSK_IPAR_LOG_SENSITIVITY_OPT</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_printdata</tt></span>

<p> <a name="func*mosek*task*printdata">&#09;</a><a name="common-func*mosek*task*printdata"></a> <a name="idx-132832792">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_printdata (
    MSKtask_t task,
    MSKstreamtypee whichstream,
    MSKidxt firsti,
    MSKidxt lasti,
    MSKidxt firstj,
    MSKidxt lastj,
    MSKidxt firstk,
    MSKidxt lastk,
    MSKintt c,
    MSKintt qo,
    MSKintt a,
    MSKintt qc,
    MSKintt bc,
    MSKintt bx,
    MSKintt vartype,
    MSKintt cones);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
<dt><tt class="tt">firsti</tt> (input)</dt>
<dd>Index of first constraint for which data should be printed.</dd>
<dt><tt class="tt">lasti</tt> (input)</dt>
<dd>Index of last constraint plus 1 for which data should be printed.</dd>
<dt><tt class="tt">firstj</tt> (input)</dt>
<dd>Index of first variable for which data should be printed.</dd>
<dt><tt class="tt">lastj</tt> (input)</dt>
<dd>Index of last variable plus 1 for which data should be printed.</dd>
<dt><tt class="tt">firstk</tt> (input)</dt>
<dd>Index of first cone for which data should be printed.</dd>
<dt><tt class="tt">lastk</tt> (input)</dt>
<dd>Index of last cone plus 1 for which data should be printed.</dd>
<dt><tt class="tt">c</tt> (input)</dt>
<dd>If non-zero <span class="math"><span class="mi">c</span></span> is printed.</dd>
<dt><tt class="tt">qo</tt> (input)</dt>
<dd>If non-zero <span class="math"><img src="math/math36.png" alt="[[MathCmd 36]]"/></span> is printed.</dd>
<dt><tt class="tt">a</tt> (input)</dt>
<dd>If non-zero <span class="math"><span class="mi">A</span></span> is printed.</dd>
<dt><tt class="tt">qc</tt> (input)</dt>
<dd>If non-zero <span class="math"><img src="math/math37.png" alt="[[MathCmd 37]]"/></span> is printed for the relevant constraints.</dd>
<dt><tt class="tt">bc</tt> (input)</dt>
<dd>If non-zero the constraints bounds are printed.</dd>
<dt><tt class="tt">bx</tt> (input)</dt>
<dd>If non-zero the variable bounds are printed.</dd>
<dt><tt class="tt">vartype</tt> (input)</dt>
<dd>If non-zero the variable types are printed.</dd>
<dt><tt class="tt">cones</tt> (input)</dt>
<dd>If non-zero the conic data is printed.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints a part of the problem data to a stream. This function is normally used for debugging purposes only, e.g. to verify that the correct data has been inputted.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_printparam</tt></span>

<p> <a name="func*mosek*task*printparam">&#09;</a><a name="common-func*mosek*task*printparam"></a> <a name="idx-134350608">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_printparam (MSKtask_t task)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints the current parameter settings to the message stream.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_probtypetostr</tt></span>

<p> <a name="func*mosek*task*probtypetostr">&#09;</a><a name="common-func*mosek*task*probtypetostr"></a> <a name="idx-134348952">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_probtypetostr (
    MSKtask_t task,
    MSKproblemtypee probtype,
    char * str);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*problemtype"><tt class="tt">probtype</tt></a> (input)</dt>
<dd>Problem type.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the problem type key <tt class="tt">probtype</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a string containing the name of a problem type given.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_prostatostr</tt></span>

<p> <a name="func*mosek*task*prostatostr">&#09;</a><a name="common-func*mosek*task*prostatostr"></a> <a name="idx-134376192">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_prostatostr (
    MSKtask_t task,
    MSKprostae prosta,
    char * str);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a> (input)</dt>
<dd>Problem status.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the status key <tt class="tt">prosta</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains a string containing the name of a problem status given.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putaij</tt></span>

<p> <a name="func*mosek*task*putaij">&#09;</a><a name="common-func*mosek*task*putaij"></a> <a name="idx-134350824">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putaij (
    MSKtask_t task,
    MSKidxt i,
    MSKidxt j,
    MSKrealt aij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint in which the change should occur.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable in which the change should occur.</dd>
<dt><tt class="tt">aij</tt> (input)</dt>
<dd>New coefficient for <span class="math"><img src="math/math897.png" alt="[[MathCmd 897]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Changes a coefficient in <span class="math"><span class="mi">A</span></span> using the method </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math984.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{i}\mathtt{j}}}=\mathtt{aij}.\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">MSK_putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putaij"><tt class="tt">MSK_putaij</tt></a></dt>
<dd>
<p> Changes a single value in the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">MSK_putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putaijlist</tt></span>

<p> <a name="func*mosek*task*putaijlist">&#09;</a><a name="common-func*mosek*task*putaijlist"></a> <a name="idx-134420960">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putaijlist (
    MSKtask_t task,
    MSKintt num,
    MSKCONST MSKidxt * subi,
    MSKCONST MSKidxt * subj,
    MSKCONST MSKrealt * valij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of coefficients that should be changed.</dd>
<dt><tt class="tt">subi</tt> (input)</dt>
<dd>Constraint indexes in which the change should occur.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Variable indexes in which the change should occur.</dd>
<dt><tt class="tt">valij</tt> (input)</dt>
<dd>New coefficient values for <span class="math"><img src="math/math897.png" alt="[[MathCmd 897]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Changes one or more coefficients in <span class="math"><span class="mi">A</span></span> using the method </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math986.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{subi[k]},\mathtt{subj[k]}}}=\mathtt{valij[k]},\quad{}k=0,\ldots ,\mathtt{num}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> If the same <span class="math"><img src="math/math897.png" alt="[[MathCmd 897]]"/></span> entry appears multiple times only the last one will be used.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">MSK_putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putaij"><tt class="tt">MSK_putaij</tt></a></dt>
<dd>
<p> Changes a single value in the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">MSK_putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putavec</tt></span>

<p> <a name="func*mosek*task*putavec">&#09;</a><a name="common-func*mosek*task*putavec"></a> <a name="idx-134453440">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putavec (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt i,
    MSKintt nzi,
    MSKCONST MSKidxt * asub,
    MSKCONST MSKrealt * aval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether to replace a column or a row.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>If <tt class="tt">accmode</tt> equals <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a>, then <span class="math"><span class="mi">i</span></span> is a constraint index. Otherwise it is a column index.</dd>
<dt><tt class="tt">nzi</tt> (input)</dt>
<dd>Number of non-zeros in the vector.</dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>Index of the <span class="math"><img src="math/math897.png" alt="[[MathCmd 897]]"/></span> values that should be changed.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>New <span class="math"><img src="math/math897.png" alt="[[MathCmd 897]]"/></span> values.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all elements in one row or column of <span class="math"><span class="mi">A</span></span>.</p>

<p>Assuming that there are no duplicate subscripts in <tt class="tt">asub</tt>, assignment is performed as follows: </p>

<ul class="itemize">
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a>, then </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math990.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{i},\mathtt{asub}[k]}}=\mathtt{aval}[k],\quad{}k=0,\ldots ,\mathtt{nzi}-1\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> and all other <span class="math"><img src="math/math991.png" alt="[[MathCmd 991]]"/></span>. </p>
</li>
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">MSK_ACC_VAR</tt></a>, then </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math992.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{asub}[k],\mathtt{i}}}=\mathtt{aval}[k],\quad{}k=0,\ldots ,\mathtt{nzi}-1\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> and all other <span class="math"><img src="math/math993.png" alt="[[MathCmd 993]]"/></span>. </p>
</li>
</ul>

<p> If <tt class="tt">asub</tt> contains duplicates, the corresponding coefficients will be added together.</p>

<p>For an explanation of the meaning of <tt class="tt">ptrb</tt> and <tt class="tt">ptre</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">MSK_putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putaij"><tt class="tt">MSK_putaij</tt></a></dt>
<dd>
<p> Changes a single value in the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">MSK_putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putaveclist</tt></span>

<p> <a name="func*mosek*task*putaveclist">&#09;</a><a name="common-func*mosek*task*putaveclist"></a> <a name="idx-134405296">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putaveclist (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKintt num,
    MSKCONST MSKidxt * sub,
    MSKCONST MSKintt * ptrb,
    MSKCONST MSKintt * ptre,
    MSKCONST MSKidxt * asub,
    MSKCONST MSKrealt * aval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of rows or columns of <span class="math"><span class="mi">A</span></span> to replace.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of rows or columns that should be replaced. <tt class="tt">sub</tt> should not contain duplicate values.</dd>
<dt><tt class="tt">ptrb</tt> (input)</dt>
<dd>Array of pointers to the first element in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptrb</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">ptre</tt> (input)</dt>
<dd>Array of pointers to the last element plus one in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptre</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a>, then <tt class="tt">asub</tt> contains the new variable indexes, otherwise it contains the new constraint indexes.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all elements in a set of rows or columns of <span class="math"><span class="mi">A</span></span>.</p>

<p>The elements are replaced as follows. </p>

<ul class="itemize">
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a>, then for <span class="math"><img src="math/math994.png" alt="[[MathCmd 994]]"/></span> </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math995.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{sub}[i],\mathtt{asub}[k]}}=\mathtt{aval}[k],\quad{}k=\mathtt{aptrb}[i],\ldots ,\mathtt{aptre}[i]-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">MSK_ACC_VAR</tt></a>, then for <span class="math"><img src="math/math994.png" alt="[[MathCmd 994]]"/></span> </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math997.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{asub}[k],\mathtt{sub}[i]}}=\mathtt{aval}[k],\quad{}k=\mathtt{aptrb}[i],\ldots ,\mathtt{aptre}[i]-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
</ul>

<p>  If the same row or column appears multiple times only the last one will be used.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">MSK_putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">MSK_putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putaveclist64</tt></span>

<p> <a name="func*mosek*task*putaveclist64">&#09;</a><a name="common-func*mosek*task*putaveclist64"></a> <a name="idx-134551816">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putaveclist64 (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKintt num,
    MSKCONST MSKidxt * sub,
    MSKCONST MSKint64t * ptrb,
    MSKCONST MSKint64t * ptre,
    MSKCONST MSKidxt * asub,
    MSKCONST MSKrealt * aval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of rows or columns of <span class="math"><span class="mi">A</span></span> to replace.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of rows or columns that should be replaced. <tt class="tt">sub</tt> should not contain duplicate values.</dd>
<dt><tt class="tt">ptrb</tt> (input)</dt>
<dd>Array of pointers to the first element in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptrb</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">ptre</tt> (input)</dt>
<dd>Array of pointers to the last element plus one in the rows or columns stored in <tt class="tt">asub</tt> and <tt class="tt">aval</tt>. For an explanation of the meaning of <tt class="tt">ptre</tt> see Section <a title="5.8.3.2. Row or column ordered sparse matrix" href="node007.html#sec-intro-subsubsec-cmo-rmo-matrix">5.8.3.2</a>.</dd>
<dt><tt class="tt">asub</tt> (input)</dt>
<dd>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a>, then <tt class="tt">asub</tt> contains the new variable indexes, otherwise it contains the new constraint indexes.</dd>
<dt><tt class="tt">aval</tt> (input)</dt>
<dd>Coefficient values. See (<a href="node007.html#EQ:ADEF">5.8.5</a>) and Section <a title="5.8.3. Matrix formats" href="node007.html#sec-matrix-formats">5.8.3</a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all elements in a set of rows or columns of <span class="math"><span class="mi">A</span></span>.</p>

<p>The elements are replaced as follows. </p>

<ul class="itemize">
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a>, then for <span class="math"><img src="math/math994.png" alt="[[MathCmd 994]]"/></span> </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math995.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{sub}[i],\mathtt{asub}[k]}}=\mathtt{aval}[k],\quad{}k=\mathtt{aptrb}[i],\ldots ,\mathtt{aptre}[i]-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
<li>
<p>If <tt class="tt">accmode</tt> is <a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">MSK_ACC_VAR</tt></a>, then for <span class="math"><img src="math/math994.png" alt="[[MathCmd 994]]"/></span> </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math997.png" alt="\begin{displaymath}\nonumber{}a_{{\mathtt{asub}[k],\mathtt{sub}[i]}}=\mathtt{aval}[k],\quad{}k=\mathtt{aptrb}[i],\ldots ,\mathtt{aptre}[i]-1.\end{displaymath}"/></td></tr>
</tbody>
</table>
</li>
</ul>

<p>  If the same row or column appears multiple times only the last one will be used.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putavec"><tt class="tt">MSK_putavec</tt></a></dt>
<dd>
<p> Replaces all elements in one row or column of the linear coefficient matrix.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">MSK_putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putbound</tt></span>

<p> <a name="func*mosek*task*putbound">&#09;</a><a name="common-func*mosek*task*putbound"></a> <a name="idx-136174912">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putbound (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt i,
    MSKboundkeye bk,
    MSKrealt bl,
    MSKrealt bu);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether the bound for a constraint or a variable is changed.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (input)</dt>
<dd>New bound key.</dd>
<dt><tt class="tt">bl</tt> (input)</dt>
<dd>New lower bound.</dd>
<dt><tt class="tt">bu</tt> (input)</dt>
<dd>New upper bound.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Changes the bounds for either one constraint or one variable.</p>

<p>If the a bound value specified is numerically larger than <a href="node018.html#common-const*mosek*dparam*data-tol-bound-inf"><tt class="tt">MSK_DPAR_DATA_TOL_BOUND_INF</tt></a> it is considered infinite and the bound key is changed accordingly. If a bound value is numerically larger than <a href="node018.html#common-const*mosek*dparam*data-tol-bound-wrn"><tt class="tt">MSK_DPAR_DATA_TOL_BOUND_WRN</tt></a>, a warning will be displayed, but the bound is inputted as specified.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putboundlist"><tt class="tt">MSK_putboundlist</tt></a></dt>
<dd>
<p> Changes the bounds of constraints or variables.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putboundlist</tt></span>

<p> <a name="func*mosek*task*putboundlist">&#09;</a><a name="common-func*mosek*task*putboundlist"></a> <a name="idx-136196320">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putboundlist (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKintt num,
    MSKCONST MSKidxt * sub,
    MSKCONST MSKboundkeye * bk,
    MSKCONST MSKrealt * bl,
    MSKCONST MSKrealt * bu);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines whether bounds for constraints (<a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a>) or variables (<a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">MSK_ACC_VAR</tt></a>) are changed.</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of bounds that should be changed.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Subscripts of the bounds that should be changed.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (input)</dt>
<dd>Constraint or variable index <tt class="tt">sub[t]</tt> is assigned the bound key <tt class="tt">bk[t]</tt>.</dd>
<dt><tt class="tt">bl</tt> (input)</dt>
<dd>Constraint or variable index <tt class="tt">sub[t]</tt> is assigned the lower bound <tt class="tt">bl[t]</tt>.</dd>
<dt><tt class="tt">bu</tt> (input)</dt>
<dd>Constraint or variable index <tt class="tt">sub[t]</tt> is assigned the upper bound <tt class="tt">bu[t]</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Changes the bounds for either some constraints or variables. If multiple bound changes are specified for a constraint or a variable, only the last change takes effect.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putbound"><tt class="tt">MSK_putbound</tt></a></dt>
<dd>
<p> Changes the bound for either one constraint or one variable.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-inf"><tt class="tt">MSK_DPAR_DATA_TOL_BOUND_INF</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-wrn"><tt class="tt">MSK_DPAR_DATA_TOL_BOUND_WRN</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putboundslice</tt></span>

<p> <a name="func*mosek*task*putboundslice">&#09;</a><a name="common-func*mosek*task*putboundslice"></a> <a name="idx-136245120">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putboundslice (
    MSKtask_t task,
    MSKaccmodee con,
    MSKidxt first,
    MSKidxt last,
    MSKCONST MSKboundkeye * bk,
    MSKCONST MSKrealt * bl,
    MSKCONST MSKrealt * bu);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">con</tt></a> (input)</dt>
<dd>Defines whether bounds for constraints (<a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a>) or variables (<a href="node020.html#common-const*mosek*accmode*var"><tt class="tt">MSK_ACC_VAR</tt></a>) are changed.</dd>
<dt><tt class="tt">first</tt> (input)</dt>
<dd>First index in the sequence.</dd>
<dt><tt class="tt">last</tt> (input)</dt>
<dd>Last index plus 1 in the sequence.</dd>
<dt><a href="node020.html#common-constclass*mosek*boundkey"><tt class="tt">bk</tt></a> (input)</dt>
<dd>Bound keys.</dd>
<dt><tt class="tt">bl</tt> (input)</dt>
<dd>Values for lower bounds.</dd>
<dt><tt class="tt">bu</tt> (input)</dt>
<dd>Values for upper bounds.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Changes the bounds for a sequence of variables or constraints.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putbound"><tt class="tt">MSK_putbound</tt></a></dt>
<dd>
<p> Changes the bound for either one constraint or one variable.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-inf"><tt class="tt">MSK_DPAR_DATA_TOL_BOUND_INF</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*dparam*data-tol-bound-wrn"><tt class="tt">MSK_DPAR_DATA_TOL_BOUND_WRN</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putcallbackfunc</tt></span>

<p> <a name="func*mosek*task*putcallbackfunc">&#09;</a><a name="common-func*mosek*task*putcallbackfunc"></a> <a name="idx-136280472">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putcallbackfunc (
    MSKtask_t task,
    MSKcallbackfunc func,
    MSKuserhandle_t handle);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">func</tt> (input)</dt>
<dd>A user-defined function which will be called occasionally from within the MOSEK optimizers. If the argument is a <tt class="tt">NULL</tt> pointer, then a previous inputted call-back function removed. The progress function has the type <a href="node017.html#common-typedef*mosek*callbackfunc"><tt class="tt">MSK_callbackfunc</tt></a>.</dd>
<dt><tt class="tt">handle</tt> (input)</dt>
<dd>A pointer to a user-defined data structure. Whenever the function <tt class="tt">callbackfunc</tt> is called, then <tt class="tt">handle</tt> is passed to the function.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The function is used to input a user-defined progress call-back function of type <a href="node017.html#common-typedef*mosek*callbackfunc"><tt class="tt">MSK_callbackfunc</tt></a>. The call-back function is called frequently during the optimization process.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node018.html#common-const*mosek*iparam*log-sim-freq"><tt class="tt">MSK_IPAR_LOG_SIM_FREQ</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putcfix</tt></span>

<p> <a name="func*mosek*task*putcfix">&#09;</a><a name="common-func*mosek*task*putcfix"></a> <a name="idx-136301600">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putcfix (
    MSKtask_t task,
    MSKrealt cfix);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">cfix</tt> (input)</dt>
<dd>Fixed term in the objective.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Replaces the fixed term in the objective by a new one.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putcj</tt></span>

<p> <a name="func*mosek*task*putcj">&#09;</a><a name="common-func*mosek*task*putcj"></a> <a name="idx-136299152">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putcj (
    MSKtask_t task,
    MSKidxt j,
    MSKrealt cj);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable for which <span class="math"><span class="mi">c</span></span> should be changed.</dd>
<dt><tt class="tt">cj</tt> (input)</dt>
<dd>New value of <span class="math"><img src="math/math92.png" alt="[[MathCmd 92]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Modifies one coefficient in the linear objective vector <span class="math"><span class="mi">c</span></span>, i.e. </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1003.png" alt="\begin{displaymath}\nonumber{}c_{{\mathtt{j}}}=\mathtt{cj}.\end{displaymath}"/></td></tr>
</tbody>
</table>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putclist</tt></span>

<p> <a name="func*mosek*task*putclist">&#09;</a><a name="common-func*mosek*task*putclist"></a> <a name="idx-136322368">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putclist (
    MSKtask_t task,
    MSKintt num,
    MSKCONST MSKidxt * subj,
    MSKCONST MSKrealt * val);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of coefficients that should be changed.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>Index of variables for which <span class="math"><span class="mi">c</span></span> should be changed.</dd>
<dt><tt class="tt">val</tt> (input)</dt>
<dd>New numerical values for coefficients in <span class="math"><span class="mi">c</span></span> that should be modified.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Modifies elements in the linear term <span class="math"><span class="mi">c</span></span> in the objective using the principle </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1004.png" alt="\begin{displaymath}\nonumber{}c_{{\mathtt{subj[t]}}}=\mathtt{val[t]},\quad{}t=0,\ldots ,\mathtt{num}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> If a variable index is specified multiple times in <tt class="tt">subj</tt> only the last entry is used.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putcone</tt></span>

<p> <a name="func*mosek*task*putcone">&#09;</a><a name="common-func*mosek*task*putcone"></a> <a name="idx-136337600">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putcone (
    MSKtask_t task,
    MSKidxt k,
    MSKconetypee conetype,
    MSKrealt conepar,
    MSKintt nummem,
    MSKCONST MSKidxt * submem);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the cone.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (input)</dt>
<dd>Specifies the type of the cone.</dd>
<dt><tt class="tt">conepar</tt> (input)</dt>
<dd>This argument is currently not used. Can be set to 0.0.</dd>
<dt><tt class="tt">nummem</tt> (input)</dt>
<dd>Number of member variables in the cone.</dd>
<dt><tt class="tt">submem</tt> (input)</dt>
<dd>Variable subscripts of the members in the cone.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Replaces a conic constraint.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putdouparam</tt></span>

<p> <a name="func*mosek*task*putdouparam">&#09;</a><a name="common-func*mosek*task*putdouparam"></a> <a name="idx-136335944">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putdouparam (
    MSKtask_t task,
    MSKdparame param,
    MSKrealt parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node018.html#common-constclass*mosek*dparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a double parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putintparam</tt></span>

<p> <a name="func*mosek*task*putintparam">&#09;</a><a name="common-func*mosek*task*putintparam"></a> <a name="idx-136367856">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putintparam (
    MSKtask_t task,
    MSKiparame param,
    MSKintt parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node018.html#common-constclass*mosek*iparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of an integer parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putmaxnumanz</tt></span>

<p> <a name="func*mosek*task*putmaxnumanz">&#09;</a><a name="common-func*mosek*task*putmaxnumanz"></a> <a name="idx-136341480">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putmaxnumanz (
    MSKtask_t task,
    MSKintt maxnumanz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumanz</tt> (input)</dt>
<dd>New size of the storage reserved for storing <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>MOSEK stores only the non-zero elements in <span class="math"><span class="mi">A</span></span>. Therefore, MOSEK cannot predict how much storage is required to store <span class="math"><span class="mi">A</span></span>. Using this function it is possible to specify the number of non-zeros to preallocate for storing <span class="math"><span class="mi">A</span></span>.</p>

<p>If the number of non-zeros in the problem is known, it is a good idea to set <tt class="tt">maxnumanz</tt> slightly larger than this number, otherwise a rough estimate can be used. In general, if <span class="math"><span class="mi">A</span></span> is inputted in many small chunks, setting this value may speed up the the data input phase.</p>

<p>It is not mandatory to call this function, since MOSEK will reallocate internal structures whenever it is necessary.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node020.html#common-const*mosek*iinfitem*sto-num-a-realloc"><tt class="tt">MSK_IINF_STO_NUM_A_REALLOC</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putmaxnumanz64</tt></span>

<p> <a name="func*mosek*task*putmaxnumanz64">&#09;</a><a name="common-func*mosek*task*putmaxnumanz64"></a> <a name="idx-136389984">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putmaxnumanz64 (
    MSKtask_t task,
    MSKint64t maxnumanz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumanz</tt> (input)</dt>
<dd>New size of the storage reserved for storing <span class="math"><span class="mi">A</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The function changes the size of the preallocated storage for linear coefficients.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node020.html#common-const*mosek*iinfitem*sto-num-a-realloc"><tt class="tt">MSK_IINF_STO_NUM_A_REALLOC</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putmaxnumcon</tt></span>

<p> <a name="func*mosek*task*putmaxnumcon">&#09;</a><a name="common-func*mosek*task*putmaxnumcon"></a> <a name="idx-137817552">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putmaxnumcon (
    MSKtask_t task,
    MSKintt maxnumcon);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>Number of preallocated constraints in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the number of preallocated constraints in the optimization task. When this number of constraints is reached MOSEK will automatically allocate more space for constraints.</p>

<p>It is never mandatory to call this function, since MOSEK will reallocate any internal structures whenever it is required.</p>

<p>Please note that <tt class="tt">maxnumcon</tt> must be larger than the current number of constraints in the task.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putmaxnumcone</tt></span>

<p> <a name="func*mosek*task*putmaxnumcone">&#09;</a><a name="common-func*mosek*task*putmaxnumcone"></a> <a name="idx-137811224">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putmaxnumcone (
    MSKtask_t task,
    MSKintt maxnumcone);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumcone</tt> (input)</dt>
<dd>Number of preallocated conic constraints in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the number of preallocated conic constraints in the optimization task. When this number of conic constraints is reached MOSEK will automatically allocate more space for conic constraints.</p>

<p>It is never mandatory to call this function, since MOSEK will reallocate any internal structures whenever it is required.</p>

<p>Please note that <tt class="tt">maxnumcon</tt> must be larger than the current number of constraints in the task.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putmaxnumqnz</tt></span>

<p> <a name="func*mosek*task*putmaxnumqnz">&#09;</a><a name="common-func*mosek*task*putmaxnumqnz"></a> <a name="idx-137840256">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putmaxnumqnz (
    MSKtask_t task,
    MSKintt maxnumqnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumqnz</tt> (input)</dt>
<dd>Number of non-zero elements preallocated in quadratic coefficient matrices.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>MOSEK stores only the non-zero elements in <span class="math"><span class="mi">Q</span></span>. Therefore, MOSEK cannot predict how much storage is required to store <span class="math"><span class="mi">Q</span></span>. Using this function it is possible to specify the number non-zeros to preallocate for storing <span class="math"><span class="mi">Q</span></span> (both objective and constraints).</p>

<p>It may be advantageous to reserve more non-zeros for <span class="math"><span class="mi">Q</span></span> than actually needed since it may improve the internal efficiency of MOSEK, however, it is never worthwhile to specify more than the double of the anticipated number of non-zeros in <span class="math"><span class="mi">Q</span></span>.</p>

<p>It is never mandatory to call this function, since its only function is to give a hint of the amount of data to preallocate for efficiency reasons.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putmaxnumqnz64</tt></span>

<p> <a name="func*mosek*task*putmaxnumqnz64">&#09;</a><a name="common-func*mosek*task*putmaxnumqnz64"></a> <a name="idx-136373384">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putmaxnumqnz64 (
    MSKtask_t task,
    MSKint64t maxnumqnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumqnz</tt> (input)</dt>
<dd>Number of non-zero elements preallocated in quadratic coefficient matrices.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>MOSEK stores only the non-zero elements in <span class="math"><span class="mi">Q</span></span>. Therefore, MOSEK cannot predict how much storage is required to store <span class="math"><span class="mi">Q</span></span>. Using this function it is possible to specify the number non-zeros to preallocate for storing <span class="math"><span class="mi">Q</span></span> (both objective and constraints).</p>

<p>It may be advantageous to reserve more non-zeros for <span class="math"><span class="mi">Q</span></span> than actually needed since it may improve the internal efficiency of MOSEK, however, it is never worthwhile to specify more than the double of the anticipated number of non-zeros in <span class="math"><span class="mi">Q</span></span>.</p>

<p>It is never mandatory to call this function, since its only function is to give a hint of the amount of data to preallocate for efficiency reasons.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putmaxnumvar</tt></span>

<p> <a name="func*mosek*task*putmaxnumvar">&#09;</a><a name="common-func*mosek*task*putmaxnumvar"></a> <a name="idx-137865408">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putmaxnumvar (
    MSKtask_t task,
    MSKintt maxnumvar);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>Number of preallocated variables in the optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the number of preallocated variables in the optimization task. When this number of variables is reached MOSEK will automatically allocate more space for variables.</p>

<p>It is never mandatory to call this function, since its only function is to give a hint of the amount of data to preallocate for efficiency reasons.</p>

<p>Please note that <tt class="tt">maxnumvar</tt> must be larger than the current number of variables in the task.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putnadouparam</tt></span>

<p> <a name="func*mosek*task*putnadouparam">&#09;</a><a name="common-func*mosek*task*putnadouparam"></a> <a name="idx-137840760">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putnadouparam (
    MSKtask_t task,
    MSKCONST char * paramname,
    MSKrealt parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a named double parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putnaintparam</tt></span>

<p> <a name="func*mosek*task*putnaintparam">&#09;</a><a name="common-func*mosek*task*putnaintparam"></a> <a name="idx-137887184">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putnaintparam (
    MSKtask_t task,
    MSKCONST char * paramname,
    MSKintt parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a named integer parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putname</tt></span>

<p> <a name="func*mosek*task*putname">&#09;</a><a name="common-func*mosek*task*putname"></a> <a name="idx-137881144">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putname (
    MSKtask_t task,
    MSKproblemiteme whichitem,
    MSKidxt i,
    MSKCONST char * name);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*problemitem"><tt class="tt">whichitem</tt></a> (input)</dt>
<dd>Problem item, i.e. a cone, a variable or a constraint name..</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index.</dd>
<dt><tt class="tt">name</tt> (input)</dt>
<dd>New name to be assigned to the item.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Assigns the name defined by <tt class="tt">name</tt> to a problem item (a variable, a constraint or a cone).</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putnastrparam</tt></span>

<p> <a name="func*mosek*task*putnastrparam">&#09;</a><a name="common-func*mosek*task*putnastrparam"></a> <a name="idx-137923400">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putnastrparam (
    MSKtask_t task,
    MSKCONST char * paramname,
    MSKCONST char * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">paramname</tt> (input)</dt>
<dd>Name of a parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a named string parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putnlfunc</tt></span>

<p> <a name="func*mosek*task*putnlfunc">&#09;</a><a name="common-func*mosek*task*putnlfunc"></a> <a name="idx-137894368">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putnlfunc (
    MSKtask_t task,
    MSKuserhandle_t nlhandle,
    MSKnlgetspfunc nlgetsp,
    MSKnlgetvafunc nlgetva);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">nlhandle</tt> (input)</dt>
<dd>A pointer to a user-defined data structure. It is passed to the functions <tt class="tt">nlgetsp</tt> and <tt class="tt">nlgetva</tt> whenever those two functions called.</dd>
<dt><tt class="tt">nlgetsp</tt> (input)</dt>
<dd>A user-defined function which provide information about the structure of the nonlinear functions in the optimization problem.</dd>
<dt><tt class="tt">nlgetva</tt> (input)</dt>
<dd>A user-defined function which is used to evaluate the nonlinear function in the optimization problem at a given point.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>This function is used to communicate the nonlinear function information to MOSEK.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putobjname</tt></span>

<p> <a name="func*mosek*task*putobjname">&#09;</a><a name="common-func*mosek*task*putobjname"></a> <a name="idx-137944888">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putobjname (
    MSKtask_t task,
    MSKCONST char * objname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">objname</tt> (input)</dt>
<dd>Name of the objective.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Assigns the name given by <tt class="tt">objname</tt> to the objective function.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putobjsense</tt></span>

<p> <a name="func*mosek*task*putobjsense">&#09;</a><a name="common-func*mosek*task*putobjsense"></a> <a name="idx-137949128">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putobjsense (
    MSKtask_t task,
    MSKobjsensee sense);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*objsense"><tt class="tt">sense</tt></a> (input)</dt>
<dd>The objective sense of the task. The values <a href="node020.html#common-const*mosek*objsense*maximize"><tt class="tt">MSK_OBJECTIVE_SENSE_MAXIMIZE</tt></a> and <a href="node020.html#common-const*mosek*objsense*minimize"><tt class="tt">MSK_OBJECTIVE_SENSE_MINIMIZE</tt></a> means that the the problem is maximized or minimized respectively. The value <a href="node020.html#common-const*mosek*objsense*undefined"><tt class="tt">MSK_OBJECTIVE_SENSE_UNDEFINED</tt></a> means that the objective sense is taken from the parameter <a href="node018.html#common-const*mosek*iparam*objective-sense"><tt class="tt">MSK_IPAR_OBJECTIVE_SENSE</tt></a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the objective sense of the task.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*getobjsense"><tt class="tt">MSK_getobjsense</tt></a></dt>
<dd>
<p> Gets the objective sense.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putparam</tt></span>

<p> <a name="func*mosek*task*putparam">&#09;</a><a name="common-func*mosek*task*putparam"></a> <a name="idx-137975352">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putparam (
    MSKtask_t task,
    MSKCONST char * parname,
    MSKCONST char * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">parname</tt> (input)</dt>
<dd>Parameter name.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks if a <tt class="tt">parname</tt> is valid parameter name. If it is, the parameter is assigned the value specified by <tt class="tt">parvalue</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putqcon</tt></span>

<p> <a name="func*mosek*task*putqcon">&#09;</a><a name="common-func*mosek*task*putqcon"></a> <a name="idx-137983904">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putqcon (
    MSKtask_t task,
    MSKintt numqcnz,
    MSKCONST MSKidxt * qcsubk,
    MSKCONST MSKidxt * qcsubi,
    MSKCONST MSKidxt * qcsubj,
    MSKCONST MSKrealt * qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numqcnz</tt> (input)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubk</tt> (input)</dt>
<dd><span class="math"><span class="mi">k</span></span> subscripts for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubi</tt> (input)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (input)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (input)</dt>
<dd>Numerical value for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all quadratic entries in the constraints. Consider constraints on the form:  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1009.png" alt="\begin{math}\nonumber{}l_{k}^{c}\leq{}\frac{1}{2}\sum _{{i=0}}^{{\mathtt{numvar}-1}}\sum _{{j=0}}^{{\mathtt{numvar}-1}}q_{{ij}}^{k}x_{i}x_{j}+\sum _{{j=0}}^{{\mathtt{numvar}-1}}a_{{kj}}x_{j}\leq{}u_{k}^{c},~k=0,\ldots ,m-1.\end{math}"/></td>
<td>(15.4.26)</td></tr>
</tbody>
</table>

<p>  The function assigns values to <span class="math"><span class="mi">q</span></span> such that:  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1010.png" alt="\begin{math}\nonumber{}q_{{\mathtt{qcsubi[t]},\mathtt{qcsubj[t]}}}^{{\mathtt{qcsubk[t]}}}=\mathtt{qcval[t]},~t=0,\ldots ,\mathtt{numqcnz}-1.\end{math}"/></td>
<td>(15.4.27)</td></tr>
</tbody>
</table>

<p>  and  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1011.png" alt="\begin{math}\nonumber{}q_{{\mathtt{\mathtt{qcsubj[t]},qcsubi[t]}}}^{{\mathtt{qcsubk[t]}}}=\mathtt{qcval[t]},~t=0,\ldots ,\mathtt{numqcnz}-1.\end{math}"/></td>
<td>(15.4.28)</td></tr>
</tbody>
</table>

<p> Values not assigned are set to zero.</p>

<p>Please note that duplicate entries are added together.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putqconk"><tt class="tt">MSK_putqconk</tt></a></dt>
<dd>
<p> Replaces all quadratic terms in a single constraint.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><tt class="tt">MSK_putmaxnumqnz</tt></a></dt>
<dd>
<p> Changes the size of the preallocated storage for quadratic terms.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putqconk</tt></span>

<p> <a name="func*mosek*task*putqconk">&#09;</a><a name="common-func*mosek*task*putqconk"></a> <a name="idx-137970536">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putqconk (
    MSKtask_t task,
    MSKidxt k,
    MSKintt numqcnz,
    MSKCONST MSKidxt * qcsubi,
    MSKCONST MSKintt * qcsubj,
    MSKCONST MSKrealt * qcval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>The constraint in which the new <span class="math"><span class="mi">Q</span></span> elements are inserted.</dd>
<dt><tt class="tt">numqcnz</tt> (input)</dt>
<dd>Number of quadratic terms. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubi</tt> (input)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscripts for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcsubj</tt> (input)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscripts for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>. See (<a href="node007.html#EQ:QCDEF">5.8.4</a>).</dd>
<dt><tt class="tt">qcval</tt> (input)</dt>
<dd>Numerical value for <span class="math"><img src="math/math94.png" alt="[[MathCmd 94]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all the quadratic entries in one constraint <span class="math"><span class="mi">k</span></span> of the form: </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1015.png" alt="\begin{math}\nonumber{}l_{k}^{c}\leq{}\frac{1}{2}\sum _{{i=0}}^{{\mathtt{numvar}-1}}\sum _{{j=0}}^{{\mathtt{numvar}-1}}q_{{ij}}^{k}x_{i}x_{j}+\sum _{{j=0}}^{{\mathtt{numvar}-1}}a_{{kj}}x_{j}\leq{}u_{k}^{c}.\end{math}"/></td>
<td>(15.4.29)</td></tr>
</tbody>
</table>

<p>  It is assumed that <span class="math"><img src="math/math37.png" alt="[[MathCmd 37]]"/></span> is symmetric, i.e. <span class="math"><img src="math/math1017.png" alt="[[MathCmd 1017]]"/></span>, and therefore, only the values of <span class="math"><img src="math/math1018.png" alt="[[MathCmd 1018]]"/></span> for which <span class="math"><span class="mi">i</span>&ge;<span class="mi">j</span></span> should be inputted to MOSEK. To be precise, MOSEK uses the following procedure  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1019.png" alt="\begin{displaymath}\nonumber{}\begin{array}{ll}\nonumber{}1. & Q^{{k}}=0\\\nonumber{}2. & \mbox{for }t=0\mbox{ to }\mathtt{numqonz}-1\\\nonumber{}3. & \qquad{}q_{{\mathtt{qcsubi[t]},\mathtt{qcsubj[t]}}}^{{k}}=q_{{\mathtt{qcsubi[t]},\mathtt{qcsubj[t]}}}^{{k}}+\mathtt{qcval[t]}\\\nonumber{}3. & \qquad{}q_{{\mathtt{qcsubj[t]},\mathtt{qcsubi[t]}}}^{{k}}=q_{{\mathtt{qcsubj[t]},\mathtt{qcsubi[t]}}}^{{k}}+\mathtt{qcval[t]}\end{array}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>Please note that:  </p>

<ul class="itemize">
<li>For large problems it is essential for the efficiency that the function <a href="node017.html#common-func*mosek*task*putmaxnumqnz64"><tt class="tt">MSK_putmaxnumqnz64</tt></a> is employed to specify an appropriate <tt class="tt">maxnumqnz</tt>.</li>
<li>Only the lower triangular part should be specified because <span class="math"><img src="math/math37.png" alt="[[MathCmd 37]]"/></span> is symmetric. Specifying values for <span class="math"><img src="math/math1018.png" alt="[[MathCmd 1018]]"/></span> where <span class="math"><span class="mi">i</span><span class="mo">&lt;</span><span class="mi">j</span></span> will result in an error.</li>
<li>Only non-zero elements should be specified.</li>
<li>The order in which the non-zero elements are specified is insignificant. </li>
<li>Duplicate elements are added together. Hence, it is recommended not to specify the same element multiple times in <tt class="tt">qosubi</tt>, <tt class="tt">qosubj</tt>, and <tt class="tt">qoval</tt>.</li>
</ul>

<p> For a code example see Section <a title="5.3.2. Example: Quadratic constraints" href="node007.html#chap:mosekapi:sec:quadratic_constraint">5.3.2</a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putqcon"><tt class="tt">MSK_putqcon</tt></a></dt>
<dd>
<p> Replaces all quadratic terms in constraints.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><tt class="tt">MSK_putmaxnumqnz</tt></a></dt>
<dd>
<p> Changes the size of the preallocated storage for quadratic terms.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putqobj</tt></span>

<p> <a name="func*mosek*task*putqobj">&#09;</a><a name="common-func*mosek*task*putqobj"></a> <a name="idx-139617200">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putqobj (
    MSKtask_t task,
    MSKintt numqonz,
    MSKCONST MSKidxt * qosubi,
    MSKCONST MSKidxt * qosubj,
    MSKCONST MSKrealt * qoval);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">numqonz</tt> (input)</dt>
<dd>Number of non-zero elements in <span class="math"><img src="math/math36.png" alt="[[MathCmd 36]]"/></span>.</dd>
<dt><tt class="tt">qosubi</tt> (input)</dt>
<dd><span class="math"><span class="mi">i</span></span> subscript for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
<dt><tt class="tt">qosubj</tt> (input)</dt>
<dd><span class="math"><span class="mi">j</span></span> subscript for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
<dt><tt class="tt">qoval</tt> (input)</dt>
<dd>Numerical value for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces all the quadratic terms in the objective  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1026.png" alt="\begin{math}\nonumber{}\frac{1}{2}\sum \limits _{{i=0}}^{{\mathtt{numvar}-1}}\sum _{{j=0}}^{{\mathtt{numvar}-1}}q_{{ij}}^{o}x_{i}x_{j}+\sum _{{j=0}}^{{\mathtt{numvar}-1}}c_{j}x_{j}+c^{f}.\end{math}"/></td>
<td>(15.4.30)</td></tr>
</tbody>
</table>

<p>  It is assumed that <span class="math"><img src="math/math36.png" alt="[[MathCmd 36]]"/></span> is symmetric, i.e. <span class="math"><img src="math/math1028.png" alt="[[MathCmd 1028]]"/></span>, and therefore, only the values of <span class="math"><img src="math/math1029.png" alt="[[MathCmd 1029]]"/></span> for which <span class="math"><span class="mi">i</span>&ge;<span class="mi">j</span></span> should be specified. To be precise, MOSEK uses the following procedure  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1030.png" alt="\begin{displaymath}\nonumber{}\begin{array}{ll}\nonumber{}1. & Q^{o}=0\\\nonumber{}2. & \mbox{for }t=0\mbox{ to }\mathtt{numqonz}-1\\\nonumber{}3. & \qquad{}q_{{\mathtt{qosubi[t]},\mathtt{qosubj[t]}}}^{{o}}=q_{{\mathtt{qosubi[t]},\mathtt{qosubj[t]}}}^{{o}}+\mathtt{qoval[t]}\\\nonumber{}3. & \qquad{}q_{{\mathtt{qosubj[t]},\mathtt{qosubi[t]}}}^{{o}}=q_{{\mathtt{qosubj[t]},\mathtt{qosubi[t]}}}^{{o}}+\mathtt{qoval[t]}\end{array}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> Please note that:  </p>

<ul class="itemize">
<li>Only the lower triangular part should be specified because <span class="math"><img src="math/math36.png" alt="[[MathCmd 36]]"/></span> is symmetric. Specifying values for <span class="math"><img src="math/math1029.png" alt="[[MathCmd 1029]]"/></span> where <span class="math"><span class="mi">i</span><span class="mo">&lt;</span><span class="mi">j</span></span> will result in an error.</li>
<li>Only non-zero elements should be specified.</li>
<li>The order in which the non-zero elements are specified is insignificant.</li>
<li>Duplicate entries are added to together. </li>
</ul>

<p> For a code example see Section <a title="5.3.1. Example: Quadratic objective" href="node007.html#chap:mosekapi:sec:quadratic_objective">5.3.1</a>.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putqobjij</tt></span>

<p> <a name="func*mosek*task*putqobjij">&#09;</a><a name="common-func*mosek*task*putqobjij"></a> <a name="idx-139654352">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putqobjij (
    MSKtask_t task,
    MSKidxt i,
    MSKidxt j,
    MSKrealt qoij);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Row index for the coefficient to be replaced.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Column index for the coefficient to be replaced.</dd>
<dt><tt class="tt">qoij</tt> (input)</dt>
<dd>The new value for <span class="math"><img src="math/math88.png" alt="[[MathCmd 88]]"/></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Replaces one coefficient in the quadratic term in the objective. The function performs the assignment  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1034.png" alt="\begin{displaymath}\nonumber{}q_{{\mathtt{i}\mathtt{j}}}^{o}=\mathtt{qoij}.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Only the elements in the lower triangular part are accepted. Setting <span class="math"><img src="math/math1035.png" alt="[[MathCmd 1035]]"/></span> with <span class="math"><span class="mi">j</span><span class="mo">&gt;</span><span class="mi">i</span></span> will cause an error.</p>

<p>Please note that replacing all quadratic element, one at a time, is more computationally expensive than replacing all elements at once. Use <a href="node017.html#common-func*mosek*task*putqobj"><tt class="tt">MSK_putqobj</tt></a> instead whenever possible.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putresponsefunc</tt></span>

<p> <a name="func*mosek*task*putresponsefunc">&#09;</a><a name="common-func*mosek*task*putresponsefunc"></a> <a name="idx-139677568">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putresponsefunc (
    MSKtask_t task,
    MSKresponsefunc responsefunc,
    MSKuserhandle_t handle);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">responsefunc</tt> (input)</dt>
<dd>A user-defined response handling function.</dd>
<dt><tt class="tt">handle</tt> (input)</dt>
<dd>A user-defined data structure that is passed to the function <tt class="tt">responsefunc</tt> whenever it is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Inputs a user-defined error call-back which is called when an error or warning occurs.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putsolution</tt></span>

<p> <a name="func*mosek*task*putsolution">&#09;</a><a name="common-func*mosek*task*putsolution"></a> <a name="idx-139687984">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putsolution (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKCONST MSKstakeye * skc,
    MSKCONST MSKstakeye * skx,
    MSKCONST MSKstakeye * skn,
    MSKCONST MSKrealt * xc,
    MSKCONST MSKrealt * xx,
    MSKCONST MSKrealt * y,
    MSKCONST MSKrealt * slc,
    MSKCONST MSKrealt * suc,
    MSKCONST MSKrealt * slx,
    MSKCONST MSKrealt * sux,
    MSKCONST MSKrealt * snx);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skc</tt></a> (input)</dt>
<dd>Status keys for the constraints.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skx</tt></a> (input)</dt>
<dd>Status keys for the variables.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">skn</tt></a> (input)</dt>
<dd>Status keys for the conic constraints.</dd>
<dt><tt class="tt">xc</tt> (input)</dt>
<dd>Primal constraint solution.</dd>
<dt><tt class="tt">xx</tt> (input)</dt>
<dd>Primal variable solution (<span class="math"><span class="mi">x</span></span>).</dd>
<dt><tt class="tt">y</tt> (input)</dt>
<dd>Vector of dual variables corresponding to the constraints.</dd>
<dt><tt class="tt">slc</tt> (input)</dt>
<dd>Dual variables corresponding to the lower bounds on the constraints (<span class="math"><img src="math/math936.png" alt="[[MathCmd 936]]"/></span>).</dd>
<dt><tt class="tt">suc</tt> (input)</dt>
<dd>Dual variables corresponding to the upper bounds on the constraints (<span class="math"><img src="math/math937.png" alt="[[MathCmd 937]]"/></span>).</dd>
<dt><tt class="tt">slx</tt> (input)</dt>
<dd>Dual variables corresponding to the lower bounds on the variables (<span class="math"><img src="math/math938.png" alt="[[MathCmd 938]]"/></span>).</dd>
<dt><tt class="tt">sux</tt> (input)</dt>
<dd>Dual variables corresponding to the upper bounds on the variables (appears as <span class="math"><img src="math/math939.png" alt="[[MathCmd 939]]"/></span>).</dd>
<dt><tt class="tt">snx</tt> (input)</dt>
<dd>Dual variables corresponding to the conic constraints on the variables (<span class="math"><img src="math/math940.png" alt="[[MathCmd 940]]"/></span>).</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Inserts a solution into the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putsolutioni</tt></span>

<p> <a name="func*mosek*task*putsolutioni">&#09;</a><a name="common-func*mosek*task*putsolutioni"></a> <a name="idx-139729448">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putsolutioni (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKidxt i,
    MSKsoltypee whichsol,
    MSKstakeye sk,
    MSKrealt x,
    MSKrealt sl,
    MSKrealt su,
    MSKrealt sn);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>If set to <a href="node020.html#common-const*mosek*accmode*con"><tt class="tt">MSK_ACC_CON</tt></a> the solution information for a constraint is modified. Otherwise for a variable.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the constraint or variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><a href="node020.html#common-constclass*mosek*stakey"><tt class="tt">sk</tt></a> (input)</dt>
<dd>Status key of the constraint or variable.</dd>
<dt><tt class="tt">x</tt> (input)</dt>
<dd>Solution value of the primal constraint or variable.</dd>
<dt><tt class="tt">sl</tt> (input)</dt>
<dd>Solution value of the dual variable associated with the lower bound.</dd>
<dt><tt class="tt">su</tt> (input)</dt>
<dd>Solution value of the dual variable associated with the upper bound.</dd>
<dt><tt class="tt">sn</tt> (input)</dt>
<dd>Solution value of the dual variable associated with the cone constraint.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the primal and dual solution information for a single constraint or variable.</p>

<p>To define a solution or a significant part of a solution, first call the <a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><tt class="tt">MSK_makesolutionstatusunknown</tt></a> function, then for each relevant constraint and variable call <a href="node017.html#common-func*mosek*task*putsolutioni"><tt class="tt">MSK_putsolutioni</tt></a> to set the solution information.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><tt class="tt">MSK_makesolutionstatusunknown</tt></a></dt>
<dd>
<p> Sets the solution status to unknown.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putsolutionyi</tt></span>

<p> <a name="func*mosek*task*putsolutionyi">&#09;</a><a name="common-func*mosek*task*putsolutionyi"></a> <a name="idx-139754384">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putsolutionyi (
    MSKtask_t task,
    MSKidxt i,
    MSKsoltypee whichsol,
    MSKrealt y);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">i</tt> (input)</dt>
<dd>Index of the dual variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">y</tt> (input)</dt>
<dd>Solution value of the dual variable.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Inputs the dual variable of a solution.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*makesolutionstatusunknown"><tt class="tt">MSK_makesolutionstatusunknown</tt></a></dt>
<dd>
<p> Sets the solution status to unknown.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putsolutioni"><tt class="tt">MSK_putsolutioni</tt></a></dt>
<dd>
<p> Sets the primal and dual solution information for a single constraint or variable.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putstrparam</tt></span>

<p> <a name="func*mosek*task*putstrparam">&#09;</a><a name="common-func*mosek*task*putstrparam"></a> <a name="idx-139744104">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putstrparam (
    MSKtask_t task,
    MSKsparame param,
    MSKCONST char * parvalue);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node018.html#common-constclass*mosek*sparam"><tt class="tt">param</tt></a> (input)</dt>
<dd>Which parameter.</dd>
<dt><tt class="tt">parvalue</tt> (input)</dt>
<dd>Parameter value.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the value of a string parameter.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_puttaskname</tt></span>

<p> <a name="func*mosek*task*puttaskname">&#09;</a><a name="common-func*mosek*task*puttaskname"></a> <a name="idx-139788088">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_puttaskname (
    MSKtask_t task,
    MSKCONST char * taskname);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">taskname</tt> (input)</dt>
<dd>Name assigned to the task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Assigns the name <tt class="tt">taskname</tt> to the task.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putvarbranchorder</tt></span>

<p> <a name="func*mosek*task*putvarbranchorder">&#09;</a><a name="common-func*mosek*task*putvarbranchorder"></a> <a name="idx-139758264">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putvarbranchorder (
    MSKtask_t task,
    MSKidxt j,
    MSKintt priority,
    int direction);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><tt class="tt">priority</tt> (input)</dt>
<dd>The branching priority that should be assigned to variable <span class="math"><span class="mi">j</span></span>.</dd>
<dt><a href="node020.html#common-constclass*mosek*branchdir"><tt class="tt">direction</tt></a> (input)</dt>
<dd>Specifies the preferred branching direction for variable <span class="math"><span class="mi">j</span></span>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The purpose of the function is to assign a branching priority and direction. The higher priority that is assigned to an integer variable the earlier the mixed integer optimizer will branch on the variable. The branching direction controls if the optimizer branches up or down on the variable.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putvartype</tt></span>

<p> <a name="func*mosek*task*putvartype">&#09;</a><a name="common-func*mosek*task*putvartype"></a> <a name="idx-139810936">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putvartype (
    MSKtask_t task,
    MSKidxt j,
    MSKvariabletypee vartype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">j</tt> (input)</dt>
<dd>Index of the variable.</dd>
<dt><a href="node020.html#common-constclass*mosek*variabletype"><tt class="tt">vartype</tt></a> (input)</dt>
<dd>The new variable type.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Sets the variable type of one variable.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putvartypelist"><tt class="tt">MSK_putvartypelist</tt></a></dt>
<dd>
<p> Sets the variable type for one or more variables.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_putvartypelist</tt></span>

<p> <a name="func*mosek*task*putvartypelist">&#09;</a><a name="common-func*mosek*task*putvartypelist"></a> <a name="idx-139823584">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_putvartypelist (
    MSKtask_t task,
    MSKintt num,
    MSKCONST MSKidxt * subj,
    MSKCONST MSKvariabletypee * vartype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of variables for which the variable type should be set.</dd>
<dt><tt class="tt">subj</tt> (input)</dt>
<dd>A list of variable indexes for which the variable type should be changed.</dd>
<dt><a href="node020.html#common-constclass*mosek*variabletype"><tt class="tt">vartype</tt></a> (input)</dt>
<dd>A list of variable types that should be assigned to the variables specified by <tt class="tt">subj</tt>. See section <a title="18.55. Variable types" href="node020.html#constclass*mosek*variabletype">18.55</a> for the possible values of <tt class="tt">vartype</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the variable type for one or more variables, i.e. variable number <span class="math"><img src="math/math1041.png" alt="[[MathCmd 1041]]"/></span> is assigned the variable type <span class="math"><img src="math/math1042.png" alt="[[MathCmd 1042]]"/></span>.</p>

<p>If the same index is specified multiple times in <tt class="tt">subj</tt> only the last entry takes effect.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putvartype"><tt class="tt">MSK_putvartype</tt></a></dt>
<dd>
<p> Sets the variable type of one variable.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_readbranchpriorities</tt></span>

<p> <a name="func*mosek*task*readbranchpriorities">&#09;</a><a name="common-func*mosek*task*readbranchpriorities"></a> <a name="idx-139845216">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_readbranchpriorities (
    MSKtask_t task,
    MSKCONST char * filename);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Data is read from the file <tt class="tt">filename</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Reads branching priority data from a file.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*writebranchpriorities"><tt class="tt">MSK_writebranchpriorities</tt></a></dt>
<dd>
<p> Writes branching priority data to a file.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_readdata</tt></span>

<p> <a name="func*mosek*task*readdata">&#09;</a><a name="common-func*mosek*task*readdata"></a> <a name="idx-139822432">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_readdata (
    MSKtask_t task,
    MSKCONST char * filename);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Data is read from the file <tt class="tt">filename</tt> if it is a nonempty string. Otherwise data is read from the file specified by <a href="node018.html#common-const*mosek*sparam*data-file-name"><tt class="tt">MSK_SPAR_DATA_FILE_NAME</tt></a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Reads an optimization data and associated data from a file.</p>

<p>The data file format is determined by the <a href="node018.html#common-const*mosek*iparam*read-data-format"><tt class="tt">MSK_IPAR_READ_DATA_FORMAT</tt></a> parameter. By default the parameter has the value <a href="node020.html#common-const*mosek*dataformat*extension"><tt class="tt">MSK_DATA_FORMAT_EXTENSION</tt></a> indicating that the extension of the input file should determine the file type, where the extension is interpreted as follows:</p>

<ul class="itemize">
<li>"<tt class="tt">.lp</tt>" and "<tt class="tt">.lp.gz</tt>" are interpreted as an LP file and a compressed LP file respectively. </li>
<li>"<tt class="tt">.opf</tt>" and "<tt class="tt">.opf.gz</tt>" are interpreted as an OPF file and a compressed OPF file respectively. </li>
<li>"<tt class="tt">.mps</tt>" and "<tt class="tt">.mps.gz</tt>" are interpreted as an MPS file and a compressed MPS file respectively. </li>
<li>"<tt class="tt">.mbt</tt>" and "<tt class="tt">.mbt.gz</tt>" are interpreted as an MBT file and a compressed MBT file respectively. </li>
</ul>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*writedata"><tt class="tt">MSK_writedata</tt></a></dt>
<dd>
<p> Writes problem data to a file.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*read-data-format"><tt class="tt">MSK_IPAR_READ_DATA_FORMAT</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_readparamfile</tt></span>

<p> <a name="func*mosek*task*readparamfile">&#09;</a><a name="common-func*mosek*task*readparamfile"></a> <a name="idx-141309064">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_readparamfile (MSKtask_t task)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Reads a parameter file.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_readsolution</tt></span>

<p> <a name="func*mosek*task*readsolution">&#09;</a><a name="common-func*mosek*task*readsolution"></a> <a name="idx-141300224">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_readsolution (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKCONST char * filename);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>A valid file name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Reads a solution file and inserts the solution into the solution <tt class="tt">whichsol</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_readsummary</tt></span>

<p> <a name="func*mosek*task*readsummary">&#09;</a><a name="common-func*mosek*task*readsummary"></a> <a name="idx-141327536">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_readsummary (
    MSKtask_t task,
    MSKstreamtypee whichstream);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints a short summary of last file that was read.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_relaxprimal</tt></span>

<p> <a name="func*mosek*task*relaxprimal">&#09;</a><a name="common-func*mosek*task*relaxprimal"></a> <a name="idx-141317832">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_relaxprimal (
    MSKtask_t task,
    MSKtask_t * relaxedtask,
    MSKrealt * wlc,
    MSKrealt * wuc,
    MSKrealt * wlx,
    MSKrealt * wux);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">relaxedtask</tt> (output)</dt>
<dd>The returned task.</dd>
<dt><tt class="tt">wlc</tt> (input/output)</dt>
<dd>Weights associated with lower bounds on the activity of constraints. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math1043.png" alt="[[MathCmd 1043]]"/></span>, then <span class="math"><img src="math/math645.png" alt="[[MathCmd 645]]"/></span> is fixed to zero. On return <tt class="tt">wlc[i]</tt> contains the relaxed bound.</dd>
<dt><tt class="tt">wuc</tt> (input/output)</dt>
<dd>Weights associated with upper bounds on the activity of constraints. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math1045.png" alt="[[MathCmd 1045]]"/></span>, then <span class="math"><img src="math/math646.png" alt="[[MathCmd 646]]"/></span> is fixed to zero. On return <tt class="tt">wuc[i]</tt> contains the relaxed bound.</dd>
<dt><tt class="tt">wlx</tt> (input/output)</dt>
<dd>Weights associated with lower bounds on the activity of variables. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math1047.png" alt="[[MathCmd 1047]]"/></span> then <span class="math"><img src="math/math1048.png" alt="[[MathCmd 1048]]"/></span> is fixed to zero. On return <tt class="tt">wlx[i]</tt> contains the relaxed bound.</dd>
<dt><tt class="tt">wux</tt> (input/output)</dt>
<dd>Weights associated with upper bounds on the activity of variables. If negative, the bound is strictly enforced, i.e. if <span class="math"><img src="math/math1049.png" alt="[[MathCmd 1049]]"/></span> then <span class="math"><img src="math/math1050.png" alt="[[MathCmd 1050]]"/></span> is fixed to zero. On return <tt class="tt">wux[i]</tt> contains the relaxed bound.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Creates a problem that computes the minimal (weighted) relaxation of the bounds that will make an infeasible problem feasible.</p>

<p>Given an existing task describing the problem  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1051.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x & \leq{} & u^{x},\end{array}\end{math}"/></td>
<td>(15.4.31)</td></tr>
</tbody>
</table>

<p>  the function forms a new task <tt class="tt">relaxedtask</tt> having the form  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1052.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & p &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax+v_{l}^{c}-v_{u}^{c} & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x+v_{l}^{x}-v_{u}^{x} & \leq{} & u^{x},\\\nonumber{} &  &  & (w_{l}^{c})^{T}v_{l}^{c}+(w_{u}^{c})^{T}v_{u}^{c}+(w_{l}^{x})^{T}v_{l}^{x}+(w_{u}^{x})^{T}v_{u}^{x}-p & \leq{} & 0,\\\nonumber{} &  &  & v_{l}^{c},v_{u}^{c},v_{l}^{x},v_{u}^{x}\geq{}0. &  &\end{array}\end{math}"/></td>
<td><a name="ais-eq-feasrepair1">&#09;</a>(15.4.32)</td></tr>
</tbody>
</table>

<p>  Hence, the function adds so-called elasticity variables to all the constraints which relax the constraints, for instance <span class="math"><img src="math/math645.png" alt="[[MathCmd 645]]"/></span> and <span class="math"><img src="math/math646.png" alt="[[MathCmd 646]]"/></span> relax <span class="math"><img src="math/math650.png" alt="[[MathCmd 650]]"/></span> and <span class="math"><img src="math/math1056.png" alt="[[MathCmd 1056]]"/></span> respectively. It should be obvious that (<a href="node017.html#ais-eq-feasrepair1">15.4.32</a>) is feasible. Moreover, the function adds the constraint  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1057.png" alt="\begin{displaymath}\nonumber{}(w_{l}^{c})^{T}v_{l}^{c}+(w_{u}^{c})^{T}v_{u}^{c}+(w_{l}^{x})^{T}v_{l}^{x}+(w_{u}^{x})^{T}v_{u}^{x}-p\leq{}0\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  to the problem which makes the variable <span class="math"><span class="mi">p</span></span> bigger than the total weighted sum of the relaxation to the bounds. <span class="math"><img src="math/math654.png" alt="[[MathCmd 654]]"/></span>, <span class="math"><img src="math/math655.png" alt="[[MathCmd 655]]"/></span>, <span class="math"><img src="math/math656.png" alt="[[MathCmd 656]]"/></span> and <span class="math"><img src="math/math657.png" alt="[[MathCmd 657]]"/></span> are user-defined weights which normally should be nonnegative. If a weight is negative, then the corresponding elasticity variable is fixed to zero.</p>

<p>Hence, when the problem (<a href="node017.html#ais-eq-feasrepair1">15.4.32</a>) is optimized, the weighted minimal change to the bounds such that the problem is feasible is computed.</p>

<p>One can specify that a bound should be strictly enforced by assigning a negative value to the corresponding weight, i.e if <span class="math"><img src="math/math1043.png" alt="[[MathCmd 1043]]"/></span> then <span class="math"><img src="math/math645.png" alt="[[MathCmd 645]]"/></span> is fixed to zero.</p>

<p>Now let <span class="math"><img src="math/math660.png" alt="[[MathCmd 660]]"/></span> be the optimal objective value to (<a href="node017.html#ais-eq-feasrepair1">15.4.32</a>), then a natural thing to do is to solve the optimization problem  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1065.png" alt="\begin{math}\nonumber{}\begin{array}{lccccl}\nonumber{}\mbox{minimize} &  &  & c^{T}x &  & \\\nonumber{}\mbox{subject to} & l^{c} & \leq{} & Ax+v_{l}^{c}-v_{u}^{c} & \leq{} & u^{c},\\\nonumber{} & l^{x} & \leq{} & x+v_{l}^{x}-v_{u}^{x} & \leq{} & u^{x},\\\nonumber{} &  &  & (w_{l}^{c})^{T}v_{l}^{c}+(w_{u}^{c})^{T}v_{u}^{c}+(w_{l}^{x})^{T}v_{l}^{x}+(w_{u}^{x})^{T}v_{u}^{x}-p & \leq{} & 0,\\\nonumber{} &  &  & p & = & p^{*},\\\nonumber{} &  &  & v_{l}^{c},v_{u}^{c},v_{l}^{x},v_{u}^{x}\geq{}0, &  &\end{array}\end{math}"/></td>
<td><a name="ais-eq-feasrepair2">&#09;</a>(15.4.33)</td></tr>
</tbody>
</table>

<p>  where the original objective function is minimized subject to the constraint that the total weighted relaxation is minimal.</p>

<p>The parameter <a href="node018.html#common-const*mosek*iparam*feasrepair-optimize"><tt class="tt">MSK_IPAR_FEASREPAIR_OPTIMIZE</tt></a> controls whether the function returns the problem (<a href="node017.html#ais-eq-feasrepair1">15.4.32</a>) or the problem (<a href="node017.html#ais-eq-feasrepair2">15.4.33</a>).The parameter can take one of the following values.  </p>

<dl class="description">
<dt><a href="node020.html#common-const*mosek*feasrepairtype*optimize-none"><tt class="tt">MSK_FEASREPAIR_OPTIMIZE_NONE</tt></a></dt>
<dd>
<p>: The returned task <tt class="tt">relaxedtask</tt> contains problem (<a href="node017.html#ais-eq-feasrepair1">15.4.32</a>) and is not optimized.</p>
</dd>
<dt><a href="node020.html#common-const*mosek*feasrepairtype*optimize-penalty"><tt class="tt">MSK_FEASREPAIR_OPTIMIZE_PENALTY</tt></a></dt>
<dd>
<p>: The returned task <tt class="tt">relaxedtask</tt> contains problem (<a href="node017.html#ais-eq-feasrepair1">15.4.32</a>) and is optimized.</p>
</dd>
<dt><a href="node020.html#common-const*mosek*feasrepairtype*optimize-combined"><tt class="tt">MSK_FEASREPAIR_OPTIMIZE_COMBINED</tt></a></dt>
<dd>
<p>: The returned task <tt class="tt">relaxedtask</tt> contains problem (<a href="node017.html#ais-eq-feasrepair2">15.4.33</a>) and is optimized. </p>
</dd>
</dl>

<p>  Please note that the <span class="math"><span class="mi">v</span></span> variables are appended to the <span class="math"><span class="mi">x</span></span> variables ordered as </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1066.png" alt="\begin{displaymath}\nonumber{}(v_{u}^{c})_{1},(v_{l}^{c})_{1},(v_{u}^{c})_{2},(v_{l}^{c})_{2},\ldots ,(v_{u}^{c})_{m},(v_{l}^{c})_{m},\quad{}(v_{u}^{x})_{1},(v_{l}^{x})_{1},(v_{u}^{x})_{2},(v_{l}^{x})_{2},\ldots ,(v_{u}^{x})_{n},(v_{l}^{x})_{n}\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> in the returned task.</p>

<p>If <tt class="tt">NAME_CON</tt> (<tt class="tt">NAME_VAR</tt>) is the name of the <span class="math"><span class="mi">i</span></span>th constraint (variable) then the new variables are named as follows: </p>

<ul class="itemize">
<li>The variable corresponding to <span class="math"><img src="math/math646.png" alt="[[MathCmd 646]]"/></span> (<span class="math"><img src="math/math1068.png" alt="[[MathCmd 1068]]"/></span>) is named &#8220;<tt class="tt">NAME_CON*up</tt>&#8221; (&#8220;<tt class="tt">NAME_VAR*up</tt>&#8221;).</li>
<li>The variable corresponding to <span class="math"><img src="math/math645.png" alt="[[MathCmd 645]]"/></span> (<span class="math"><img src="math/math647.png" alt="[[MathCmd 647]]"/></span>) is named &#8220;<tt class="tt">NAME_CON*lo</tt>&#8221; (&#8220;<tt class="tt">NAME_VAR*lo</tt>&#8221;). </li>
</ul>

<p> where &#8220;<tt class="tt">*</tt>&#8221; can be replaced by a user-defined string by setting the <a href="node018.html#common-const*mosek*sparam*feasrepair-name-separator"><tt class="tt">MSK_SPAR_FEASREPAIR_NAME_SEPARATOR</tt></a> parameter.</p>

<p>Please note that if <span class="math"><img src="math/math1071.png" alt="[[MathCmd 1071]]"/></span> or <span class="math"><img src="math/math1072.png" alt="[[MathCmd 1072]]"/></span> then the feasibility repair problem becomes infeasible. Such trivial conflicts must therefore be removed manually before using <a href="node017.html#common-func*mosek*task*relaxprimal"><tt class="tt">MSK_relaxprimal</tt></a>.</p>

<p>The above discussion shows how the function works for a linear optimization problem. However, the function also works for quadratic and conic optimization problems but it cannot be used for general nonlinear optimization problems.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node018.html#common-const*mosek*dparam*feasrepair-tol"><tt class="tt">MSK_DPAR_FEASREPAIR_TOL</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*feasrepair-optimize"><tt class="tt">MSK_IPAR_FEASREPAIR_OPTIMIZE</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*sparam*feasrepair-name-separator"><tt class="tt">MSK_SPAR_FEASREPAIR_NAME_SEPARATOR</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*sparam*feasrepair-name-prefix"><tt class="tt">MSK_SPAR_FEASREPAIR_NAME_PREFIX</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_remove</tt></span>

<p> <a name="func*mosek*task*remove">&#09;</a><a name="common-func*mosek*task*remove"></a> <a name="idx-141412328">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_remove (
    MSKtask_t task,
    MSKaccmodee accmode,
    MSKintt num,
    MSKCONST MSKintt * sub);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a> (input)</dt>
<dd>Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</dd>
<dt><tt class="tt">num</tt> (input)</dt>
<dd>Number of constraints or variables which should be removed.</dd>
<dt><tt class="tt">sub</tt> (input)</dt>
<dd>Indexes of constraints or variables which should be removed.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>The function removes a number of constraints or variables from the optimization task. This implies that the existing constraints and variables are renumbered, for instance if constraint 5 is removed then constraint 6 becomes constraint 5 and so forth.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*append"><tt class="tt">MSK_append</tt></a></dt>
<dd>
<p> Appends a number of variables or constraints to the optimization task.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_removecone</tt></span>

<p> <a name="func*mosek*task*removecone">&#09;</a><a name="common-func*mosek*task*removecone"></a> <a name="idx-141442512">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_removecone (
    MSKtask_t task,
    MSKidxt k);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">k</tt> (input)</dt>
<dd>Index of the conic constraint that should be removed.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Removes a conic constraint from the problem. This implies that all the conic constraints appearing after cone number <tt class="tt">k</tt> are renumbered, decresing their indexes by one.</p>

<p>In general, it is much more efficient to remove a cone with a high index than a low index.</p>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_resizetask</tt></span>

<p> <a name="func*mosek*task*resizetask">&#09;</a><a name="common-func*mosek*task*resizetask"></a> <a name="idx-141446032">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_resizetask (
    MSKtask_t task,
    MSKintt maxnumcon,
    MSKintt maxnumvar,
    MSKintt maxnumcone,
    MSKintt maxnumanz,
    MSKintt maxnumqnz);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">maxnumcon</tt> (input)</dt>
<dd>New maximum number of constraints.</dd>
<dt><tt class="tt">maxnumvar</tt> (input)</dt>
<dd>New maximum number of variables.</dd>
<dt><tt class="tt">maxnumcone</tt> (input)</dt>
<dd>New maximum number of cones.</dd>
<dt><tt class="tt">maxnumanz</tt> (input)</dt>
<dd>New maximum number of non-zeros in <span class="math"><span class="mi">A</span></span>.</dd>
<dt><tt class="tt">maxnumqnz</tt> (input)</dt>
<dd>New maximum number of non-zeros in all <span class="math"><span class="mi">Q</span></span> matrices.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Sets the amount of preallocated space assigned for each type of data in an optimization task.</p>

<p>It is never mandatory to call this function, since its only function is to give a hint of the amount of data to preallocate for efficiency reasons.</p>

<p>Please note that the procedure is <b>destructive</b> in the sense that all existing data stored in the task is destroyed.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*putmaxnumvar"><tt class="tt">MSK_putmaxnumvar</tt></a></dt>
<dd>
<p> Sets the number of preallocated variables in the optimization task.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumcon"><tt class="tt">MSK_putmaxnumcon</tt></a></dt>
<dd>
<p> Sets the number of preallocated constraints in the optimization task.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumcone"><tt class="tt">MSK_putmaxnumcone</tt></a></dt>
<dd>
<p> Sets the number of preallocated conic constraints in the optimization task.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumanz"><tt class="tt">MSK_putmaxnumanz</tt></a></dt>
<dd>
<p> The function changes the size of the preallocated storage for linear coefficients.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*putmaxnumqnz"><tt class="tt">MSK_putmaxnumqnz</tt></a></dt>
<dd>
<p> Changes the size of the preallocated storage for quadratic terms.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_sensitivityreport</tt></span>

<p> <a name="func*mosek*task*sensitivityreport">&#09;</a><a name="common-func*mosek*task*sensitivityreport"></a> <a name="idx-141487712">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_sensitivityreport (
    MSKtask_t task,
    MSKstreamtypee whichstream);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Reads a sensitivity format file from a location given by <a href="node018.html#common-const*mosek*sparam*sensitivity-file-name"><tt class="tt">MSK_SPAR_SENSITIVITY_FILE_NAME</tt></a> and writes the result to the stream <tt class="tt">whichstream</tt>. If <a href="node018.html#common-const*mosek*sparam*sensitivity-res-file-name"><tt class="tt">MSK_SPAR_SENSITIVITY_RES_FILE_NAME</tt></a> is set to a non-empty string, then the sensitivity report is also written to a file of this name.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*dualsensitivity"><tt class="tt">MSK_dualsensitivity</tt></a></dt>
<dd>
<p> Performs sensitivity analysis on objective coefficients.</p>
</dd>
<dt><a href="node017.html#common-func*mosek*task*primalsensitivity"><tt class="tt">MSK_primalsensitivity</tt></a></dt>
<dd>
<p> Perform sensitivity analysis on bounds.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity"><tt class="tt">MSK_IPAR_LOG_SENSITIVITY</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*log-sensitivity-opt"><tt class="tt">MSK_IPAR_LOG_SENSITIVITY_OPT</tt></a></dt>
<dd></dd>
<dt><a href="node018.html#common-const*mosek*iparam*sensitivity-type"><tt class="tt">MSK_IPAR_SENSITIVITY_TYPE</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_setdefaults</tt></span>

<p> <a name="func*mosek*task*setdefaults">&#09;</a><a name="common-func*mosek*task*setdefaults"></a> <a name="idx-141478584">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_setdefaults (MSKtask_t task)
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Resets all the parameters to their default values.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_sktostr</tt></span>

<p> <a name="func*mosek*task*sktostr">&#09;</a><a name="common-func*mosek*task*sktostr"></a> <a name="idx-143097728">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_sktostr (
    MSKtask_t task,
    MSKintt sk,
    char * str);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">sk</tt> (input)</dt>
<dd>A valid status key.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the status key <tt class="tt">sk</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an explanatory string corresponding to a status key.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_solstatostr</tt></span>

<p> <a name="func*mosek*task*solstatostr">&#09;</a><a name="common-func*mosek*task*solstatostr"></a> <a name="idx-141480880">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_solstatostr (
    MSKtask_t task,
    MSKsolstae solsta,
    char * str);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a> (input)</dt>
<dd>Solution status.</dd>
<dt><tt class="tt">str</tt> (output)</dt>
<dd>String corresponding to the solution status <tt class="tt">solsta</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains an explanatory string corresponding to a solution status.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_solutiondef</tt></span>

<p> <a name="func*mosek*task*solutiondef">&#09;</a><a name="common-func*mosek*task*solutiondef"></a> <a name="idx-143121872">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_solutiondef (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKintt * isdef);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">isdef</tt> (output)</dt>
<dd>Is non-zero if the requested solution is defined.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks whether a solution is defined.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_solutionsummary</tt></span>

<p> <a name="func*mosek*task*solutionsummary">&#09;</a><a name="common-func*mosek*task*solutionsummary"></a> <a name="idx-143097936">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_solutionsummary (
    MSKtask_t task,
    MSKstreamtypee whichstream);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Prints a short summary of the current solutions. Please see Section <a title="8.7. Understanding solution quality" href="node010.html#chap:solving:sec:solqual">8.7</a> for more details.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_solvewithbasis</tt></span>

<p> <a name="func*mosek*task*solvewithbasis">&#09;</a><a name="common-func*mosek*task*solvewithbasis"></a> <a name="idx-143145584">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_solvewithbasis (
    MSKtask_t task,
    MSKintt transp,
    MSKintt * numnz,
    MSKidxt * sub,
    MSKrealt * val);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">transp</tt> (input)</dt>
<dd>If this argument is non-zero, then (<a href="node017.html#ais-eq-Btxb">15.4.35</a>) is solved. Otherwise the system (<a href="node017.html#ais-eq-Bxb">15.4.34</a>) is solved.</dd>
<dt><tt class="tt">numnz</tt> (input/output)</dt>
<dd>As input it is the number of non-zeros in <span class="math"><span class="mi">b</span></span>. As output it is the number of non-zeros in <span class="math"><img src="math/math528.png" alt="[[MathCmd 528]]"/></span>.</dd>
<dt><tt class="tt">sub</tt> (input/output)</dt>
<dd>
<p>As input it contains the positions of the non-zeros in <span class="math"><span class="mi">b</span></span>, i.e.  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1074.png" alt="\begin{displaymath}\nonumber{}b[\mathtt{sub}[k]]\not=0,~k=0,\ldots ,\mathtt{numnz[0]}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p> As output it contains the positions of the non-zeros in <span class="math"><img src="math/math528.png" alt="[[MathCmd 528]]"/></span>. It is important that <tt class="tt">sub</tt> has room for <tt class="tt">numcon</tt> elements.</p>
</dd>
<dt><tt class="tt">val</tt> (input/output)</dt>
<dd>
<p>As input it is the vector <span class="math"><span class="mi">b</span></span>. Although the positions of the non-zero elements are specified in <tt class="tt">sub</tt> it is required that <span class="math"><img src="math/math1076.png" alt="[[MathCmd 1076]]"/></span> if <span class="math"><span class="mi">b</span><span class="mo">[</span><span class="mi">i</span><span class="mo">]</span><span class="mo">=</span><span class="mn">0</span></span>. As output <tt class="tt">val</tt> is the vector <span class="math"><img src="math/math528.png" alt="[[MathCmd 528]]"/></span>.</p>

<p>Please note that <tt class="tt">val</tt> is a dense vector &mdash; not a packed sparse vector. This implies that <tt class="tt">val</tt> has room for <tt class="tt">numcon</tt> elements.</p>
</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>If a basic solution is available, then exactly <span class="math"><img src="math/math23.png" alt="[[MathCmd 23]]"/></span> basis variables are defined. These <span class="math"><img src="math/math23.png" alt="[[MathCmd 23]]"/></span> basis variables are denoted the basis. Associated with the basis is a basis matrix denoted <span class="math"><span class="mi">B</span></span>. This function solves either the linear equation system  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1080.png" alt="\begin{math}\nonumber{}B\bar{x}=b\end{math}"/></td>
<td><a name="ais-eq-Bxb">&#09;</a>(15.4.34)</td></tr>
</tbody>
</table>

<p>  or the system  </p>

<table width="100%" class="equation" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1081.png" alt="\begin{math}\nonumber{}B^{T}\bar{x}=b\end{math}"/></td>
<td><a name="ais-eq-Btxb">&#09;</a>(15.4.35)</td></tr>
</tbody>
</table>

<p>  for the unknowns <span class="math"><img src="math/math528.png" alt="[[MathCmd 528]]"/></span>, with <span class="math"><span class="mi">b</span></span> being a user-defined vector.</p>

<p>In order to make sense of the solution <span class="math"><img src="math/math528.png" alt="[[MathCmd 528]]"/></span> it is important to know the ordering of the variables in the basis because the ordering specifies how <span class="math"><span class="mi">B</span></span> is constructed. When calling <a href="node017.html#common-func*mosek*task*initbasissolve"><tt class="tt">MSK_initbasissolve</tt></a> an ordering of the basis variables is obtained, whicd can be used to deduce how MOSEK has constructed <span class="math"><span class="mi">B</span></span>. Indeed if the <span class="math"><span class="mi">k</span></span>th basis variable is variable <span class="math"><img src="math/math144.png" alt="[[MathCmd 144]]"/></span> it implies that  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1085.png" alt="\begin{displaymath}\nonumber{}B_{{i,k}}=A_{{i,j}},~i=0,\ldots ,\mathtt{numcon}-1.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Otherwise if the <span class="math"><span class="mi">k</span></span>th basis variable is variable <span class="math"><img src="math/math1086.png" alt="[[MathCmd 1086]]"/></span> it implies that`  </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math1087.png" alt="\begin{displaymath}\nonumber{}B_{{i,k}}=\left\lbrace{}\begin{array}{ll}\nonumber{}-1, & i=j,\\\nonumber{}0, & i\not=j.\end{array}\right.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>  Given the knowledge of how <span class="math"><span class="mi">B</span></span> is constructed it is possible to interpret the solution <span class="math"><img src="math/math528.png" alt="[[MathCmd 528]]"/></span> correctly.</p>

<p>Please note that this function exploits the sparsity in the vector <span class="math"><span class="mi">b</span></span> to speed up the computations.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*initbasissolve"><tt class="tt">MSK_initbasissolve</tt></a></dt>
<dd>
<p> Prepare a task for basis solver.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*basis-solve-use-plus-one"><tt class="tt">MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_strdupdbgtask</tt></span>

<p> <a name="func*mosek*task*strdupdbgtask">&#09;</a><a name="common-func*mosek*task*strdupdbgtask"></a> <a name="idx-143180360">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">char * MSK_strdupdbgtask (
    MSKtask_t task,
    MSKCONST char * str,
    MSKCONST char * file,
    MSKCONST unsigned line);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">str</tt> (input)</dt>
<dd>String that should be copied.</dd>
<dt><tt class="tt">file</tt> (input)</dt>
<dd>File from which the function is called.</dd>
<dt><tt class="tt">line</tt> (input)</dt>
<dd>Line in the file from which the function is called.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Make a copy of a string. The string created by this procedure must be freed by <a href="node017.html#common-func*mosek*task*freetask"><tt class="tt">MSK_freetask</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_strduptask</tt></span>

<p> <a name="func*mosek*task*strduptask">&#09;</a><a name="common-func*mosek*task*strduptask"></a> <a name="idx-143216152">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">char * MSK_strduptask (
    MSKtask_t task,
    MSKCONST char * str);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">str</tt> (input)</dt>
<dd>String that should be copied.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Make a copy of a string. The string created by this procedure must be freed by <a href="node017.html#common-func*mosek*task*freetask"><tt class="tt">MSK_freetask</tt></a>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_strtoconetype</tt></span>

<p> <a name="func*mosek*task*strtoconetype">&#09;</a><a name="common-func*mosek*task*strtoconetype"></a> <a name="idx-143178568">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_strtoconetype (
    MSKtask_t task,
    MSKCONST char * str,
    MSKconetypee * conetype);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">str</tt> (input)</dt>
<dd>String corresponding to the cone type code <tt class="tt">codetype</tt>.</dd>
<dt><a href="node020.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a> (output)</dt>
<dd>The cone type corresponding to the string <tt class="tt">str</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains cone type code corresponding to a cone type string.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_strtosk</tt></span>

<p> <a name="func*mosek*task*strtosk">&#09;</a><a name="common-func*mosek*task*strtosk"></a> <a name="idx-143242736">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_strtosk (
    MSKtask_t task,
    MSKCONST char * str,
    MSKintt * sk);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">str</tt> (input)</dt>
<dd>Status key string.</dd>
<dt><tt class="tt">sk</tt> (output)</dt>
<dd>Status key corresponding to the string.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Obtains the status key corresponding to an explanatory string.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_undefsolution</tt></span>

<p> <a name="func*mosek*task*undefsolution">&#09;</a><a name="common-func*mosek*task*undefsolution"></a> <a name="idx-143203792">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_undefsolution (
    MSKtask_t task,
    MSKsoltypee whichsol);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Undefines a solution. Purges all information regarding <tt class="tt">whichsol</tt>.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_unlinkfuncfromtaskstream</tt></span>

<p> <a name="func*mosek*task*unlinkfuncfromtaskstream">&#09;</a><a name="common-func*mosek*task*unlinkfuncfromtaskstream"></a> <a name="idx-143257256">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_unlinkfuncfromtaskstream (
    MSKtask_t task,
    MSKstreamtypee whichstream);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*streamtype"><tt class="tt">whichstream</tt></a> (input)</dt>
<dd>Index of the stream.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Disconnects a user-defined function from a task stream.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_whichparam</tt></span>

<p> <a name="func*mosek*task*whichparam">&#09;</a><a name="common-func*mosek*task*whichparam"></a> <a name="idx-143261424">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_whichparam (
    MSKtask_t task,
    MSKCONST char * parname,
    MSKparametertypee * partype,
    MSKintt * param);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">parname</tt> (input)</dt>
<dd>Parameter name.</dd>
<dt><a href="node020.html#common-constclass*mosek*parametertype"><tt class="tt">partype</tt></a> (output)</dt>
<dd>Parameter type.</dd>
<dt><tt class="tt">param</tt> (output)</dt>
<dd>Which parameter.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Checks if <tt class="tt">parname</tt> is valid parameter name. If yes then, <tt class="tt">partype</tt> and <tt class="tt">param</tt> denotes the type and the index of parameter respectively.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_writebranchpriorities</tt></span>

<p> <a name="func*mosek*task*writebranchpriorities">&#09;</a><a name="common-func*mosek*task*writebranchpriorities"></a> <a name="idx-143274136">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_writebranchpriorities (
    MSKtask_t task,
    MSKCONST char * filename);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Data is written to the file <tt class="tt">filename</tt>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Writes branching priority data to a file.</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*readbranchpriorities"><tt class="tt">MSK_readbranchpriorities</tt></a></dt>
<dd>
<p> Reads branching priority data from a file.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_writedata</tt></span>

<p> <a name="func*mosek*task*writedata">&#09;</a><a name="common-func*mosek*task*writedata"></a> <a name="idx-143294120">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_writedata (
    MSKtask_t task,
    MSKCONST char * filename);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>Data is written to the file <tt class="tt">filename</tt> if it is a nonempty string. Otherwise data is written to the file specified by <a href="node018.html#common-const*mosek*sparam*data-file-name"><tt class="tt">MSK_SPAR_DATA_FILE_NAME</tt></a>.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>
<p>Writes problem data associated with the optimization task to a file in one of four formats:</p>

<dl class="description">
<dt></dt>
<dd>
<p>LP : A text based row oriented format. File extension <tt class="tt">.lp</tt>. See Appendix <a title="D. The LP file format" href="node024.html#app-sec-lpformat">D</a>. </p>
</dd>
<dt></dt>
<dd>
<p>MPS : A text based column oriented format. File extension <tt class="tt">.mps</tt>. See Appendix <a title="C. The MPS file format" href="node023.html#app-sec-mpsformat">C</a>. </p>
</dd>
<dt></dt>
<dd>
<p>OPF : A text based row oriented format. File extension <tt class="tt">.opf</tt>. Supports more problem types than MPS and LP. See Appendix <a title="E. The OPF format" href="node025.html#app-sec-opfformat">E</a>. </p>
</dd>
<dt></dt>
<dd>
<p>MBT : A binary format for fast reading and writing. File extension <tt class="tt">.mbt</tt>. </p>
</dd>
</dl>

<p> By default the data file format is determined by the file name extension. This behaviour can be overridden by setting the <a href="node018.html#common-const*mosek*iparam*write-data-format"><tt class="tt">MSK_IPAR_WRITE_DATA_FORMAT</tt></a> parameter.</p>

<p>MOSEK is able to read and write files in a compressed format (gzip). To write in the compressed format append the extension "<tt class="tt">.gz</tt>". E.g to write a gzip compressed MPS file use the extension <tt class="tt">mps.gz</tt>.</p>

<p>Please note that MPS, LP and OPF files require all variables to have unique names. If a task contains no names, it is possible to write the file with automaticly generated anonymous names by setting the <a href="node018.html#common-const*mosek*iparam*write-generic-names"><tt class="tt">MSK_IPAR_WRITE_GENERIC_NAMES</tt></a> parameter to <a href="node020.html#common-const*mosek*onoffkey*on"><tt class="tt">MSK_ON</tt></a>.</p>
</dd>
<dt>See also:</dt>
<dd>
<p>&nbsp;</p>

<dl class="description">
<dt><a href="node017.html#common-func*mosek*task*readdata"><tt class="tt">MSK_readdata</tt></a></dt>
<dd>
<p> Reads problem data from a file.</p>
</dd>
<dt><a href="node018.html#common-const*mosek*iparam*write-data-format"><tt class="tt">MSK_IPAR_WRITE_DATA_FORMAT</tt></a></dt>
<dd></dd>
</dl>
</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_writeparamfile</tt></span>

<p> <a name="func*mosek*task*writeparamfile">&#09;</a><a name="common-func*mosek*task*writeparamfile"></a> <a name="idx-143260776">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_writeparamfile (
    MSKtask_t task,
    MSKCONST char * filename);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>The name of parameter file.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Writes all the parameters to a parameter file.</dd>
</dl>
</li>
<li><span class="itemhead"><tt class="tt">MSK_writesolution</tt></span>

<p> <a name="func*mosek*task*writesolution">&#09;</a><a name="common-func*mosek*task*writesolution"></a> <a name="idx-143337736">&#09;</a> </p>

<dl class="funcdesc">
<dt>Syntax:</dt>
<dd>
<p>&nbsp;</p>

<pre class="verbatim">MSKrescodee MSK_writesolution (
    MSKtask_t task,
    MSKsoltypee whichsol,
    MSKCONST char * filename);
</pre>

<dl class="funcargsdesc">
<dt><tt class="tt">task</tt> (input)</dt>
<dd>An optimization task.</dd>
<dt><a href="node020.html#common-constclass*mosek*soltype"><tt class="tt">whichsol</tt></a> (input)</dt>
<dd>Selects a solution.</dd>
<dt><tt class="tt">filename</tt> (input)</dt>
<dd>A valid file name.</dd>
</dl>
</dd>
<dt>Description:</dt>
<dd>Saves the current basic, interior-point, or integer solution to a file.</dd>
</dl>
</li>
</ul>

</div>

</div>

</div>

<div class="navigationarea">
<table class="navigation" width="100%" cellpadding="0" cellspacing="2">
<tbody><tr>
<td><a href="node016.html" target="_self"><img src="graphics/previous.png" class="navbutton-previous" alt="Previous : 14. Usage guidelines" border="0"/></a></td>
<td><a href="index.html" target="_self"><img src="graphics/up.png" class="navbutton-up" alt="Up:  The MOSEK C API manual. 
Version 6.0 (Revision 137)." border="0"/></a></td>
<td><a href="node018.html" target="_self"><img src="graphics/next.png" class="navbutton-next" alt="Next:  16. Parameter reference" border="0"/></a></td>
<td align="center" class="navtitle">The MOSEK C API manual. 
<br/>Version 6.0 (Revision 137).</td>
<td><a href="index.html"><img src="graphics/contents.png" class="navbutton-contents" alt="" border="0"/></a></td>
<td><a href="node030.html"><img src="graphics/index.png" class="navbutton-index" alt="" border="0"/></a></td></tr>
</tbody>
</table>


<table class="trail"><tr>
<td valign="top"><b>Previous : </b><a href="node016.html" target="_self">14. Usage guidelines</a></td>
<td valign="top"><b>Up : </b><a href="index.html" target="_self">The MOSEK C API manual. 
<br/>Version 6.0 (Revision 137).</a></td>
<td valign="top"><b>Next : </b><a href="node018.html" target="_self">16. Parameter reference</a></td>
<td valign="top"><a href="index.html" target="_self"><b>Contents</b></a></td>
<td valign="top"><a href="node030.html"><b>Index</b></a></td></tr></table>

<hr/>
</div>

<div class="gentime">Tue Apr 10 10:50:21 2012</div>
</body></html>