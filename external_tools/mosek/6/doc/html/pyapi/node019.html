<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>17. Constants</title>
<!-- pyLaTeX: XHTML.lib.Sectioning.chapter -->
<link href="styles/style.css" rel="stylesheet"/>
<link href="styles/gstyles.css" rel="stylesheet"/>
<link href="graphics/favicon.png" rel="shortcut icon"/>
</head>
<body>
<div class="navigationarea">
<table class="navigation" width="100%" cellpadding="0" cellspacing="2">
<tbody><tr>
<td><a href="node018.html" target="_self"><img src="graphics/previous.png" class="navbutton-previous" alt="Previous : 16. Response codes" border="0"/></a></td>
<td><a href="index.html" target="_self"><img src="graphics/up.png" class="navbutton-up" alt="Up:  The MOSEK Python API manual. 
Version 6.0 (Revision 137)." border="0"/></a></td>
<td><a href="node020.html" target="_self"><img src="graphics/next.png" class="navbutton-next" alt="Next:  A. Problem analyzer examples" border="0"/></a></td>
<td align="center" class="navtitle">The MOSEK Python API manual. 
<br/>Version 6.0 (Revision 137).</td>
<td><a href="index.html"><img src="graphics/contents.png" class="navbutton-contents" alt="" border="0"/></a></td>
<td><a href="node028.html"><img src="graphics/index.png" class="navbutton-index" alt="" border="0"/></a></td></tr>
</tbody>
</table>


<table class="trail"><tr>
<td valign="top"><b>Previous : </b><a href="node018.html" target="_self">16. Response codes</a></td>
<td valign="top"><b>Up : </b><a href="index.html" target="_self">The MOSEK Python API manual. 
<br/>Version 6.0 (Revision 137).</a></td>
<td valign="top"><b>Next : </b><a href="node020.html" target="_self">A. Problem analyzer examples</a></td>
<td valign="top"><a href="index.html" target="_self"><b>Contents</b></a></td>
<td valign="top"><a href="node028.html"><b>Index</b></a></td></tr></table>

<hr/>
</div>

<div>
<h1><a name="249792200">17. Constants</a></h1>

<div class="contents">
<ul class="toc-level-1">
<li><a href="node019.html#249804992" target="_self">17.1. Constraint or variable access modes</a></li>
<li><a href="node019.html#249806928" target="_self">17.2. Function opcode</a></li>
<li><a href="node019.html#249812824" target="_self">17.3. Function operand type</a></li>
<li><a href="node019.html#249816128" target="_self">17.4. Basis identification</a></li>
<li><a href="node019.html#249820080" target="_self">17.5. Bound keys</a></li>
<li><a href="node019.html#249824032" target="_self">17.6. Specifies the branching direction.</a></li>
<li><a href="node019.html#249826624" target="_self">17.7. Progress call-back codes</a></li>
<li><a href="node019.html#249904952" target="_self">17.8. Types of convexity checks.</a></li>
<li><a href="node019.html#249907608" target="_self">17.9. Compression types</a></li>
<li><a href="node019.html#249910264" target="_self">17.10. Cone types</a></li>
<li><a href="node019.html#249912208" target="_self">17.11. CPU type</a></li>
<li><a href="node019.html#249920112" target="_self">17.12. Data format types</a></li>
<li><a href="node019.html#249925360" target="_self">17.13. Double information items</a></li>
<li><a href="node019.html#251602272" target="_self">17.14. Feasibility repair types</a></li>
<li><a href="node019.html#251604864" target="_self">17.15. License feature</a></li>
<li><a href="node019.html#251608168" target="_self">17.16. Integer information items.</a></li>
<li><a href="node019.html#251678376" target="_self">17.17. Information item types</a></li>
<li><a href="node019.html#251681032" target="_self">17.18. Input/output modes</a></li>
<li><a href="node019.html#251683688" target="_self">17.19. Language selection constants</a></li>
<li><a href="node019.html#251685632" target="_self">17.20. Long integer information items.</a></li>
<li><a href="node019.html#251695544" target="_self">17.21. Mark</a></li>
<li><a href="node019.html#251697488" target="_self">17.22. Continuous mixed-integer solution type</a></li>
<li><a href="node019.html#251700792" target="_self">17.23. Integer restrictions</a></li>
<li><a href="node019.html#251703448" target="_self">17.24. Mixed-integer node selection types</a></li>
<li><a href="node019.html#251708048" target="_self">17.25. MPS file format type</a></li>
<li><a href="node019.html#251710640" target="_self">17.26. Message keys</a></li>
<li><a href="node019.html#251713296" target="_self">17.27. Network detection method</a></li>
<li><a href="node019.html#251715952" target="_self">17.28. Objective sense types</a></li>
<li><a href="node019.html#251718544" target="_self">17.29. On/off</a></li>
<li><a href="node019.html#251720552" target="_self">17.30. Optimizer types</a></li>
<li><a href="node019.html#251728456" target="_self">17.31. Ordering strategies</a></li>
<li><a href="node019.html#251733056" target="_self">17.32. Parameter type</a></li>
<li><a href="node019.html#251736360" target="_self">17.33. Presolve method.</a></li>
<li><a href="node019.html#251738952" target="_self">17.34. Problem data items</a></li>
<li><a href="node019.html#251741608" target="_self">17.35. Problem types</a></li>
<li><a href="node019.html#251746208" target="_self">17.36. Problem status keys</a></li>
<li><a href="node019.html#251754760" target="_self">17.37. Interpretation of quadratic terms in MPS files</a></li>
<li><a href="node019.html#251757416" target="_self">17.38. Response code type</a></li>
<li><a href="node019.html#251761368" target="_self">17.39. Scaling type</a></li>
<li><a href="node019.html#251763312" target="_self">17.40. Scaling type</a></li>
<li><a href="node019.html#251766616" target="_self">17.41. Sensitivity types</a></li>
<li><a href="node019.html#251768560" target="_self">17.42. Degeneracy strategies</a></li>
<li><a href="node019.html#251772512" target="_self">17.43. Exploit duplicate columns.</a></li>
<li><a href="node019.html#251775168" target="_self">17.44. Hot-start type employed by the simplex optimizer</a></li>
<li><a href="node019.html#251777824" target="_self">17.45. Problem reformulation.</a></li>
<li><a href="node019.html#251781064" target="_self">17.46. Simplex selection strategy</a></li>
<li><a href="node019.html#251785728" target="_self">17.47. Solution items</a></li>
<li><a href="node019.html#251791624" target="_self">17.48. Solution status keys</a></li>
<li><a href="node019.html#251802184" target="_self">17.49. Solution types</a></li>
<li><a href="node019.html#251804776" target="_self">17.50. Solve primal or dual form</a></li>
<li><a href="node019.html#251807432" target="_self">17.51. Status keys</a></li>
<li><a href="node019.html#251812680" target="_self">17.52. Starting point types</a></li>
<li><a href="node019.html#251815984" target="_self">17.53. Stream types</a></li>
<li><a href="node019.html#251819288" target="_self">17.54. Integer values</a></li>
<li><a href="node019.html#251821232" target="_self">17.55. Variable types</a></li>
<li><a href="node019.html#251823240" target="_self">17.56. XML writer output mode</a></li>
</ul>

<hr width="100%" class="tocseparator"/>
</div>

<p> <a name="chap-constsref">&#09;</a></p>

<ul class="itemize">
<li> <a href="node019.html#common-constclass*mosek*accmode"><tt class="tt">accmode</tt></a>
<br/>
<br/>Constraint or variable access modes </li>
<li> <a href="node019.html#common-constclass*mosek*adopcode"><tt class="tt">adopcode</tt></a>
<br/>
<br/>Function opcode </li>
<li> <a href="node019.html#common-constclass*mosek*adoptype"><tt class="tt">adoptype</tt></a>
<br/>
<br/>Function operand type </li>
<li> <a href="node019.html#common-constclass*mosek*basindtype"><tt class="tt">basindtype</tt></a>
<br/>
<br/>Basis identification </li>
<li> <a href="node019.html#common-constclass*mosek*boundkey"><tt class="tt">boundkey</tt></a>
<br/>
<br/>Bound keys </li>
<li> <a href="node019.html#common-constclass*mosek*branchdir"><tt class="tt">branchdir</tt></a>
<br/>
<br/>Specifies the branching direction. </li>
<li> <a href="node019.html#common-constclass*mosek*callbackcode"><tt class="tt">callbackcode</tt></a>
<br/>
<br/>Progress call-back codes </li>
<li> <a href="node019.html#common-constclass*mosek*checkconvexitytype"><tt class="tt">checkconvexitytype</tt></a>
<br/>
<br/>Types of convexity checks. </li>
<li> <a href="node019.html#common-constclass*mosek*compresstype"><tt class="tt">compresstype</tt></a>
<br/>
<br/>Compression types </li>
<li> <a href="node019.html#common-constclass*mosek*conetype"><tt class="tt">conetype</tt></a>
<br/>
<br/>Cone types </li>
<li> <a href="node019.html#common-constclass*mosek*cputype"><tt class="tt">cputype</tt></a>
<br/>
<br/>CPU type </li>
<li> <a href="node019.html#common-constclass*mosek*dataformat"><tt class="tt">dataformat</tt></a>
<br/>
<br/>Data format types </li>
<li> <a href="node019.html#common-constclass*mosek*dinfitem"><tt class="tt">dinfitem</tt></a>
<br/>
<br/>Double information items </li>
<li> <a href="node019.html#common-constclass*mosek*feasrepairtype"><tt class="tt">feasrepairtype</tt></a>
<br/>
<br/>Feasibility repair types </li>
<li> <a href="node019.html#common-constclass*mosek*feature"><tt class="tt">feature</tt></a>
<br/>
<br/>License feature </li>
<li> <a href="node019.html#common-constclass*mosek*iinfitem"><tt class="tt">iinfitem</tt></a>
<br/>
<br/>Integer information items. </li>
<li> <a href="node019.html#common-constclass*mosek*inftype"><tt class="tt">inftype</tt></a>
<br/>
<br/>Information item types </li>
<li> <a href="node019.html#common-constclass*mosek*iomode"><tt class="tt">iomode</tt></a>
<br/>
<br/>Input/output modes </li>
<li> <a href="node019.html#common-constclass*mosek*language"><tt class="tt">language</tt></a>
<br/>
<br/>Language selection constants </li>
<li> <a href="node019.html#common-constclass*mosek*liinfitem"><tt class="tt">liinfitem</tt></a>
<br/>
<br/>Long integer information items. </li>
<li> <a href="node019.html#common-constclass*mosek*mark"><tt class="tt">mark</tt></a>
<br/>
<br/>Mark </li>
<li> <a href="node019.html#common-constclass*mosek*miocontsoltype"><tt class="tt">miocontsoltype</tt></a>
<br/>
<br/>Continuous mixed-integer solution type </li>
<li> <a href="node019.html#common-constclass*mosek*miomode"><tt class="tt">miomode</tt></a>
<br/>
<br/>Integer restrictions </li>
<li> <a href="node019.html#common-constclass*mosek*mionodeseltype"><tt class="tt">mionodeseltype</tt></a>
<br/>
<br/>Mixed-integer node selection types </li>
<li> <a href="node019.html#common-constclass*mosek*mpsformat"><tt class="tt">mpsformat</tt></a>
<br/>
<br/>MPS file format type </li>
<li> <a href="node019.html#common-constclass*mosek*msgkey"><tt class="tt">msgkey</tt></a>
<br/>
<br/>Message keys </li>
<li> <a href="node019.html#common-constclass*mosek*networkdetect"><tt class="tt">networkdetect</tt></a>
<br/>
<br/>Network detection method </li>
<li> <a href="node019.html#common-constclass*mosek*objsense"><tt class="tt">objsense</tt></a>
<br/>
<br/>Objective sense types </li>
<li> <a href="node019.html#common-constclass*mosek*onoffkey"><tt class="tt">onoffkey</tt></a>
<br/>
<br/>On/off </li>
<li> <a href="node019.html#common-constclass*mosek*optimizertype"><tt class="tt">optimizertype</tt></a>
<br/>
<br/>Optimizer types </li>
<li> <a href="node019.html#common-constclass*mosek*orderingtype"><tt class="tt">orderingtype</tt></a>
<br/>
<br/>Ordering strategies </li>
<li> <a href="node019.html#common-constclass*mosek*parametertype"><tt class="tt">parametertype</tt></a>
<br/>
<br/>Parameter type </li>
<li> <a href="node019.html#common-constclass*mosek*presolvemode"><tt class="tt">presolvemode</tt></a>
<br/>
<br/>Presolve method. </li>
<li> <a href="node019.html#common-constclass*mosek*problemitem"><tt class="tt">problemitem</tt></a>
<br/>
<br/>Problem data items </li>
<li> <a href="node019.html#common-constclass*mosek*problemtype"><tt class="tt">problemtype</tt></a>
<br/>
<br/>Problem types </li>
<li> <a href="node019.html#common-constclass*mosek*prosta"><tt class="tt">prosta</tt></a>
<br/>
<br/>Problem status keys </li>
<li> <a href="node019.html#common-constclass*mosek*qreadtype"><tt class="tt">qreadtype</tt></a>
<br/>
<br/>Interpretation of quadratic terms in MPS files </li>
<li> <a href="node019.html#common-constclass*mosek*rescodetype"><tt class="tt">rescodetype</tt></a>
<br/>
<br/>Response code type </li>
<li> <a href="node019.html#common-constclass*mosek*scalingmethod"><tt class="tt">scalingmethod</tt></a>
<br/>
<br/>Scaling type </li>
<li> <a href="node019.html#common-constclass*mosek*scalingtype"><tt class="tt">scalingtype</tt></a>
<br/>
<br/>Scaling type </li>
<li> <a href="node019.html#common-constclass*mosek*sensitivitytype"><tt class="tt">sensitivitytype</tt></a>
<br/>
<br/>Sensitivity types </li>
<li> <a href="node019.html#common-constclass*mosek*simdegen"><tt class="tt">simdegen</tt></a>
<br/>
<br/>Degeneracy strategies </li>
<li> <a href="node019.html#common-constclass*mosek*simdupvec"><tt class="tt">simdupvec</tt></a>
<br/>
<br/>Exploit duplicate columns. </li>
<li> <a href="node019.html#common-constclass*mosek*simhotstart"><tt class="tt">simhotstart</tt></a>
<br/>
<br/>Hot-start type employed by the simplex optimizer </li>
<li> <a href="node019.html#common-constclass*mosek*simreform"><tt class="tt">simreform</tt></a>
<br/>
<br/>Problem reformulation. </li>
<li> <a href="node019.html#common-constclass*mosek*simseltype"><tt class="tt">simseltype</tt></a>
<br/>
<br/>Simplex selection strategy </li>
<li> <a href="node019.html#common-constclass*mosek*solitem"><tt class="tt">solitem</tt></a>
<br/>
<br/>Solution items </li>
<li> <a href="node019.html#common-constclass*mosek*solsta"><tt class="tt">solsta</tt></a>
<br/>
<br/>Solution status keys </li>
<li> <a href="node019.html#common-constclass*mosek*soltype"><tt class="tt">soltype</tt></a>
<br/>
<br/>Solution types </li>
<li> <a href="node019.html#common-constclass*mosek*solveform"><tt class="tt">solveform</tt></a>
<br/>
<br/>Solve primal or dual form </li>
<li> <a href="node019.html#common-constclass*mosek*stakey"><tt class="tt">stakey</tt></a>
<br/>
<br/>Status keys </li>
<li> <a href="node019.html#common-constclass*mosek*startpointtype"><tt class="tt">startpointtype</tt></a>
<br/>
<br/>Starting point types </li>
<li> <a href="node019.html#common-constclass*mosek*streamtype"><tt class="tt">streamtype</tt></a>
<br/>
<br/>Stream types </li>
<li> <a href="node019.html#common-constclass*mosek*value"><tt class="tt">value</tt></a>
<br/>
<br/>Integer values </li>
<li> <a href="node019.html#common-constclass*mosek*variabletype"><tt class="tt">variabletype</tt></a>
<br/>
<br/>Variable types </li>
<li> <a href="node019.html#common-constclass*mosek*xmlwriteroutputtype"><tt class="tt">xmlwriteroutputtype</tt></a>
<br/>
<br/>XML writer output mode </li>
</ul>

<div>
<h1><a name="249804992">17.1. Constraint or variable access modes</a></h1>

<p> <a name="constclass*mosek*accmode">&#09;</a><a name="common-constclass*mosek*accmode"></a> <a name="idx-168268360">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.accmode.con</tt><a name="const*mosek*accmode*con">&#09;</a><a name="common-const*mosek*accmode*con"></a> 
<br/>Access data by rows (constraint oriented) </li>
<li><tt class="tt">mosek.accmode.var</tt><a name="const*mosek*accmode*var">&#09;</a><a name="common-const*mosek*accmode*var"></a> 
<br/>Access data by columns (variable orinted) </li>
</ul>

</div>

<div>
<h1><a name="249806928">17.2. Function opcode</a></h1>

<p> <a name="constclass*mosek*adopcode">&#09;</a><a name="common-constclass*mosek*adopcode"></a> <a name="idx-168286976">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.adopcode.add</tt><a name="const*mosek*adopcode*add">&#09;</a><a name="common-const*mosek*adopcode*add"></a> 
<br/>Add two operands. </li>
<li><tt class="tt">mosek.adopcode.div</tt><a name="const*mosek*adopcode*div">&#09;</a><a name="common-const*mosek*adopcode*div"></a> 
<br/>Divide two operands. </li>
<li><tt class="tt">mosek.adopcode.exp</tt><a name="const*mosek*adopcode*exp">&#09;</a><a name="common-const*mosek*adopcode*exp"></a> 
<br/>Exponential function of one oparand. </li>
<li><tt class="tt">mosek.adopcode.log</tt><a name="const*mosek*adopcode*log">&#09;</a><a name="common-const*mosek*adopcode*log"></a> 
<br/>Logarithm function of one operand. </li>
<li><tt class="tt">mosek.adopcode.mul</tt><a name="const*mosek*adopcode*mul">&#09;</a><a name="common-const*mosek*adopcode*mul"></a> 
<br/>Multiply two operands. </li>
<li><tt class="tt">mosek.adopcode.pow</tt><a name="const*mosek*adopcode*pow">&#09;</a><a name="common-const*mosek*adopcode*pow"></a> 
<br/>First operand to the power the second operand. </li>
<li><tt class="tt">mosek.adopcode.ret</tt><a name="const*mosek*adopcode*ret">&#09;</a><a name="common-const*mosek*adopcode*ret"></a> 
<br/>Return one operand. </li>
<li><tt class="tt">mosek.adopcode.sub</tt><a name="const*mosek*adopcode*sub">&#09;</a><a name="common-const*mosek*adopcode*sub"></a> 
<br/>Subtract two operands. </li>
</ul>

</div>

<div>
<h1><a name="249812824">17.3. Function operand type</a></h1>

<p> <a name="constclass*mosek*adoptype">&#09;</a><a name="common-constclass*mosek*adoptype"></a> <a name="idx-168318808">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.adoptype.constant</tt><a name="const*mosek*adoptype*constant">&#09;</a><a name="common-const*mosek*adoptype*constant"></a> 
<br/>Operand refers to a constant. </li>
<li><tt class="tt">mosek.adoptype.none</tt><a name="const*mosek*adoptype*none">&#09;</a><a name="common-const*mosek*adoptype*none"></a> 
<br/>Operand not used. </li>
<li><tt class="tt">mosek.adoptype.reference</tt><a name="const*mosek*adoptype*reference">&#09;</a><a name="common-const*mosek*adoptype*reference"></a> 
<br/>Operand refers to the result of another operation. </li>
<li><tt class="tt">mosek.adoptype.variable</tt><a name="const*mosek*adoptype*variable">&#09;</a><a name="common-const*mosek*adoptype*variable"></a> 
<br/>Operand refers to a variable. </li>
</ul>

</div>

<div>
<h1><a name="249816128">17.4. Basis identification</a></h1>

<p> <a name="constclass*mosek*basindtype">&#09;</a><a name="common-constclass*mosek*basindtype"></a> <a name="idx-168340872">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.basindtype.always</tt><a name="const*mosek*basindtype*always">&#09;</a><a name="common-const*mosek*basindtype*always"></a> 
<br/>Basis identification is always performed even if the interior-point optimizer terminates abnormally. </li>
<li><tt class="tt">mosek.basindtype.if_feasible</tt><a name="const*mosek*basindtype*if-feasible">&#09;</a><a name="common-const*mosek*basindtype*if-feasible"></a> 
<br/>Basis identification is not performed if the interior-point optimizer terminates with a problem status saying that the problem is primal or dual infeasible. </li>
<li><tt class="tt">mosek.basindtype.never</tt><a name="const*mosek*basindtype*never">&#09;</a><a name="common-const*mosek*basindtype*never"></a> 
<br/>Never do basis identification. </li>
<li><tt class="tt">mosek.basindtype.no_error</tt><a name="const*mosek*basindtype*no-error">&#09;</a><a name="common-const*mosek*basindtype*no-error"></a> 
<br/>Basis identification is performed if the interior-point optimizer terminates without an error. </li>
<li><tt class="tt">mosek.basindtype.other</tt><a name="const*mosek*basindtype*other">&#09;</a><a name="common-const*mosek*basindtype*other"></a> 
<br/>Try another BI method. </li>
</ul>

</div>

<div>
<h1><a name="249820080">17.5. Bound keys</a></h1>

<p> <a name="constclass*mosek*boundkey">&#09;</a><a name="common-constclass*mosek*boundkey"></a> <a name="idx-168363648">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.boundkey.fr</tt><a name="const*mosek*boundkey*fr">&#09;</a><a name="common-const*mosek*boundkey*fr"></a> 
<br/>The constraint or variable is free. </li>
<li><tt class="tt">mosek.boundkey.fx</tt><a name="const*mosek*boundkey*fx">&#09;</a><a name="common-const*mosek*boundkey*fx"></a> 
<br/>The constraint or variable is fixed. </li>
<li><tt class="tt">mosek.boundkey.lo</tt><a name="const*mosek*boundkey*lo">&#09;</a><a name="common-const*mosek*boundkey*lo"></a> 
<br/>The constraint or variable has a finite lower bound and an infinite upper bound. </li>
<li><tt class="tt">mosek.boundkey.ra</tt><a name="const*mosek*boundkey*ra">&#09;</a><a name="common-const*mosek*boundkey*ra"></a> 
<br/>The constraint or variable is ranged. </li>
<li><tt class="tt">mosek.boundkey.up</tt><a name="const*mosek*boundkey*up">&#09;</a><a name="common-const*mosek*boundkey*up"></a> 
<br/>The constraint or variable has an infinite lower bound and an finite upper bound. </li>
</ul>

</div>

<div>
<h1><a name="249824032">17.6. Specifies the branching direction.</a></h1>

<p> <a name="constclass*mosek*branchdir">&#09;</a><a name="common-constclass*mosek*branchdir"></a> <a name="idx-169536832">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.branchdir.down</tt><a name="const*mosek*branchdir*down">&#09;</a><a name="common-const*mosek*branchdir*down"></a> 
<br/>The mixed-integer optimizer always chooses the down branch first. </li>
<li><tt class="tt">mosek.branchdir.free</tt><a name="const*mosek*branchdir*free">&#09;</a><a name="common-const*mosek*branchdir*free"></a> 
<br/>The mixed-integer optimizer decides which branch to choose. </li>
<li><tt class="tt">mosek.branchdir.up</tt><a name="const*mosek*branchdir*up">&#09;</a><a name="common-const*mosek*branchdir*up"></a> 
<br/>The mixed-integer optimizer always chooses the up branch first. </li>
</ul>

</div>

<div>
<h1><a name="249826624">17.7. Progress call-back codes</a></h1>

<p> <a name="constclass*mosek*callbackcode">&#09;</a><a name="common-constclass*mosek*callbackcode"></a> <a name="idx-169540568">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.callbackcode.begin_bi</tt><a name="const*mosek*callbackcode*begin-bi">&#09;</a><a name="common-const*mosek*callbackcode*begin-bi"></a> 
<br/>The basis identification procedure has been started. </li>
<li><tt class="tt">mosek.callbackcode.begin_concurrent</tt><a name="const*mosek*callbackcode*begin-concurrent">&#09;</a><a name="common-const*mosek*callbackcode*begin-concurrent"></a> 
<br/>Concurrent optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_conic</tt><a name="const*mosek*callbackcode*begin-conic">&#09;</a><a name="common-const*mosek*callbackcode*begin-conic"></a> 
<br/>The call-back function is called when the conic optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_dual_bi</tt><a name="const*mosek*callbackcode*begin-dual-bi">&#09;</a><a name="common-const*mosek*callbackcode*begin-dual-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the dual phase is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_dual_sensitivity</tt><a name="const*mosek*callbackcode*begin-dual-sensitivity">&#09;</a><a name="common-const*mosek*callbackcode*begin-dual-sensitivity"></a> 
<br/>Dual sensitivity analysis is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_dual_setup_bi</tt><a name="const*mosek*callbackcode*begin-dual-setup-bi">&#09;</a><a name="common-const*mosek*callbackcode*begin-dual-setup-bi"></a> 
<br/>The call-back function is called when the dual BI phase is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_dual_simplex</tt><a name="const*mosek*callbackcode*begin-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*begin-dual-simplex"></a> 
<br/>The call-back function is called when the dual simplex optimizer started. </li>
<li><tt class="tt">mosek.callbackcode.begin_dual_simplex_bi</tt><a name="const*mosek*callbackcode*begin-dual-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*begin-dual-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the dual simplex clean-up phase is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_full_convexity_check</tt><a name="const*mosek*callbackcode*begin-full-convexity-check">&#09;</a><a name="common-const*mosek*callbackcode*begin-full-convexity-check"></a> 
<br/>Begin full convexity check. </li>
<li><tt class="tt">mosek.callbackcode.begin_infeas_ana</tt><a name="const*mosek*callbackcode*begin-infeas-ana">&#09;</a><a name="common-const*mosek*callbackcode*begin-infeas-ana"></a> 
<br/>The call-back function is called when the infeasibility analyzer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_intpnt</tt><a name="const*mosek*callbackcode*begin-intpnt">&#09;</a><a name="common-const*mosek*callbackcode*begin-intpnt"></a> 
<br/>The call-back function is called when the interior-point optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_license_wait</tt><a name="const*mosek*callbackcode*begin-license-wait">&#09;</a><a name="common-const*mosek*callbackcode*begin-license-wait"></a> 
<br/>Begin waiting for license. </li>
<li><tt class="tt">mosek.callbackcode.begin_mio</tt><a name="const*mosek*callbackcode*begin-mio">&#09;</a><a name="common-const*mosek*callbackcode*begin-mio"></a> 
<br/>The call-back function is called when the mixed-integer optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_network_dual_simplex</tt><a name="const*mosek*callbackcode*begin-network-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*begin-network-dual-simplex"></a> 
<br/>The call-back function is called when the dual network simplex optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_network_primal_simplex</tt><a name="const*mosek*callbackcode*begin-network-primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*begin-network-primal-simplex"></a> 
<br/>The call-back function is called when the primal network simplex optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_network_simplex</tt><a name="const*mosek*callbackcode*begin-network-simplex">&#09;</a><a name="common-const*mosek*callbackcode*begin-network-simplex"></a> 
<br/>The call-back function is called when the simplex network optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_nonconvex</tt><a name="const*mosek*callbackcode*begin-nonconvex">&#09;</a><a name="common-const*mosek*callbackcode*begin-nonconvex"></a> 
<br/>The call-back function is called when the nonconvex optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_optimizer</tt><a name="const*mosek*callbackcode*begin-optimizer">&#09;</a><a name="common-const*mosek*callbackcode*begin-optimizer"></a> 
<br/>The call-back function is called when the optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_presolve</tt><a name="const*mosek*callbackcode*begin-presolve">&#09;</a><a name="common-const*mosek*callbackcode*begin-presolve"></a> 
<br/>The call-back function is called when the presolve is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_primal_bi</tt><a name="const*mosek*callbackcode*begin-primal-bi">&#09;</a><a name="common-const*mosek*callbackcode*begin-primal-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the primal phase is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_primal_dual_simplex</tt><a name="const*mosek*callbackcode*begin-primal-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*begin-primal-dual-simplex"></a> 
<br/>The call-back function is called when the primal-dual simplex optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_primal_dual_simplex_bi</tt><a name="const*mosek*callbackcode*begin-primal-dual-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*begin-primal-dual-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the primal-dual simplex clean-up phase is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_primal_sensitivity</tt><a name="const*mosek*callbackcode*begin-primal-sensitivity">&#09;</a><a name="common-const*mosek*callbackcode*begin-primal-sensitivity"></a> 
<br/>Primal sensitivity analysis is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_primal_setup_bi</tt><a name="const*mosek*callbackcode*begin-primal-setup-bi">&#09;</a><a name="common-const*mosek*callbackcode*begin-primal-setup-bi"></a> 
<br/>The call-back function is called when the primal BI setup is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_primal_simplex</tt><a name="const*mosek*callbackcode*begin-primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*begin-primal-simplex"></a> 
<br/>The call-back function is called when the primal simplex optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_primal_simplex_bi</tt><a name="const*mosek*callbackcode*begin-primal-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*begin-primal-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the primal simplex clean-up phase is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_qcqo_reformulate</tt><a name="const*mosek*callbackcode*begin-qcqo-reformulate">&#09;</a><a name="common-const*mosek*callbackcode*begin-qcqo-reformulate"></a> 
<br/>Begin QCQO reformulation. </li>
<li><tt class="tt">mosek.callbackcode.begin_read</tt><a name="const*mosek*callbackcode*begin-read">&#09;</a><a name="common-const*mosek*callbackcode*begin-read"></a> 
<br/>MOSEK has started reading a problem file. </li>
<li><tt class="tt">mosek.callbackcode.begin_simplex</tt><a name="const*mosek*callbackcode*begin-simplex">&#09;</a><a name="common-const*mosek*callbackcode*begin-simplex"></a> 
<br/>The call-back function is called when the simplex optimizer is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_simplex_bi</tt><a name="const*mosek*callbackcode*begin-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*begin-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the simplex clean-up phase is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_simplex_network_detect</tt><a name="const*mosek*callbackcode*begin-simplex-network-detect">&#09;</a><a name="common-const*mosek*callbackcode*begin-simplex-network-detect"></a> 
<br/>The call-back function is called when the network detection procedure is started. </li>
<li><tt class="tt">mosek.callbackcode.begin_write</tt><a name="const*mosek*callbackcode*begin-write">&#09;</a><a name="common-const*mosek*callbackcode*begin-write"></a> 
<br/>MOSEK has started writing a problem file. </li>
<li><tt class="tt">mosek.callbackcode.conic</tt><a name="const*mosek*callbackcode*conic">&#09;</a><a name="common-const*mosek*callbackcode*conic"></a> 
<br/>The call-back function is called from within the conic optimizer after the information database has been updated. </li>
<li><tt class="tt">mosek.callbackcode.dual_simplex</tt><a name="const*mosek*callbackcode*dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*dual-simplex"></a> 
<br/>The call-back function is called from within the dual simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.end_bi</tt><a name="const*mosek*callbackcode*end-bi">&#09;</a><a name="common-const*mosek*callbackcode*end-bi"></a> 
<br/>The call-back function is called when the basis identification procedure is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_concurrent</tt><a name="const*mosek*callbackcode*end-concurrent">&#09;</a><a name="common-const*mosek*callbackcode*end-concurrent"></a> 
<br/>Concurrent optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_conic</tt><a name="const*mosek*callbackcode*end-conic">&#09;</a><a name="common-const*mosek*callbackcode*end-conic"></a> 
<br/>The call-back function is called when the conic optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_dual_bi</tt><a name="const*mosek*callbackcode*end-dual-bi">&#09;</a><a name="common-const*mosek*callbackcode*end-dual-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the dual phase is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_dual_sensitivity</tt><a name="const*mosek*callbackcode*end-dual-sensitivity">&#09;</a><a name="common-const*mosek*callbackcode*end-dual-sensitivity"></a> 
<br/>Dual sensitivity analysis is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_dual_setup_bi</tt><a name="const*mosek*callbackcode*end-dual-setup-bi">&#09;</a><a name="common-const*mosek*callbackcode*end-dual-setup-bi"></a> 
<br/>The call-back function is called when the dual BI phase is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_dual_simplex</tt><a name="const*mosek*callbackcode*end-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*end-dual-simplex"></a> 
<br/>The call-back function is called when the dual simplex optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_dual_simplex_bi</tt><a name="const*mosek*callbackcode*end-dual-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*end-dual-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the dual clean-up phase is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_full_convexity_check</tt><a name="const*mosek*callbackcode*end-full-convexity-check">&#09;</a><a name="common-const*mosek*callbackcode*end-full-convexity-check"></a> 
<br/>End full convexity check. </li>
<li><tt class="tt">mosek.callbackcode.end_infeas_ana</tt><a name="const*mosek*callbackcode*end-infeas-ana">&#09;</a><a name="common-const*mosek*callbackcode*end-infeas-ana"></a> 
<br/>The call-back function is called when the infeasibility analyzer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_intpnt</tt><a name="const*mosek*callbackcode*end-intpnt">&#09;</a><a name="common-const*mosek*callbackcode*end-intpnt"></a> 
<br/>The call-back function is called when the interior-point optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_license_wait</tt><a name="const*mosek*callbackcode*end-license-wait">&#09;</a><a name="common-const*mosek*callbackcode*end-license-wait"></a> 
<br/>End waiting for license. </li>
<li><tt class="tt">mosek.callbackcode.end_mio</tt><a name="const*mosek*callbackcode*end-mio">&#09;</a><a name="common-const*mosek*callbackcode*end-mio"></a> 
<br/>The call-back function is called when the mixed-integer optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_network_dual_simplex</tt><a name="const*mosek*callbackcode*end-network-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*end-network-dual-simplex"></a> 
<br/>The call-back function is called when the dual network simplex optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_network_primal_simplex</tt><a name="const*mosek*callbackcode*end-network-primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*end-network-primal-simplex"></a> 
<br/>The call-back function is called when the primal network simplex optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_network_simplex</tt><a name="const*mosek*callbackcode*end-network-simplex">&#09;</a><a name="common-const*mosek*callbackcode*end-network-simplex"></a> 
<br/>The call-back function is called when the simplex network optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_nonconvex</tt><a name="const*mosek*callbackcode*end-nonconvex">&#09;</a><a name="common-const*mosek*callbackcode*end-nonconvex"></a> 
<br/>The call-back function is called when the nonconvex optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_optimizer</tt><a name="const*mosek*callbackcode*end-optimizer">&#09;</a><a name="common-const*mosek*callbackcode*end-optimizer"></a> 
<br/>The call-back function is called when the optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_presolve</tt><a name="const*mosek*callbackcode*end-presolve">&#09;</a><a name="common-const*mosek*callbackcode*end-presolve"></a> 
<br/>The call-back function is called when the presolve is completed. </li>
<li><tt class="tt">mosek.callbackcode.end_primal_bi</tt><a name="const*mosek*callbackcode*end-primal-bi">&#09;</a><a name="common-const*mosek*callbackcode*end-primal-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the primal phase is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_primal_dual_simplex</tt><a name="const*mosek*callbackcode*end-primal-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*end-primal-dual-simplex"></a> 
<br/>The call-back function is called when the primal-dual simplex optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_primal_dual_simplex_bi</tt><a name="const*mosek*callbackcode*end-primal-dual-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*end-primal-dual-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the primal-dual clean-up phase is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_primal_sensitivity</tt><a name="const*mosek*callbackcode*end-primal-sensitivity">&#09;</a><a name="common-const*mosek*callbackcode*end-primal-sensitivity"></a> 
<br/>Primal sensitivity analysis is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_primal_setup_bi</tt><a name="const*mosek*callbackcode*end-primal-setup-bi">&#09;</a><a name="common-const*mosek*callbackcode*end-primal-setup-bi"></a> 
<br/>The call-back function is called when the primal BI setup is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_primal_simplex</tt><a name="const*mosek*callbackcode*end-primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*end-primal-simplex"></a> 
<br/>The call-back function is called when the primal simplex optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_primal_simplex_bi</tt><a name="const*mosek*callbackcode*end-primal-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*end-primal-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the primal clean-up phase is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_qcqo_reformulate</tt><a name="const*mosek*callbackcode*end-qcqo-reformulate">&#09;</a><a name="common-const*mosek*callbackcode*end-qcqo-reformulate"></a> 
<br/>End QCQO reformulation. </li>
<li><tt class="tt">mosek.callbackcode.end_read</tt><a name="const*mosek*callbackcode*end-read">&#09;</a><a name="common-const*mosek*callbackcode*end-read"></a> 
<br/>MOSEK has finished reading a problem file. </li>
<li><tt class="tt">mosek.callbackcode.end_simplex</tt><a name="const*mosek*callbackcode*end-simplex">&#09;</a><a name="common-const*mosek*callbackcode*end-simplex"></a> 
<br/>The call-back function is called when the simplex optimizer is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_simplex_bi</tt><a name="const*mosek*callbackcode*end-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*end-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure when the simplex clean-up phase is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_simplex_network_detect</tt><a name="const*mosek*callbackcode*end-simplex-network-detect">&#09;</a><a name="common-const*mosek*callbackcode*end-simplex-network-detect"></a> 
<br/>The call-back function is called when the network detection procedure is terminated. </li>
<li><tt class="tt">mosek.callbackcode.end_write</tt><a name="const*mosek*callbackcode*end-write">&#09;</a><a name="common-const*mosek*callbackcode*end-write"></a> 
<br/>MOSEK has finished writing a problem file. </li>
<li><tt class="tt">mosek.callbackcode.im_bi</tt><a name="const*mosek*callbackcode*im-bi">&#09;</a><a name="common-const*mosek*callbackcode*im-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure at an intermediate point. </li>
<li><tt class="tt">mosek.callbackcode.im_conic</tt><a name="const*mosek*callbackcode*im-conic">&#09;</a><a name="common-const*mosek*callbackcode*im-conic"></a> 
<br/>The call-back function is called at an intermediate stage within the conic optimizer where the information database has not been updated. </li>
<li><tt class="tt">mosek.callbackcode.im_dual_bi</tt><a name="const*mosek*callbackcode*im-dual-bi">&#09;</a><a name="common-const*mosek*callbackcode*im-dual-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure at an intermediate point in the dual phase. </li>
<li><tt class="tt">mosek.callbackcode.im_dual_sensivity</tt><a name="const*mosek*callbackcode*im-dual-sensivity">&#09;</a><a name="common-const*mosek*callbackcode*im-dual-sensivity"></a> 
<br/>The call-back function is called at an intermediate stage of the dual sensitivity analysis. </li>
<li><tt class="tt">mosek.callbackcode.im_dual_simplex</tt><a name="const*mosek*callbackcode*im-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*im-dual-simplex"></a> 
<br/>The call-back function is called at an intermediate point in the dual simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.im_full_convexity_check</tt><a name="const*mosek*callbackcode*im-full-convexity-check">&#09;</a><a name="common-const*mosek*callbackcode*im-full-convexity-check"></a> 
<br/>The call-back function is called at an intermediate stage of the full convexity check. </li>
<li><tt class="tt">mosek.callbackcode.im_intpnt</tt><a name="const*mosek*callbackcode*im-intpnt">&#09;</a><a name="common-const*mosek*callbackcode*im-intpnt"></a> 
<br/>The call-back function is called at an intermediate stage within the interior-point optimizer where the information database has not been updated. </li>
<li><tt class="tt">mosek.callbackcode.im_license_wait</tt><a name="const*mosek*callbackcode*im-license-wait">&#09;</a><a name="common-const*mosek*callbackcode*im-license-wait"></a> 
<br/>MOSEK is waiting for a license. </li>
<li><tt class="tt">mosek.callbackcode.im_lu</tt><a name="const*mosek*callbackcode*im-lu">&#09;</a><a name="common-const*mosek*callbackcode*im-lu"></a> 
<br/>The call-back function is called from within the LU factorization procedure at an intermediate point. </li>
<li><tt class="tt">mosek.callbackcode.im_mio</tt><a name="const*mosek*callbackcode*im-mio">&#09;</a><a name="common-const*mosek*callbackcode*im-mio"></a> 
<br/>The call-back function is called at an intermediate point in the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.callbackcode.im_mio_dual_simplex</tt><a name="const*mosek*callbackcode*im-mio-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*im-mio-dual-simplex"></a> 
<br/>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the dual simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.im_mio_intpnt</tt><a name="const*mosek*callbackcode*im-mio-intpnt">&#09;</a><a name="common-const*mosek*callbackcode*im-mio-intpnt"></a> 
<br/>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the interior-point optimizer. </li>
<li><tt class="tt">mosek.callbackcode.im_mio_presolve</tt><a name="const*mosek*callbackcode*im-mio-presolve">&#09;</a><a name="common-const*mosek*callbackcode*im-mio-presolve"></a> 
<br/>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the presolve. </li>
<li><tt class="tt">mosek.callbackcode.im_mio_primal_simplex</tt><a name="const*mosek*callbackcode*im-mio-primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*im-mio-primal-simplex"></a> 
<br/>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the primal simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.im_network_dual_simplex</tt><a name="const*mosek*callbackcode*im-network-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*im-network-dual-simplex"></a> 
<br/>The call-back function is called at an intermediate point in the dual network simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.im_network_primal_simplex</tt><a name="const*mosek*callbackcode*im-network-primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*im-network-primal-simplex"></a> 
<br/>The call-back function is called at an intermediate point in the primal network simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.im_nonconvex</tt><a name="const*mosek*callbackcode*im-nonconvex">&#09;</a><a name="common-const*mosek*callbackcode*im-nonconvex"></a> 
<br/>The call-back function is called at an intermediate stage within the nonconvex optimizer where the information database has not been updated. </li>
<li><tt class="tt">mosek.callbackcode.im_order</tt><a name="const*mosek*callbackcode*im-order">&#09;</a><a name="common-const*mosek*callbackcode*im-order"></a> 
<br/>The call-back function is called from within the matrix ordering procedure at an intermediate point. </li>
<li><tt class="tt">mosek.callbackcode.im_presolve</tt><a name="const*mosek*callbackcode*im-presolve">&#09;</a><a name="common-const*mosek*callbackcode*im-presolve"></a> 
<br/>The call-back function is called from within the presolve procedure at an intermediate stage. </li>
<li><tt class="tt">mosek.callbackcode.im_primal_bi</tt><a name="const*mosek*callbackcode*im-primal-bi">&#09;</a><a name="common-const*mosek*callbackcode*im-primal-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure at an intermediate point in the primal phase. </li>
<li><tt class="tt">mosek.callbackcode.im_primal_dual_simplex</tt><a name="const*mosek*callbackcode*im-primal-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*im-primal-dual-simplex"></a> 
<br/>The call-back function is called at an intermediate point in the primal-dual simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.im_primal_sensivity</tt><a name="const*mosek*callbackcode*im-primal-sensivity">&#09;</a><a name="common-const*mosek*callbackcode*im-primal-sensivity"></a> 
<br/>The call-back function is called at an intermediate stage of the primal sensitivity analysis. </li>
<li><tt class="tt">mosek.callbackcode.im_primal_simplex</tt><a name="const*mosek*callbackcode*im-primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*im-primal-simplex"></a> 
<br/>The call-back function is called at an intermediate point in the primal simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.im_qo_reformulate</tt><a name="const*mosek*callbackcode*im-qo-reformulate">&#09;</a><a name="common-const*mosek*callbackcode*im-qo-reformulate"></a> 
<br/>The call-back function is called at an intermediate stage of the QP to SOCP reformulation. </li>
<li><tt class="tt">mosek.callbackcode.im_simplex</tt><a name="const*mosek*callbackcode*im-simplex">&#09;</a><a name="common-const*mosek*callbackcode*im-simplex"></a> 
<br/>The call-back function is called from within the simplex optimizer at an intermediate point. </li>
<li><tt class="tt">mosek.callbackcode.im_simplex_bi</tt><a name="const*mosek*callbackcode*im-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*im-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure at an intermediate point in the simplex clean-up phase. The frequency of the call-backs is controlled by the <a href="node017.html#common-const*mosek*iparam*log-sim-freq"><tt class="tt">mosek.iparam.log_sim_freq</tt></a> parameter. </li>
<li><tt class="tt">mosek.callbackcode.intpnt</tt><a name="const*mosek*callbackcode*intpnt">&#09;</a><a name="common-const*mosek*callbackcode*intpnt"></a> 
<br/>The call-back function is called from within the interior-point optimizer after the information database has been updated. </li>
<li><tt class="tt">mosek.callbackcode.new_int_mio</tt><a name="const*mosek*callbackcode*new-int-mio">&#09;</a><a name="common-const*mosek*callbackcode*new-int-mio"></a> 
<br/>The call-back function is called after a new integer solution has been located by the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.callbackcode.noncovex</tt><a name="const*mosek*callbackcode*noncovex">&#09;</a><a name="common-const*mosek*callbackcode*noncovex"></a> 
<br/>The call-back function is called from within the nonconvex optimizer after the information database has been updated. </li>
<li><tt class="tt">mosek.callbackcode.primal_simplex</tt><a name="const*mosek*callbackcode*primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*primal-simplex"></a> 
<br/>The call-back function is called from within the primal simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.qcone</tt><a name="const*mosek*callbackcode*qcone">&#09;</a><a name="common-const*mosek*callbackcode*qcone"></a> 
<br/>The call-back function is called from within the Qcone optimizer. </li>
<li><tt class="tt">mosek.callbackcode.read_add_anz</tt><a name="const*mosek*callbackcode*read-add-anz">&#09;</a><a name="common-const*mosek*callbackcode*read-add-anz"></a> 
<br/>A chunk of <span class="math"><span class="mi">A</span></span> non-zeos has been read from a problem file. </li>
<li><tt class="tt">mosek.callbackcode.read_add_cones</tt><a name="const*mosek*callbackcode*read-add-cones">&#09;</a><a name="common-const*mosek*callbackcode*read-add-cones"></a> 
<br/>A chunk of cones has been read from a problem file. </li>
<li><tt class="tt">mosek.callbackcode.read_add_cons</tt><a name="const*mosek*callbackcode*read-add-cons">&#09;</a><a name="common-const*mosek*callbackcode*read-add-cons"></a> 
<br/>A chunk of constraints has been read from a problem file. </li>
<li><tt class="tt">mosek.callbackcode.read_add_qnz</tt><a name="const*mosek*callbackcode*read-add-qnz">&#09;</a><a name="common-const*mosek*callbackcode*read-add-qnz"></a> 
<br/>A chunk of <span class="math"><span class="mi">Q</span></span> non-zeos has been read from a problem file. </li>
<li><tt class="tt">mosek.callbackcode.read_add_vars</tt><a name="const*mosek*callbackcode*read-add-vars">&#09;</a><a name="common-const*mosek*callbackcode*read-add-vars"></a> 
<br/>A chunk of variables has been read from a problem file. </li>
<li><tt class="tt">mosek.callbackcode.read_opf</tt><a name="const*mosek*callbackcode*read-opf">&#09;</a><a name="common-const*mosek*callbackcode*read-opf"></a> 
<br/>The call-back function is called from the OPF reader. </li>
<li><tt class="tt">mosek.callbackcode.read_opf_section</tt><a name="const*mosek*callbackcode*read-opf-section">&#09;</a><a name="common-const*mosek*callbackcode*read-opf-section"></a> 
<br/>A chunk of <span class="math"><span class="mi">Q</span></span> non-zeos has been read from a problem file. </li>
<li><tt class="tt">mosek.callbackcode.update_dual_bi</tt><a name="const*mosek*callbackcode*update-dual-bi">&#09;</a><a name="common-const*mosek*callbackcode*update-dual-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure at an intermediate point in the dual phase. </li>
<li><tt class="tt">mosek.callbackcode.update_dual_simplex</tt><a name="const*mosek*callbackcode*update-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*update-dual-simplex"></a> 
<br/>The call-back function is called in the dual simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.update_dual_simplex_bi</tt><a name="const*mosek*callbackcode*update-dual-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*update-dual-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure at an intermediate point in the dual simplex clean-up phase. The frequency of the call-backs is controlled by the <a href="node017.html#common-const*mosek*iparam*log-sim-freq"><tt class="tt">mosek.iparam.log_sim_freq</tt></a> parameter. </li>
<li><tt class="tt">mosek.callbackcode.update_network_dual_simplex</tt><a name="const*mosek*callbackcode*update-network-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*update-network-dual-simplex"></a> 
<br/>The call-back function is called in the dual network simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.update_network_primal_simplex</tt><a name="const*mosek*callbackcode*update-network-primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*update-network-primal-simplex"></a> 
<br/>The call-back function is called in the primal network simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.update_nonconvex</tt><a name="const*mosek*callbackcode*update-nonconvex">&#09;</a><a name="common-const*mosek*callbackcode*update-nonconvex"></a> 
<br/>The call-back function is called at an intermediate stage within the nonconvex optimizer where the information database has been updated. </li>
<li><tt class="tt">mosek.callbackcode.update_presolve</tt><a name="const*mosek*callbackcode*update-presolve">&#09;</a><a name="common-const*mosek*callbackcode*update-presolve"></a> 
<br/>The call-back function is called from within the presolve procedure. </li>
<li><tt class="tt">mosek.callbackcode.update_primal_bi</tt><a name="const*mosek*callbackcode*update-primal-bi">&#09;</a><a name="common-const*mosek*callbackcode*update-primal-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure at an intermediate point in the primal phase. </li>
<li><tt class="tt">mosek.callbackcode.update_primal_dual_simplex</tt><a name="const*mosek*callbackcode*update-primal-dual-simplex">&#09;</a><a name="common-const*mosek*callbackcode*update-primal-dual-simplex"></a> 
<br/>The call-back function is called in the primal-dual simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.update_primal_dual_simplex_bi</tt><a name="const*mosek*callbackcode*update-primal-dual-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*update-primal-dual-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure at an intermediate point in the primal-dual simplex clean-up phase. The frequency of the call-backs is controlled by the <a href="node017.html#common-const*mosek*iparam*log-sim-freq"><tt class="tt">mosek.iparam.log_sim_freq</tt></a> parameter. </li>
<li><tt class="tt">mosek.callbackcode.update_primal_simplex</tt><a name="const*mosek*callbackcode*update-primal-simplex">&#09;</a><a name="common-const*mosek*callbackcode*update-primal-simplex"></a> 
<br/>The call-back function is called in the primal simplex optimizer. </li>
<li><tt class="tt">mosek.callbackcode.update_primal_simplex_bi</tt><a name="const*mosek*callbackcode*update-primal-simplex-bi">&#09;</a><a name="common-const*mosek*callbackcode*update-primal-simplex-bi"></a> 
<br/>The call-back function is called from within the basis identification procedure at an intermediate point in the primal simplex clean-up phase. The frequency of the call-backs is controlled by the <a href="node017.html#common-const*mosek*iparam*log-sim-freq"><tt class="tt">mosek.iparam.log_sim_freq</tt></a> parameter. </li>
<li><tt class="tt">mosek.callbackcode.write_opf</tt><a name="const*mosek*callbackcode*write-opf">&#09;</a><a name="common-const*mosek*callbackcode*write-opf"></a> 
<br/>The call-back function is called from the OPF writer. </li>
</ul>

</div>

<div>
<h1><a name="249904952">17.8. Types of convexity checks.</a></h1>

<p> <a name="constclass*mosek*checkconvexitytype">&#09;</a><a name="common-constclass*mosek*checkconvexitytype"></a> <a name="idx-171304000">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.checkconvexitytype.full</tt><a name="const*mosek*checkconvexitytype*full">&#09;</a><a name="common-const*mosek*checkconvexitytype*full"></a> 
<br/>Perform a full convexity check. </li>
<li><tt class="tt">mosek.checkconvexitytype.none</tt><a name="const*mosek*checkconvexitytype*none">&#09;</a><a name="common-const*mosek*checkconvexitytype*none"></a> 
<br/>No convexity check. </li>
<li><tt class="tt">mosek.checkconvexitytype.simple</tt><a name="const*mosek*checkconvexitytype*simple">&#09;</a><a name="common-const*mosek*checkconvexitytype*simple"></a> 
<br/>Perform simple and fast convexity check. </li>
</ul>

</div>

<div>
<h1><a name="249907608">17.9. Compression types</a></h1>

<p> <a name="constclass*mosek*compresstype">&#09;</a><a name="common-constclass*mosek*compresstype"></a> <a name="idx-171315928">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.compresstype.free</tt><a name="const*mosek*compresstype*free">&#09;</a><a name="common-const*mosek*compresstype*free"></a> 
<br/>The type of compression used is chosen automatically. </li>
<li><tt class="tt">mosek.compresstype.gzip</tt><a name="const*mosek*compresstype*gzip">&#09;</a><a name="common-const*mosek*compresstype*gzip"></a> 
<br/>The type of compression used is gzip compatible. </li>
<li><tt class="tt">mosek.compresstype.none</tt><a name="const*mosek*compresstype*none">&#09;</a><a name="common-const*mosek*compresstype*none"></a> 
<br/>No compression is used. </li>
</ul>

</div>

<div>
<h1><a name="249910264">17.10. Cone types</a></h1>

<p> <a name="constclass*mosek*conetype">&#09;</a><a name="common-constclass*mosek*conetype"></a> <a name="idx-171332888">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.conetype.quad</tt><a name="const*mosek*conetype*quad">&#09;</a><a name="common-const*mosek*conetype*quad"></a> 
<br/>The cone is a quadratic cone. </li>
<li><tt class="tt">mosek.conetype.rquad</tt><a name="const*mosek*conetype*rquad">&#09;</a><a name="common-const*mosek*conetype*rquad"></a> 
<br/>The cone is a rotated quadratic cone. </li>
</ul>

</div>

<div>
<h1><a name="249912208">17.11. CPU type</a></h1>

<p> <a name="constclass*mosek*cputype">&#09;</a><a name="common-constclass*mosek*cputype"></a> <a name="idx-171329800">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.cputype.amd_athlon</tt><a name="const*mosek*cputype*amd-athlon">&#09;</a><a name="common-const*mosek*cputype*amd-athlon"></a> 
<br/>An AMD Athlon. </li>
<li><tt class="tt">mosek.cputype.amd_opteron</tt><a name="const*mosek*cputype*amd-opteron">&#09;</a><a name="common-const*mosek*cputype*amd-opteron"></a> 
<br/>An AMD Opteron (64 bit). </li>
<li><tt class="tt">mosek.cputype.generic</tt><a name="const*mosek*cputype*generic">&#09;</a><a name="common-const*mosek*cputype*generic"></a> 
<br/>An generic CPU type for the platform </li>
<li><tt class="tt">mosek.cputype.hp_parisc20</tt><a name="const*mosek*cputype*hp-parisc20">&#09;</a><a name="common-const*mosek*cputype*hp-parisc20"></a> 
<br/>An HP PA RISC version 2.0 CPU. </li>
<li><tt class="tt">mosek.cputype.intel_core2</tt><a name="const*mosek*cputype*intel-core2">&#09;</a><a name="common-const*mosek*cputype*intel-core2"></a> 
<br/>An Intel CORE2 cpu. </li>
<li><tt class="tt">mosek.cputype.intel_itanium2</tt><a name="const*mosek*cputype*intel-itanium2">&#09;</a><a name="common-const*mosek*cputype*intel-itanium2"></a> 
<br/>An Intel Itanium2. </li>
<li><tt class="tt">mosek.cputype.intel_p3</tt><a name="const*mosek*cputype*intel-p3">&#09;</a><a name="common-const*mosek*cputype*intel-p3"></a> 
<br/>An Intel Pentium P3. </li>
<li><tt class="tt">mosek.cputype.intel_p4</tt><a name="const*mosek*cputype*intel-p4">&#09;</a><a name="common-const*mosek*cputype*intel-p4"></a> 
<br/>An Intel Pentium P4 or Intel Xeon. </li>
<li><tt class="tt">mosek.cputype.intel_pm</tt><a name="const*mosek*cputype*intel-pm">&#09;</a><a name="common-const*mosek*cputype*intel-pm"></a> 
<br/>An Intel PM cpu. </li>
<li><tt class="tt">mosek.cputype.powerpc_g5</tt><a name="const*mosek*cputype*powerpc-g5">&#09;</a><a name="common-const*mosek*cputype*powerpc-g5"></a> 
<br/>A G5 PowerPC CPU. </li>
<li><tt class="tt">mosek.cputype.unknown</tt><a name="const*mosek*cputype*unknown">&#09;</a><a name="common-const*mosek*cputype*unknown"></a> 
<br/>An unknown CPU. </li>
</ul>

</div>

<div>
<h1><a name="249920112">17.12. Data format types</a></h1>

<p> <a name="constclass*mosek*dataformat">&#09;</a><a name="common-constclass*mosek*dataformat"></a> <a name="idx-171383264">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.dataformat.extension</tt><a name="const*mosek*dataformat*extension">&#09;</a><a name="common-const*mosek*dataformat*extension"></a> 
<br/>The file extension is used to determine the data file format. </li>
<li><tt class="tt">mosek.dataformat.free_mps</tt><a name="const*mosek*dataformat*free-mps">&#09;</a><a name="common-const*mosek*dataformat*free-mps"></a> 
<br/>The data data a free MPS formatted file. </li>
<li><tt class="tt">mosek.dataformat.lp</tt><a name="const*mosek*dataformat*lp">&#09;</a><a name="common-const*mosek*dataformat*lp"></a> 
<br/>The data file is LP formatted. </li>
<li><tt class="tt">mosek.dataformat.mbt</tt><a name="const*mosek*dataformat*mbt">&#09;</a><a name="common-const*mosek*dataformat*mbt"></a> 
<br/>The data file is a MOSEK binary task file. </li>
<li><tt class="tt">mosek.dataformat.mps</tt><a name="const*mosek*dataformat*mps">&#09;</a><a name="common-const*mosek*dataformat*mps"></a> 
<br/>The data file is MPS formatted. </li>
<li><tt class="tt">mosek.dataformat.op</tt><a name="const*mosek*dataformat*op">&#09;</a><a name="common-const*mosek*dataformat*op"></a> 
<br/>The data file is an optimization problem formatted file. </li>
<li><tt class="tt">mosek.dataformat.xml</tt><a name="const*mosek*dataformat*xml">&#09;</a><a name="common-const*mosek*dataformat*xml"></a> 
<br/>The data file is an XML formatted file. </li>
</ul>

</div>

<div>
<h1><a name="249925360">17.13. Double information items</a></h1>

<p> <a name="constclass*mosek*dinfitem">&#09;</a><a name="common-constclass*mosek*dinfitem"></a> <a name="idx-171410928">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.dinfitem.bi_clean_dual_time</tt><a name="const*mosek*dinfitem*bi-clean-dual-time">&#09;</a><a name="common-const*mosek*dinfitem*bi-clean-dual-time"></a> 
<br/>Time spent within the dual clean-up optimizer of the basis identification procedure since its invocation. </li>
<li><tt class="tt">mosek.dinfitem.bi_clean_primal_dual_time</tt><a name="const*mosek*dinfitem*bi-clean-primal-dual-time">&#09;</a><a name="common-const*mosek*dinfitem*bi-clean-primal-dual-time"></a> 
<br/>Time spent within the primal-dual clean-up optimizer of the basis identification procedure since its invocation. </li>
<li><tt class="tt">mosek.dinfitem.bi_clean_primal_time</tt><a name="const*mosek*dinfitem*bi-clean-primal-time">&#09;</a><a name="common-const*mosek*dinfitem*bi-clean-primal-time"></a> 
<br/>Time spent within the primal clean-up optimizer of the basis identification procedure since its invocation. </li>
<li><tt class="tt">mosek.dinfitem.bi_clean_time</tt><a name="const*mosek*dinfitem*bi-clean-time">&#09;</a><a name="common-const*mosek*dinfitem*bi-clean-time"></a> 
<br/>Time spent within the clean-up phase of the basis identification procedure since its invocation. </li>
<li><tt class="tt">mosek.dinfitem.bi_dual_time</tt><a name="const*mosek*dinfitem*bi-dual-time">&#09;</a><a name="common-const*mosek*dinfitem*bi-dual-time"></a> 
<br/>Time spent within the dual phase basis identification procedure since its invocation. </li>
<li><tt class="tt">mosek.dinfitem.bi_primal_time</tt><a name="const*mosek*dinfitem*bi-primal-time">&#09;</a><a name="common-const*mosek*dinfitem*bi-primal-time"></a> 
<br/>Time spent within the primal phase of the basis identification procedure since its invocation. </li>
<li><tt class="tt">mosek.dinfitem.bi_time</tt><a name="const*mosek*dinfitem*bi-time">&#09;</a><a name="common-const*mosek*dinfitem*bi-time"></a> 
<br/>Time spent within the basis identification procedure since its invocation. </li>
<li><tt class="tt">mosek.dinfitem.concurrent_time</tt><a name="const*mosek*dinfitem*concurrent-time">&#09;</a><a name="common-const*mosek*dinfitem*concurrent-time"></a> 
<br/>Time spent within the concurrent optimizer since its invocation. </li>
<li><tt class="tt">mosek.dinfitem.intpnt_dual_feas</tt><a name="const*mosek*dinfitem*intpnt-dual-feas">&#09;</a><a name="common-const*mosek*dinfitem*intpnt-dual-feas"></a> 
<br/>Dual feasibility measure reported by the interior-point and Qcone optimizer. (For the interior-point optimizer this measure does not directly related to the original problem because a homogeneous model is employed.) </li>
<li><tt class="tt">mosek.dinfitem.intpnt_dual_obj</tt><a name="const*mosek*dinfitem*intpnt-dual-obj">&#09;</a><a name="common-const*mosek*dinfitem*intpnt-dual-obj"></a> 
<br/>Dual objective value reported by the interior-point or Qcone optimizer. </li>
<li><tt class="tt">mosek.dinfitem.intpnt_factor_num_flops</tt><a name="const*mosek*dinfitem*intpnt-factor-num-flops">&#09;</a><a name="common-const*mosek*dinfitem*intpnt-factor-num-flops"></a> 
<br/>An estimate of the number of flops used in the factorization. </li>
<li><tt class="tt">mosek.dinfitem.intpnt_kap_div_tau</tt><a name="const*mosek*dinfitem*intpnt-kap-div-tau">&#09;</a><a name="common-const*mosek*dinfitem*intpnt-kap-div-tau"></a> 
<br/>This measure should converge to zero if the problem has a primal-dual optimal solution or to infinity if problem is (strictly) primal or dual infeasible. In case the measure is converging towards a positive but bounded constant the problem is usually ill-posed. </li>
<li><tt class="tt">mosek.dinfitem.intpnt_order_time</tt><a name="const*mosek*dinfitem*intpnt-order-time">&#09;</a><a name="common-const*mosek*dinfitem*intpnt-order-time"></a> 
<br/>Order time (in seconds). </li>
<li><tt class="tt">mosek.dinfitem.intpnt_primal_feas</tt><a name="const*mosek*dinfitem*intpnt-primal-feas">&#09;</a><a name="common-const*mosek*dinfitem*intpnt-primal-feas"></a> 
<br/>Primal feasibility measure reported by the interior-point or Qcone optimizers. (For the interior-point optimizer this measure does not directly related to the original problem because a homogeneous model is employed). </li>
<li><tt class="tt">mosek.dinfitem.intpnt_primal_obj</tt><a name="const*mosek*dinfitem*intpnt-primal-obj">&#09;</a><a name="common-const*mosek*dinfitem*intpnt-primal-obj"></a> 
<br/>Primal objective value reported by the interior-point or Qcone optimizer. </li>
<li><tt class="tt">mosek.dinfitem.intpnt_time</tt><a name="const*mosek*dinfitem*intpnt-time">&#09;</a><a name="common-const*mosek*dinfitem*intpnt-time"></a> 
<br/>Time spent within the interior-point optimizer since its invocation. </li>
<li><tt class="tt">mosek.dinfitem.mio_construct_solution_obj</tt><a name="const*mosek*dinfitem*mio-construct-solution-obj">&#09;</a><a name="common-const*mosek*dinfitem*mio-construct-solution-obj"></a> 
<br/>If MOSEK has successfully constructed an integer feasible solution, then this item contains the optimal objective value corresponding to the feasible solution. </li>
<li><tt class="tt">mosek.dinfitem.mio_heuristic_time</tt><a name="const*mosek*dinfitem*mio-heuristic-time">&#09;</a><a name="common-const*mosek*dinfitem*mio-heuristic-time"></a> 
<br/>Time spent in the optimizer while solving the relaxtions. </li>
<li>
<p><tt class="tt">mosek.dinfitem.mio_obj_abs_gap</tt><a name="const*mosek*dinfitem*mio-obj-abs-gap">&#09;</a><a name="common-const*mosek*dinfitem*mio-obj-abs-gap"></a> 
<br/>Given the mixed-integer optimizer has computed a feasible solution and a bound on the optimal objective value, then this item contains the absolute gap defined by </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math880.png" alt="\begin{displaymath}\nonumber{}|\mbox{(objective value of feasible solution)}-\mbox{(objective bound)}|.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>Otherwise it has the value -1.0. </p>
</li>
<li><tt class="tt">mosek.dinfitem.mio_obj_bound</tt><a name="const*mosek*dinfitem*mio-obj-bound">&#09;</a><a name="common-const*mosek*dinfitem*mio-obj-bound"></a> 
<br/>The best known bound on the objective function. This value is undefined until at least one relaxation has been solved: To see if this is the case check that <a href="node019.html#common-const*mosek*iinfitem*mio-num-relax"><tt class="tt">mosek.iinfitem.mio_num_relax</tt></a> is stricly positive. </li>
<li><tt class="tt">mosek.dinfitem.mio_obj_int</tt><a name="const*mosek*dinfitem*mio-obj-int">&#09;</a><a name="common-const*mosek*dinfitem*mio-obj-int"></a> 
<br/>The primal objective value corresponding to the best integer feasible solution. Please note that at least one integer feasible solution must have located i.e. check <a href="node019.html#common-const*mosek*iinfitem*mio-num-int-solutions"><tt class="tt">mosek.iinfitem.mio_num_int_solutions</tt></a>. </li>
<li>
<p><tt class="tt">mosek.dinfitem.mio_obj_rel_gap</tt><a name="const*mosek*dinfitem*mio-obj-rel-gap">&#09;</a><a name="common-const*mosek*dinfitem*mio-obj-rel-gap"></a> 
<br/>Given that the mixed-integer optimizer has computed a feasible solution and a bound on the optimal objective value, then this item contains the relative gap defined by </p>

<table width="100%" class="displaymath" border="0">
<tbody><tr>
<td width="100%" align="center"><img src="math/math881.png" alt="\begin{displaymath}\nonumber{}\frac{|\mbox{(objective value of feasible solution)}-\mbox{(objective bound)}|}{\max (\delta ,|\mbox{(objective value of feasible solution)}|)}.\end{displaymath}"/></td></tr>
</tbody>
</table>

<p>where <span class="math"><img src="math/math435.png" alt="[[MathCmd 435]]"/></span> is given by the paramater <a href="node017.html#common-const*mosek*dparam*mio-rel-gap-const"><tt class="tt">mosek.dparam.mio_rel_gap_const</tt></a>. Otherwise it has the value -1.0. </p>
</li>
<li><tt class="tt">mosek.dinfitem.mio_optimizer_time</tt><a name="const*mosek*dinfitem*mio-optimizer-time">&#09;</a><a name="common-const*mosek*dinfitem*mio-optimizer-time"></a> 
<br/>Time spent in the optimizer while solving the relaxtions. </li>
<li><tt class="tt">mosek.dinfitem.mio_root_optimizer_time</tt><a name="const*mosek*dinfitem*mio-root-optimizer-time">&#09;</a><a name="common-const*mosek*dinfitem*mio-root-optimizer-time"></a> 
<br/>Time spent in the optimizer while solving the root relaxation. </li>
<li><tt class="tt">mosek.dinfitem.mio_root_presolve_time</tt><a name="const*mosek*dinfitem*mio-root-presolve-time">&#09;</a><a name="common-const*mosek*dinfitem*mio-root-presolve-time"></a> 
<br/>Time spent in while presolveing the root relaxation. </li>
<li><tt class="tt">mosek.dinfitem.mio_time</tt><a name="const*mosek*dinfitem*mio-time">&#09;</a><a name="common-const*mosek*dinfitem*mio-time"></a> 
<br/>Time spent in the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.dinfitem.mio_user_obj_cut</tt><a name="const*mosek*dinfitem*mio-user-obj-cut">&#09;</a><a name="common-const*mosek*dinfitem*mio-user-obj-cut"></a> 
<br/>If the objective cut is used, then this information item has the value of the cut. </li>
<li><tt class="tt">mosek.dinfitem.optimizer_time</tt><a name="const*mosek*dinfitem*optimizer-time">&#09;</a><a name="common-const*mosek*dinfitem*optimizer-time"></a> 
<br/>Total time spent in the optimizer since it was invoked. </li>
<li><tt class="tt">mosek.dinfitem.presolve_eli_time</tt><a name="const*mosek*dinfitem*presolve-eli-time">&#09;</a><a name="common-const*mosek*dinfitem*presolve-eli-time"></a> 
<br/>Total time spent in the eliminator since the presolve was invoked. </li>
<li><tt class="tt">mosek.dinfitem.presolve_lindep_time</tt><a name="const*mosek*dinfitem*presolve-lindep-time">&#09;</a><a name="common-const*mosek*dinfitem*presolve-lindep-time"></a> 
<br/>Total time spent in the linear dependency checker since the presolve was invoked. </li>
<li><tt class="tt">mosek.dinfitem.presolve_time</tt><a name="const*mosek*dinfitem*presolve-time">&#09;</a><a name="common-const*mosek*dinfitem*presolve-time"></a> 
<br/>Total time (in seconds) spent in the presolve since it was invoked. </li>
<li><tt class="tt">mosek.dinfitem.qcqo_reformulate_time</tt><a name="const*mosek*dinfitem*qcqo-reformulate-time">&#09;</a><a name="common-const*mosek*dinfitem*qcqo-reformulate-time"></a> 
<br/>Time spent with QP reformulation. </li>
<li><tt class="tt">mosek.dinfitem.rd_time</tt><a name="const*mosek*dinfitem*rd-time">&#09;</a><a name="common-const*mosek*dinfitem*rd-time"></a> 
<br/>Time spent reading the data file. </li>
<li><tt class="tt">mosek.dinfitem.sim_dual_time</tt><a name="const*mosek*dinfitem*sim-dual-time">&#09;</a><a name="common-const*mosek*dinfitem*sim-dual-time"></a> 
<br/>Time spent in the dual simplex optimizer since invoking it. </li>
<li><tt class="tt">mosek.dinfitem.sim_feas</tt><a name="const*mosek*dinfitem*sim-feas">&#09;</a><a name="common-const*mosek*dinfitem*sim-feas"></a> 
<br/>Feasibility measure reported by the simplex optimizer. </li>
<li><tt class="tt">mosek.dinfitem.sim_network_dual_time</tt><a name="const*mosek*dinfitem*sim-network-dual-time">&#09;</a><a name="common-const*mosek*dinfitem*sim-network-dual-time"></a> 
<br/>Time spent in the dual network simplex optimizer since invoking it. </li>
<li><tt class="tt">mosek.dinfitem.sim_network_primal_time</tt><a name="const*mosek*dinfitem*sim-network-primal-time">&#09;</a><a name="common-const*mosek*dinfitem*sim-network-primal-time"></a> 
<br/>Time spent in the primal network simplex optimizer since invoking it. </li>
<li><tt class="tt">mosek.dinfitem.sim_network_time</tt><a name="const*mosek*dinfitem*sim-network-time">&#09;</a><a name="common-const*mosek*dinfitem*sim-network-time"></a> 
<br/>Time spent in the network simplex optimizer since invoking it. </li>
<li><tt class="tt">mosek.dinfitem.sim_obj</tt><a name="const*mosek*dinfitem*sim-obj">&#09;</a><a name="common-const*mosek*dinfitem*sim-obj"></a> 
<br/>Objective value reported by the simplex optimizer. </li>
<li><tt class="tt">mosek.dinfitem.sim_primal_dual_time</tt><a name="const*mosek*dinfitem*sim-primal-dual-time">&#09;</a><a name="common-const*mosek*dinfitem*sim-primal-dual-time"></a> 
<br/>Time spent in the primal-dual simplex optimizer optimizer since invoking it. </li>
<li><tt class="tt">mosek.dinfitem.sim_primal_time</tt><a name="const*mosek*dinfitem*sim-primal-time">&#09;</a><a name="common-const*mosek*dinfitem*sim-primal-time"></a> 
<br/>Time spent in the primal simplex optimizer since invoking it. </li>
<li><tt class="tt">mosek.dinfitem.sim_time</tt><a name="const*mosek*dinfitem*sim-time">&#09;</a><a name="common-const*mosek*dinfitem*sim-time"></a> 
<br/>Time spent in the simplex optimizer since invoking it. </li>
<li><tt class="tt">mosek.dinfitem.sol_bas_dual_obj</tt><a name="const*mosek*dinfitem*sol-bas-dual-obj">&#09;</a><a name="common-const*mosek*dinfitem*sol-bas-dual-obj"></a> 
<br/>Dual objective value of the basic solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_bas_max_dbi</tt><a name="const*mosek*dinfitem*sol-bas-max-dbi">&#09;</a><a name="common-const*mosek*dinfitem*sol-bas-max-dbi"></a> 
<br/>Maximal dual bound infeasibility in the basic solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_bas_max_deqi</tt><a name="const*mosek*dinfitem*sol-bas-max-deqi">&#09;</a><a name="common-const*mosek*dinfitem*sol-bas-max-deqi"></a> 
<br/>Maximal dual equality infeasibility in the basic solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_bas_max_pbi</tt><a name="const*mosek*dinfitem*sol-bas-max-pbi">&#09;</a><a name="common-const*mosek*dinfitem*sol-bas-max-pbi"></a> 
<br/>Maximal primal bound infeasibility in the basic solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_bas_max_peqi</tt><a name="const*mosek*dinfitem*sol-bas-max-peqi">&#09;</a><a name="common-const*mosek*dinfitem*sol-bas-max-peqi"></a> 
<br/>Maximal primal equality infeasibility in the basic solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_bas_max_pinti</tt><a name="const*mosek*dinfitem*sol-bas-max-pinti">&#09;</a><a name="common-const*mosek*dinfitem*sol-bas-max-pinti"></a> 
<br/>Maximal primal integer infeasibility in the basic solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_bas_primal_obj</tt><a name="const*mosek*dinfitem*sol-bas-primal-obj">&#09;</a><a name="common-const*mosek*dinfitem*sol-bas-primal-obj"></a> 
<br/>Primal objective value of the basic solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_int_max_pbi</tt><a name="const*mosek*dinfitem*sol-int-max-pbi">&#09;</a><a name="common-const*mosek*dinfitem*sol-int-max-pbi"></a> 
<br/>Maximal primal bound infeasibility in the integer solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_int_max_peqi</tt><a name="const*mosek*dinfitem*sol-int-max-peqi">&#09;</a><a name="common-const*mosek*dinfitem*sol-int-max-peqi"></a> 
<br/>Maximal primal equality infeasibility in the basic solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_int_max_pinti</tt><a name="const*mosek*dinfitem*sol-int-max-pinti">&#09;</a><a name="common-const*mosek*dinfitem*sol-int-max-pinti"></a> 
<br/>Maximal primal integer infeasibility in the integer solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_int_primal_obj</tt><a name="const*mosek*dinfitem*sol-int-primal-obj">&#09;</a><a name="common-const*mosek*dinfitem*sol-int-primal-obj"></a> 
<br/>Primal objective value of the integer solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_itr_dual_obj</tt><a name="const*mosek*dinfitem*sol-itr-dual-obj">&#09;</a><a name="common-const*mosek*dinfitem*sol-itr-dual-obj"></a> 
<br/>Dual objective value of the interior-point solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_itr_max_dbi</tt><a name="const*mosek*dinfitem*sol-itr-max-dbi">&#09;</a><a name="common-const*mosek*dinfitem*sol-itr-max-dbi"></a> 
<br/>Maximal dual bound infeasibility in the interior-point solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_itr_max_dcni</tt><a name="const*mosek*dinfitem*sol-itr-max-dcni">&#09;</a><a name="common-const*mosek*dinfitem*sol-itr-max-dcni"></a> 
<br/>Maximal dual cone infeasibility in the interior-point solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_itr_max_deqi</tt><a name="const*mosek*dinfitem*sol-itr-max-deqi">&#09;</a><a name="common-const*mosek*dinfitem*sol-itr-max-deqi"></a> 
<br/>Maximal dual equality infeasibility in the interior-point solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_itr_max_pbi</tt><a name="const*mosek*dinfitem*sol-itr-max-pbi">&#09;</a><a name="common-const*mosek*dinfitem*sol-itr-max-pbi"></a> 
<br/>Maximal primal bound infeasibility in the interior-point solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_itr_max_pcni</tt><a name="const*mosek*dinfitem*sol-itr-max-pcni">&#09;</a><a name="common-const*mosek*dinfitem*sol-itr-max-pcni"></a> 
<br/>Maximal primal cone infeasibility in the interior-point solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_itr_max_peqi</tt><a name="const*mosek*dinfitem*sol-itr-max-peqi">&#09;</a><a name="common-const*mosek*dinfitem*sol-itr-max-peqi"></a> 
<br/>Maximal primal equality infeasibility in the interior-point solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_itr_max_pinti</tt><a name="const*mosek*dinfitem*sol-itr-max-pinti">&#09;</a><a name="common-const*mosek*dinfitem*sol-itr-max-pinti"></a> 
<br/>Maximal primal integer infeasibility in the interior-point solution. Updated at the end of the optimization. </li>
<li><tt class="tt">mosek.dinfitem.sol_itr_primal_obj</tt><a name="const*mosek*dinfitem*sol-itr-primal-obj">&#09;</a><a name="common-const*mosek*dinfitem*sol-itr-primal-obj"></a> 
<br/>Primal objective value of the interior-point solution. Updated at the end of the optimization. </li>
</ul>

</div>

<div>
<h1><a name="251602272">17.14. Feasibility repair types</a></h1>

<p> <a name="constclass*mosek*feasrepairtype">&#09;</a><a name="common-constclass*mosek*feasrepairtype"></a> <a name="idx-172862928">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.feasrepairtype.optimize_combined</tt><a name="const*mosek*feasrepairtype*optimize-combined">&#09;</a><a name="common-const*mosek*feasrepairtype*optimize-combined"></a> 
<br/>Minimize with original objective subject to minimal weighted violation of bounds. </li>
<li><tt class="tt">mosek.feasrepairtype.optimize_none</tt><a name="const*mosek*feasrepairtype*optimize-none">&#09;</a><a name="common-const*mosek*feasrepairtype*optimize-none"></a> 
<br/>Do not optimize the feasibility repair problem. </li>
<li><tt class="tt">mosek.feasrepairtype.optimize_penalty</tt><a name="const*mosek*feasrepairtype*optimize-penalty">&#09;</a><a name="common-const*mosek*feasrepairtype*optimize-penalty"></a> 
<br/>Minimize weighted sum of violations. </li>
</ul>

</div>

<div>
<h1><a name="251604864">17.15. License feature</a></h1>

<p> <a name="constclass*mosek*feature">&#09;</a><a name="common-constclass*mosek*feature"></a> <a name="idx-172908344">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.feature.ptom</tt><a name="const*mosek*feature*ptom">&#09;</a><a name="common-const*mosek*feature*ptom"></a> 
<br/>Mixed-integer extension. </li>
<li><tt class="tt">mosek.feature.pton</tt><a name="const*mosek*feature*pton">&#09;</a><a name="common-const*mosek*feature*pton"></a> 
<br/>Nonlinear extension. </li>
<li><tt class="tt">mosek.feature.ptox</tt><a name="const*mosek*feature*ptox">&#09;</a><a name="common-const*mosek*feature*ptox"></a> 
<br/>Non-convex extension. </li>
<li><tt class="tt">mosek.feature.pts</tt><a name="const*mosek*feature*pts">&#09;</a><a name="common-const*mosek*feature*pts"></a> 
<br/>Base system. </li>
</ul>

</div>

<div>
<h1><a name="251608168">17.16. Integer information items.</a></h1>

<p> <a name="constclass*mosek*iinfitem">&#09;</a><a name="common-constclass*mosek*iinfitem"></a> <a name="idx-172919408">&#09;</a> </p>

<ul class="itemize">
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_con</tt><a name="const*mosek*iinfitem*ana-pro-num-con">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-con"></a> 
<br/>Number of constraints in the problem.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_con_eq</tt><a name="const*mosek*iinfitem*ana-pro-num-con-eq">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-con-eq"></a> 
<br/>Number of equality constraints.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_con_fr</tt><a name="const*mosek*iinfitem*ana-pro-num-con-fr">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-con-fr"></a> 
<br/>Number of unbounded constraints.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_con_lo</tt><a name="const*mosek*iinfitem*ana-pro-num-con-lo">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-con-lo"></a> 
<br/>Number of constraints with a lower bound and an infinite upper bound.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_con_ra</tt><a name="const*mosek*iinfitem*ana-pro-num-con-ra">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-con-ra"></a> 
<br/>Number of constraints with finite lower and upper bounds.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_con_up</tt><a name="const*mosek*iinfitem*ana-pro-num-con-up">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-con-up"></a> 
<br/>Number of constraints with an upper bound and an infinite lower bound.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_var</tt><a name="const*mosek*iinfitem*ana-pro-num-var">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-var"></a> 
<br/>Number of variables in the problem.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_var_bin</tt><a name="const*mosek*iinfitem*ana-pro-num-var-bin">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-var-bin"></a> 
<br/>Number of binary (0-1) variables.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_var_cont</tt><a name="const*mosek*iinfitem*ana-pro-num-var-cont">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-var-cont"></a> 
<br/>Number of continuous variables.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_var_eq</tt><a name="const*mosek*iinfitem*ana-pro-num-var-eq">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-var-eq"></a> 
<br/>Number of fixed variables.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_var_fr</tt><a name="const*mosek*iinfitem*ana-pro-num-var-fr">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-var-fr"></a> 
<br/>Number of free variables.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_var_int</tt><a name="const*mosek*iinfitem*ana-pro-num-var-int">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-var-int"></a> 
<br/>Number of general integer variables.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_var_lo</tt><a name="const*mosek*iinfitem*ana-pro-num-var-lo">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-var-lo"></a> 
<br/>Number of variables with a lower bound and an infinite upper bound.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_var_ra</tt><a name="const*mosek*iinfitem*ana-pro-num-var-ra">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-var-ra"></a> 
<br/>Number of variables with finite lower and upper bounds.</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li>
<p><tt class="tt">mosek.iinfitem.ana_pro_num_var_up</tt><a name="const*mosek*iinfitem*ana-pro-num-var-up">&#09;</a><a name="common-const*mosek*iinfitem*ana-pro-num-var-up"></a> 
<br/>Number of variables with an upper bound and an infinite lower bound. This value is set by</p>

<p>This value is set by <a href="node016.html#common-func*mosek*task*analyzeproblem"><tt class="tt">Task.analyzeproblem</tt></a>.</p>
</li>
<li><tt class="tt">mosek.iinfitem.cache_size_l1</tt><a name="const*mosek*iinfitem*cache-size-l1">&#09;</a><a name="common-const*mosek*iinfitem*cache-size-l1"></a> 
<br/>L1 cache size used. </li>
<li><tt class="tt">mosek.iinfitem.cache_size_l2</tt><a name="const*mosek*iinfitem*cache-size-l2">&#09;</a><a name="common-const*mosek*iinfitem*cache-size-l2"></a> 
<br/>L2 cache size used. </li>
<li><tt class="tt">mosek.iinfitem.concurrent_fastest_optimizer</tt><a name="const*mosek*iinfitem*concurrent-fastest-optimizer">&#09;</a><a name="common-const*mosek*iinfitem*concurrent-fastest-optimizer"></a> 
<br/>The type of the optimizer that finished first in a concurrent optimization. </li>
<li><tt class="tt">mosek.iinfitem.cpu_type</tt><a name="const*mosek*iinfitem*cpu-type">&#09;</a><a name="common-const*mosek*iinfitem*cpu-type"></a> 
<br/>The type of cpu detected. </li>
<li><tt class="tt">mosek.iinfitem.intpnt_factor_num_offcol</tt><a name="const*mosek*iinfitem*intpnt-factor-num-offcol">&#09;</a><a name="common-const*mosek*iinfitem*intpnt-factor-num-offcol"></a> 
<br/>Number of columns in the constraint matrix (or Jacobian) that has an offending structure. </li>
<li><tt class="tt">mosek.iinfitem.intpnt_iter</tt><a name="const*mosek*iinfitem*intpnt-iter">&#09;</a><a name="common-const*mosek*iinfitem*intpnt-iter"></a> 
<br/>Number of interior-point iterations since invoking the interior-point optimizer. </li>
<li><tt class="tt">mosek.iinfitem.intpnt_num_threads</tt><a name="const*mosek*iinfitem*intpnt-num-threads">&#09;</a><a name="common-const*mosek*iinfitem*intpnt-num-threads"></a> 
<br/>Number of threads that the interior-point optimizer is using. </li>
<li><tt class="tt">mosek.iinfitem.intpnt_solve_dual</tt><a name="const*mosek*iinfitem*intpnt-solve-dual">&#09;</a><a name="common-const*mosek*iinfitem*intpnt-solve-dual"></a> 
<br/>Non-zero if the interior-point optimizer is solving the dual problem. </li>
<li><tt class="tt">mosek.iinfitem.mio_construct_solution</tt><a name="const*mosek*iinfitem*mio-construct-solution">&#09;</a><a name="common-const*mosek*iinfitem*mio-construct-solution"></a> 
<br/>If this item has the value 0, then MOSEK did not try to construct an initial integer feasible solution. If the item has a positive value, then MOSEK successfully constructed an initial integer feasible solution. </li>
<li><tt class="tt">mosek.iinfitem.mio_initial_solution</tt><a name="const*mosek*iinfitem*mio-initial-solution">&#09;</a><a name="common-const*mosek*iinfitem*mio-initial-solution"></a> 
<br/>Is non-zero if an initial integer solution is specified. </li>
<li><tt class="tt">mosek.iinfitem.mio_num_active_nodes</tt><a name="const*mosek*iinfitem*mio-num-active-nodes">&#09;</a><a name="common-const*mosek*iinfitem*mio-num-active-nodes"></a> 
<br/>Number of active nodes in the branch and bound tree. </li>
<li><tt class="tt">mosek.iinfitem.mio_num_branch</tt><a name="const*mosek*iinfitem*mio-num-branch">&#09;</a><a name="common-const*mosek*iinfitem*mio-num-branch"></a> 
<br/>Number of branches performed during the optimization. </li>
<li><tt class="tt">mosek.iinfitem.mio_num_cuts</tt><a name="const*mosek*iinfitem*mio-num-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-num-cuts"></a> 
<br/>Number of cuts generated by the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.iinfitem.mio_num_int_solutions</tt><a name="const*mosek*iinfitem*mio-num-int-solutions">&#09;</a><a name="common-const*mosek*iinfitem*mio-num-int-solutions"></a> 
<br/>Number of integer feasible solutions that has been found. </li>
<li><tt class="tt">mosek.iinfitem.mio_num_relax</tt><a name="const*mosek*iinfitem*mio-num-relax">&#09;</a><a name="common-const*mosek*iinfitem*mio-num-relax"></a> 
<br/>Number of relaxations solved during the optimization. </li>
<li><tt class="tt">mosek.iinfitem.mio_numcon</tt><a name="const*mosek*iinfitem*mio-numcon">&#09;</a><a name="common-const*mosek*iinfitem*mio-numcon"></a> 
<br/>Number of constraints in the problem solved be the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.iinfitem.mio_numint</tt><a name="const*mosek*iinfitem*mio-numint">&#09;</a><a name="common-const*mosek*iinfitem*mio-numint"></a> 
<br/>Number of integer variables in the problem solved be the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.iinfitem.mio_numvar</tt><a name="const*mosek*iinfitem*mio-numvar">&#09;</a><a name="common-const*mosek*iinfitem*mio-numvar"></a> 
<br/>Number of variables in the problem solved be the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_basis_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-basis-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-basis-cuts"></a> 
<br/>Number of basis cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_branch</tt><a name="const*mosek*iinfitem*mio-total-num-branch">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-branch"></a> 
<br/>Number of branches performed during the optimization. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_cardgub_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-cardgub-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-cardgub-cuts"></a> 
<br/>Number of cardgub cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_clique_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-clique-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-clique-cuts"></a> 
<br/>Number of clique cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_coef_redc_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-coef-redc-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-coef-redc-cuts"></a> 
<br/>Number of coef. redc. cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_contra_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-contra-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-contra-cuts"></a> 
<br/>Number of contra cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-cuts"></a> 
<br/>Total number of cuts generated by the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_disagg_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-disagg-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-disagg-cuts"></a> 
<br/>Number of diasagg cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_flow_cover_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-flow-cover-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-flow-cover-cuts"></a> 
<br/>Number of flow cover cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_gcd_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-gcd-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-gcd-cuts"></a> 
<br/>Number of gcd cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_gomory_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-gomory-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-gomory-cuts"></a> 
<br/>Number of Gomory cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_gub_cover_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-gub-cover-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-gub-cover-cuts"></a> 
<br/>Number of GUB cover cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_knapsur_cover_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-knapsur-cover-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-knapsur-cover-cuts"></a> 
<br/>Number of knapsack cover cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_lattice_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-lattice-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-lattice-cuts"></a> 
<br/>Number of lattice cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_lift_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-lift-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-lift-cuts"></a> 
<br/>Number of lift cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_obj_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-obj-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-obj-cuts"></a> 
<br/>Number of obj cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_plan_loc_cuts</tt><a name="const*mosek*iinfitem*mio-total-num-plan-loc-cuts">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-plan-loc-cuts"></a> 
<br/>Number of loc cuts. </li>
<li><tt class="tt">mosek.iinfitem.mio_total_num_relax</tt><a name="const*mosek*iinfitem*mio-total-num-relax">&#09;</a><a name="common-const*mosek*iinfitem*mio-total-num-relax"></a> 
<br/>Number of relaxations solved during the optimization. </li>
<li><tt class="tt">mosek.iinfitem.mio_user_obj_cut</tt><a name="const*mosek*iinfitem*mio-user-obj-cut">&#09;</a><a name="common-const*mosek*iinfitem*mio-user-obj-cut"></a> 
<br/>If it is non-zero, then the objective cut is used. </li>
<li><tt class="tt">mosek.iinfitem.opt_numcon</tt><a name="const*mosek*iinfitem*opt-numcon">&#09;</a><a name="common-const*mosek*iinfitem*opt-numcon"></a> 
<br/>Number of constraints in the problem solved when the optimizer is called. </li>
<li><tt class="tt">mosek.iinfitem.opt_numvar</tt><a name="const*mosek*iinfitem*opt-numvar">&#09;</a><a name="common-const*mosek*iinfitem*opt-numvar"></a> 
<br/>Number of variables in the problem solved when the optimizer is called </li>
<li><tt class="tt">mosek.iinfitem.optimize_response</tt><a name="const*mosek*iinfitem*optimize-response">&#09;</a><a name="common-const*mosek*iinfitem*optimize-response"></a> 
<br/>The reponse code returned by optimize. </li>
<li><tt class="tt">mosek.iinfitem.rd_numcon</tt><a name="const*mosek*iinfitem*rd-numcon">&#09;</a><a name="common-const*mosek*iinfitem*rd-numcon"></a> 
<br/>Number of constraints read. </li>
<li><tt class="tt">mosek.iinfitem.rd_numcone</tt><a name="const*mosek*iinfitem*rd-numcone">&#09;</a><a name="common-const*mosek*iinfitem*rd-numcone"></a> 
<br/>Number of conic constraints read. </li>
<li><tt class="tt">mosek.iinfitem.rd_numintvar</tt><a name="const*mosek*iinfitem*rd-numintvar">&#09;</a><a name="common-const*mosek*iinfitem*rd-numintvar"></a> 
<br/>Number of integer-constrained variables read. </li>
<li><tt class="tt">mosek.iinfitem.rd_numq</tt><a name="const*mosek*iinfitem*rd-numq">&#09;</a><a name="common-const*mosek*iinfitem*rd-numq"></a> 
<br/>Number of nonempty Q matrices read. </li>
<li><tt class="tt">mosek.iinfitem.rd_numvar</tt><a name="const*mosek*iinfitem*rd-numvar">&#09;</a><a name="common-const*mosek*iinfitem*rd-numvar"></a> 
<br/>Number of variables read. </li>
<li><tt class="tt">mosek.iinfitem.rd_protype</tt><a name="const*mosek*iinfitem*rd-protype">&#09;</a><a name="common-const*mosek*iinfitem*rd-protype"></a> 
<br/>Problem type. </li>
<li><tt class="tt">mosek.iinfitem.sim_dual_deg_iter</tt><a name="const*mosek*iinfitem*sim-dual-deg-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-dual-deg-iter"></a> 
<br/>The number of dual degenerate iterations. </li>
<li><tt class="tt">mosek.iinfitem.sim_dual_hotstart</tt><a name="const*mosek*iinfitem*sim-dual-hotstart">&#09;</a><a name="common-const*mosek*iinfitem*sim-dual-hotstart"></a> 
<br/>If 1 then the dual simplex algorithm is solving from an advanced basis. </li>
<li><tt class="tt">mosek.iinfitem.sim_dual_hotstart_lu</tt><a name="const*mosek*iinfitem*sim-dual-hotstart-lu">&#09;</a><a name="common-const*mosek*iinfitem*sim-dual-hotstart-lu"></a> 
<br/>If 1 then a valid basis factorization of full rank was located and used by the dual simplex algorithm. </li>
<li><tt class="tt">mosek.iinfitem.sim_dual_inf_iter</tt><a name="const*mosek*iinfitem*sim-dual-inf-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-dual-inf-iter"></a> 
<br/>The number of iterations taken with dual infeasibility. </li>
<li><tt class="tt">mosek.iinfitem.sim_dual_iter</tt><a name="const*mosek*iinfitem*sim-dual-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-dual-iter"></a> 
<br/>Number of dual simplex iterations during the last optimization. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_dual_deg_iter</tt><a name="const*mosek*iinfitem*sim-network-dual-deg-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-dual-deg-iter"></a> 
<br/>The number of dual network degenerate iterations. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_dual_hotstart</tt><a name="const*mosek*iinfitem*sim-network-dual-hotstart">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-dual-hotstart"></a> 
<br/>If 1 then the dual network simplex algorithm is solving from an advanced basis. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_dual_hotstart_lu</tt><a name="const*mosek*iinfitem*sim-network-dual-hotstart-lu">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-dual-hotstart-lu"></a> 
<br/>If 1 then a valid basis factorization of full rank was located and used by the dual network simplex algorithm. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_dual_inf_iter</tt><a name="const*mosek*iinfitem*sim-network-dual-inf-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-dual-inf-iter"></a> 
<br/>The number of iterations taken with dual infeasibility in the network optimizer. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_dual_iter</tt><a name="const*mosek*iinfitem*sim-network-dual-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-dual-iter"></a> 
<br/>Number of dual network simplex iterations during the last optimization. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_primal_deg_iter</tt><a name="const*mosek*iinfitem*sim-network-primal-deg-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-primal-deg-iter"></a> 
<br/>The number of primal network degenerate iterations. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_primal_hotstart</tt><a name="const*mosek*iinfitem*sim-network-primal-hotstart">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-primal-hotstart"></a> 
<br/>If 1 then the primal network simplex algorithm is solving from an advanced basis. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_primal_hotstart_lu</tt><a name="const*mosek*iinfitem*sim-network-primal-hotstart-lu">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-primal-hotstart-lu"></a> 
<br/>If 1 then a valid basis factorization of full rank was located and used by the primal network simplex algorithm. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_primal_inf_iter</tt><a name="const*mosek*iinfitem*sim-network-primal-inf-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-primal-inf-iter"></a> 
<br/>The number of iterations taken with primal infeasibility in the network optimizer. </li>
<li><tt class="tt">mosek.iinfitem.sim_network_primal_iter</tt><a name="const*mosek*iinfitem*sim-network-primal-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-network-primal-iter"></a> 
<br/>Number of primal network simplex iterations during the last optimization. </li>
<li><tt class="tt">mosek.iinfitem.sim_numcon</tt><a name="const*mosek*iinfitem*sim-numcon">&#09;</a><a name="common-const*mosek*iinfitem*sim-numcon"></a> 
<br/>Number of constraints in the problem solved by the simplex optimizer. </li>
<li><tt class="tt">mosek.iinfitem.sim_numvar</tt><a name="const*mosek*iinfitem*sim-numvar">&#09;</a><a name="common-const*mosek*iinfitem*sim-numvar"></a> 
<br/>Number of variables in the problem solved by the simplex optimizer. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_deg_iter</tt><a name="const*mosek*iinfitem*sim-primal-deg-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-deg-iter"></a> 
<br/>The number of primal degenerate iterations. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_dual_deg_iter</tt><a name="const*mosek*iinfitem*sim-primal-dual-deg-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-dual-deg-iter"></a> 
<br/>The number of degenerate major iterations taken by the primal dual simplex algorithm. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_dual_hotstart</tt><a name="const*mosek*iinfitem*sim-primal-dual-hotstart">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-dual-hotstart"></a> 
<br/>If 1 then the primal dual simplex algorithm is solving from an advanced basis. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_dual_hotstart_lu</tt><a name="const*mosek*iinfitem*sim-primal-dual-hotstart-lu">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-dual-hotstart-lu"></a> 
<br/>If 1 then a valid basis factorization of full rank was located and used by the primal dual simplex algorithm. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_dual_inf_iter</tt><a name="const*mosek*iinfitem*sim-primal-dual-inf-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-dual-inf-iter"></a> 
<br/>The number of master iterations with dual infeasibility taken by the primal dual simplex algorithm. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_dual_iter</tt><a name="const*mosek*iinfitem*sim-primal-dual-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-dual-iter"></a> 
<br/>Number of primal dual simplex iterations during the last optimization. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_hotstart</tt><a name="const*mosek*iinfitem*sim-primal-hotstart">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-hotstart"></a> 
<br/>If 1 then the primal simplex algorithm is solving from an advanced basis. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_hotstart_lu</tt><a name="const*mosek*iinfitem*sim-primal-hotstart-lu">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-hotstart-lu"></a> 
<br/>If 1 then a valid basis factorization of full rank was located and used by the primal simplex algorithm. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_inf_iter</tt><a name="const*mosek*iinfitem*sim-primal-inf-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-inf-iter"></a> 
<br/>The number of iterations taken with primal infeasibility. </li>
<li><tt class="tt">mosek.iinfitem.sim_primal_iter</tt><a name="const*mosek*iinfitem*sim-primal-iter">&#09;</a><a name="common-const*mosek*iinfitem*sim-primal-iter"></a> 
<br/>Number of primal simplex iterations during the last optimization. </li>
<li><tt class="tt">mosek.iinfitem.sim_solve_dual</tt><a name="const*mosek*iinfitem*sim-solve-dual">&#09;</a><a name="common-const*mosek*iinfitem*sim-solve-dual"></a> 
<br/>Is non-zero if dual problem is solved. </li>
<li><tt class="tt">mosek.iinfitem.sol_bas_prosta</tt><a name="const*mosek*iinfitem*sol-bas-prosta">&#09;</a><a name="common-const*mosek*iinfitem*sol-bas-prosta"></a> 
<br/>Problem status of the basic solution. Updated after each optimization. </li>
<li><tt class="tt">mosek.iinfitem.sol_bas_solsta</tt><a name="const*mosek*iinfitem*sol-bas-solsta">&#09;</a><a name="common-const*mosek*iinfitem*sol-bas-solsta"></a> 
<br/>Solution status of the basic solution. Updated after each optimization. </li>
<li><tt class="tt">mosek.iinfitem.sol_int_prosta</tt><a name="const*mosek*iinfitem*sol-int-prosta">&#09;</a><a name="common-const*mosek*iinfitem*sol-int-prosta"></a> 
<br/>Problem status of the integer solution. Updated after each optimization. </li>
<li><tt class="tt">mosek.iinfitem.sol_int_solsta</tt><a name="const*mosek*iinfitem*sol-int-solsta">&#09;</a><a name="common-const*mosek*iinfitem*sol-int-solsta"></a> 
<br/>Solution status of the integer solution. Updated after each optimization. </li>
<li><tt class="tt">mosek.iinfitem.sol_itr_prosta</tt><a name="const*mosek*iinfitem*sol-itr-prosta">&#09;</a><a name="common-const*mosek*iinfitem*sol-itr-prosta"></a> 
<br/>Problem status of the interior-point solution. Updated after each optimization. </li>
<li><tt class="tt">mosek.iinfitem.sol_itr_solsta</tt><a name="const*mosek*iinfitem*sol-itr-solsta">&#09;</a><a name="common-const*mosek*iinfitem*sol-itr-solsta"></a> 
<br/>Solution status of the interior-point solution. Updated after each optimization. </li>
<li><tt class="tt">mosek.iinfitem.sto_num_a_cache_flushes</tt><a name="const*mosek*iinfitem*sto-num-a-cache-flushes">&#09;</a><a name="common-const*mosek*iinfitem*sto-num-a-cache-flushes"></a> 
<br/>Number of times the cache of <span class="math"><span class="mi">A</span></span> elements is flushed. A large number implies that <tt class="tt">maxnumanz</tt> is too small as well as an inefficient usage of MOSEK. </li>
<li><tt class="tt">mosek.iinfitem.sto_num_a_realloc</tt><a name="const*mosek*iinfitem*sto-num-a-realloc">&#09;</a><a name="common-const*mosek*iinfitem*sto-num-a-realloc"></a> 
<br/>Number of times the storage for storing <span class="math"><span class="mi">A</span></span> has been changed. A large value may indicates that memory fragmentation may occur. </li>
<li><tt class="tt">mosek.iinfitem.sto_num_a_transposes</tt><a name="const*mosek*iinfitem*sto-num-a-transposes">&#09;</a><a name="common-const*mosek*iinfitem*sto-num-a-transposes"></a> 
<br/>Number of times the <span class="math"><span class="mi">A</span></span> matrix is transposed. A large number implies that <tt class="tt">maxnumanz</tt> is too small or an inefficient usage of MOSEK. This will occur in particular if the code alternate between accessing rows and columns of <span class="math"><span class="mi">A</span></span>. </li>
</ul>

</div>

<div>
<h1><a name="251678376">17.17. Information item types</a></h1>

<p> <a name="constclass*mosek*inftype">&#09;</a><a name="common-constclass*mosek*inftype"></a> <a name="idx-175986520">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.inftype.dou_type</tt><a name="const*mosek*inftype*dou-type">&#09;</a><a name="common-const*mosek*inftype*dou-type"></a> 
<br/>Is a double information type. </li>
<li><tt class="tt">mosek.inftype.int_type</tt><a name="const*mosek*inftype*int-type">&#09;</a><a name="common-const*mosek*inftype*int-type"></a> 
<br/>Is an integer. </li>
<li><tt class="tt">mosek.inftype.lint_type</tt><a name="const*mosek*inftype*lint-type">&#09;</a><a name="common-const*mosek*inftype*lint-type"></a> 
<br/>Is a long integer. </li>
</ul>

</div>

<div>
<h1><a name="251681032">17.18. Input/output modes</a></h1>

<p> <a name="constclass*mosek*iomode">&#09;</a><a name="common-constclass*mosek*iomode"></a> <a name="idx-176008368">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.iomode.read</tt><a name="const*mosek*iomode*read">&#09;</a><a name="common-const*mosek*iomode*read"></a> 
<br/>The file is read-only. </li>
<li><tt class="tt">mosek.iomode.readwrite</tt><a name="const*mosek*iomode*readwrite">&#09;</a><a name="common-const*mosek*iomode*readwrite"></a> 
<br/>The file is to read and written. </li>
<li><tt class="tt">mosek.iomode.write</tt><a name="const*mosek*iomode*write">&#09;</a><a name="common-const*mosek*iomode*write"></a> 
<br/>The file is write-only. If the file exists then it is truncated when it is opened. Otherwise it is created when it is opened. </li>
</ul>

</div>

<div>
<h1><a name="251683688">17.19. Language selection constants</a></h1>

<p> <a name="constclass*mosek*language">&#09;</a><a name="common-constclass*mosek*language"></a> <a name="idx-175951168">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.language.dan</tt><a name="const*mosek*language*dan">&#09;</a><a name="common-const*mosek*language*dan"></a> 
<br/>Danish language selection </li>
<li><tt class="tt">mosek.language.eng</tt><a name="const*mosek*language*eng">&#09;</a><a name="common-const*mosek*language*eng"></a> 
<br/>English language selection </li>
</ul>

</div>

<div>
<h1><a name="251685632">17.20. Long integer information items.</a></h1>

<p> <a name="constclass*mosek*liinfitem">&#09;</a><a name="common-constclass*mosek*liinfitem"></a> <a name="idx-176033232">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.liinfitem.bi_clean_dual_deg_iter</tt><a name="const*mosek*liinfitem*bi-clean-dual-deg-iter">&#09;</a><a name="common-const*mosek*liinfitem*bi-clean-dual-deg-iter"></a> 
<br/>Number of dual degenerate clean iterations performed in the basis identification. </li>
<li><tt class="tt">mosek.liinfitem.bi_clean_dual_iter</tt><a name="const*mosek*liinfitem*bi-clean-dual-iter">&#09;</a><a name="common-const*mosek*liinfitem*bi-clean-dual-iter"></a> 
<br/>Number of dual clean iterations performed in the basis identification. </li>
<li><tt class="tt">mosek.liinfitem.bi_clean_primal_deg_iter</tt><a name="const*mosek*liinfitem*bi-clean-primal-deg-iter">&#09;</a><a name="common-const*mosek*liinfitem*bi-clean-primal-deg-iter"></a> 
<br/>Number of primal degenerate clean iterations performed in the basis identification. </li>
<li><tt class="tt">mosek.liinfitem.bi_clean_primal_dual_deg_iter</tt><a name="const*mosek*liinfitem*bi-clean-primal-dual-deg-iter">&#09;</a><a name="common-const*mosek*liinfitem*bi-clean-primal-dual-deg-iter"></a> 
<br/>Number of primal-dual degenerate clean iterations performed in the basis identification. </li>
<li><tt class="tt">mosek.liinfitem.bi_clean_primal_dual_iter</tt><a name="const*mosek*liinfitem*bi-clean-primal-dual-iter">&#09;</a><a name="common-const*mosek*liinfitem*bi-clean-primal-dual-iter"></a> 
<br/>Number of primal-dual clean iterations performed in the basis identification. </li>
<li><tt class="tt">mosek.liinfitem.bi_clean_primal_dual_sub_iter</tt><a name="const*mosek*liinfitem*bi-clean-primal-dual-sub-iter">&#09;</a><a name="common-const*mosek*liinfitem*bi-clean-primal-dual-sub-iter"></a> 
<br/>Number of primal-dual subproblem clean iterations performed in the basis identification. </li>
<li><tt class="tt">mosek.liinfitem.bi_clean_primal_iter</tt><a name="const*mosek*liinfitem*bi-clean-primal-iter">&#09;</a><a name="common-const*mosek*liinfitem*bi-clean-primal-iter"></a> 
<br/>Number of primal clean iterations performed in the basis identification. </li>
<li><tt class="tt">mosek.liinfitem.bi_dual_iter</tt><a name="const*mosek*liinfitem*bi-dual-iter">&#09;</a><a name="common-const*mosek*liinfitem*bi-dual-iter"></a> 
<br/>Number of dual pivots performed in the basis identification. </li>
<li><tt class="tt">mosek.liinfitem.bi_primal_iter</tt><a name="const*mosek*liinfitem*bi-primal-iter">&#09;</a><a name="common-const*mosek*liinfitem*bi-primal-iter"></a> 
<br/>Number of primal pivots performed in the basis identification. </li>
<li><tt class="tt">mosek.liinfitem.intpnt_factor_num_nz</tt><a name="const*mosek*liinfitem*intpnt-factor-num-nz">&#09;</a><a name="common-const*mosek*liinfitem*intpnt-factor-num-nz"></a> 
<br/>Number of non-zeros in factorization. </li>
<li><tt class="tt">mosek.liinfitem.mio_intpnt_iter</tt><a name="const*mosek*liinfitem*mio-intpnt-iter">&#09;</a><a name="common-const*mosek*liinfitem*mio-intpnt-iter"></a> 
<br/>Number of interior-point iterations performed by the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.liinfitem.mio_simplex_iter</tt><a name="const*mosek*liinfitem*mio-simplex-iter">&#09;</a><a name="common-const*mosek*liinfitem*mio-simplex-iter"></a> 
<br/>Number of simplex iterations performed by the mixed-integer optimizer. </li>
<li><tt class="tt">mosek.liinfitem.rd_numanz</tt><a name="const*mosek*liinfitem*rd-numanz">&#09;</a><a name="common-const*mosek*liinfitem*rd-numanz"></a> 
<br/>Number of non-zeros in A that is read. </li>
<li><tt class="tt">mosek.liinfitem.rd_numqnz</tt><a name="const*mosek*liinfitem*rd-numqnz">&#09;</a><a name="common-const*mosek*liinfitem*rd-numqnz"></a> 
<br/>Number of Q non-zeros. </li>
</ul>

</div>

<div>
<h1><a name="251695544">17.21. Mark</a></h1>

<p> <a name="constclass*mosek*mark">&#09;</a><a name="common-constclass*mosek*mark"></a> <a name="idx-176090504">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.mark.lo</tt><a name="const*mosek*mark*lo">&#09;</a><a name="common-const*mosek*mark*lo"></a> 
<br/>The lower bound is selected for sensitivity analysis. </li>
<li><tt class="tt">mosek.mark.up</tt><a name="const*mosek*mark*up">&#09;</a><a name="common-const*mosek*mark*up"></a> 
<br/>The upper bound is selected for sensitivity analysis. </li>
</ul>

</div>

<div>
<h1><a name="251697488">17.22. Continuous mixed-integer solution type</a></h1>

<p> <a name="constclass*mosek*miocontsoltype">&#09;</a><a name="common-constclass*mosek*miocontsoltype"></a> <a name="idx-176094672">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.miocontsoltype.itg</tt><a name="const*mosek*miocontsoltype*itg">&#09;</a><a name="common-const*mosek*miocontsoltype*itg"></a> 
<br/>The reported interior-point and basic solutions are a solution to the problem with all integer variables fixed at the value they have in the integer solution. A solution is only reported in case the problem has a primal feasible solution. </li>
<li><tt class="tt">mosek.miocontsoltype.itg_rel</tt><a name="const*mosek*miocontsoltype*itg-rel">&#09;</a><a name="common-const*mosek*miocontsoltype*itg-rel"></a> 
<br/>In case the problem is primal feasible then the reported interior-point and basic solutions are a solution to the problem with all integer variables fixed at the value they have in the integer solution. If the problem is primal infeasible, then the solution to the root node problem is reported. </li>
<li><tt class="tt">mosek.miocontsoltype.none</tt><a name="const*mosek*miocontsoltype*none">&#09;</a><a name="common-const*mosek*miocontsoltype*none"></a> 
<br/>No interior-point or basic solution are reported when the mixed-integer optimizer is used. </li>
<li><tt class="tt">mosek.miocontsoltype.root</tt><a name="const*mosek*miocontsoltype*root">&#09;</a><a name="common-const*mosek*miocontsoltype*root"></a> 
<br/>The reported interior-point and basic solutions are a solution to the root node problem when mixed-integer optimizer is used. </li>
</ul>

</div>

<div>
<h1><a name="251700792">17.23. Integer restrictions</a></h1>

<p> <a name="constclass*mosek*miomode">&#09;</a><a name="common-constclass*mosek*miomode"></a> <a name="idx-176100416">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.miomode.ignored</tt><a name="const*mosek*miomode*ignored">&#09;</a><a name="common-const*mosek*miomode*ignored"></a> 
<br/>The integer constraints are ignored and the problem is solved as a continuous problem. </li>
<li><tt class="tt">mosek.miomode.lazy</tt><a name="const*mosek*miomode*lazy">&#09;</a><a name="common-const*mosek*miomode*lazy"></a> 
<br/>Integer restrictions should be satisfied if an optimizer is available for the problem. </li>
<li><tt class="tt">mosek.miomode.satisfied</tt><a name="const*mosek*miomode*satisfied">&#09;</a><a name="common-const*mosek*miomode*satisfied"></a> 
<br/>Integer restrictions should be satisfied. </li>
</ul>

</div>

<div>
<h1><a name="251703448">17.24. Mixed-integer node selection types</a></h1>

<p> <a name="constclass*mosek*mionodeseltype">&#09;</a><a name="common-constclass*mosek*mionodeseltype"></a> <a name="idx-176127440">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.mionodeseltype.best</tt><a name="const*mosek*mionodeseltype*best">&#09;</a><a name="common-const*mosek*mionodeseltype*best"></a> 
<br/>The optimizer employs a best bound node selection strategy. </li>
<li><tt class="tt">mosek.mionodeseltype.first</tt><a name="const*mosek*mionodeseltype*first">&#09;</a><a name="common-const*mosek*mionodeseltype*first"></a> 
<br/>The optimizer employs a depth first node selection strategy. </li>
<li><tt class="tt">mosek.mionodeseltype.free</tt><a name="const*mosek*mionodeseltype*free">&#09;</a><a name="common-const*mosek*mionodeseltype*free"></a> 
<br/>The optimizer decides the node selection strategy. </li>
<li><tt class="tt">mosek.mionodeseltype.hybrid</tt><a name="const*mosek*mionodeseltype*hybrid">&#09;</a><a name="common-const*mosek*mionodeseltype*hybrid"></a> 
<br/>The optimizer employs a hybrid strategy. </li>
<li><tt class="tt">mosek.mionodeseltype.pseudo</tt><a name="const*mosek*mionodeseltype*pseudo">&#09;</a><a name="common-const*mosek*mionodeseltype*pseudo"></a> 
<br/>The optimizer employs selects the node based on a pseudo cost estimate. </li>
<li><tt class="tt">mosek.mionodeseltype.worst</tt><a name="const*mosek*mionodeseltype*worst">&#09;</a><a name="common-const*mosek*mionodeseltype*worst"></a> 
<br/>The optimizer employs a worst bound node selection strategy. </li>
</ul>

</div>

<div>
<h1><a name="251708048">17.25. MPS file format type</a></h1>

<p> <a name="constclass*mosek*mpsformat">&#09;</a><a name="common-constclass*mosek*mpsformat"></a> <a name="idx-176149640">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.mpsformat.free</tt><a name="const*mosek*mpsformat*free">&#09;</a><a name="common-const*mosek*mpsformat*free"></a> 
<br/>It is assumed that the input file satisfies the free MPS format. This implies that spaces are not allowed in names. Otherwise the format is free. </li>
<li><tt class="tt">mosek.mpsformat.relaxed</tt><a name="const*mosek*mpsformat*relaxed">&#09;</a><a name="common-const*mosek*mpsformat*relaxed"></a> 
<br/>It is assumed that the input file satisfies a slightly relaxed version of the MPS format. </li>
<li><tt class="tt">mosek.mpsformat.strict</tt><a name="const*mosek*mpsformat*strict">&#09;</a><a name="common-const*mosek*mpsformat*strict"></a> 
<br/>It is assumed that the input file satisfies the MPS format strictly. </li>
</ul>

</div>

<div>
<h1><a name="251710640">17.26. Message keys</a></h1>

<p> <a name="constclass*mosek*msgkey">&#09;</a><a name="common-constclass*mosek*msgkey"></a> <a name="idx-176075552">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.msgkey.mps_selected</tt><a name="const*mosek*msgkey*mps-selected">&#09;</a><a name="common-const*mosek*msgkey*mps-selected"></a> </li>
<li><tt class="tt">mosek.msgkey.reading_file</tt><a name="const*mosek*msgkey*reading-file">&#09;</a><a name="common-const*mosek*msgkey*reading-file"></a> </li>
<li><tt class="tt">mosek.msgkey.writing_file</tt><a name="const*mosek*msgkey*writing-file">&#09;</a><a name="common-const*mosek*msgkey*writing-file"></a> </li>
</ul>

</div>

<div>
<h1><a name="251713296">17.27. Network detection method</a></h1>

<p> <a name="constclass*mosek*networkdetect">&#09;</a><a name="common-constclass*mosek*networkdetect"></a> <a name="idx-176183272">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.networkdetect.advanced</tt><a name="const*mosek*networkdetect*advanced">&#09;</a><a name="common-const*mosek*networkdetect*advanced"></a> 
<br/>The network detection should use a more advanced heuristic. </li>
<li><tt class="tt">mosek.networkdetect.free</tt><a name="const*mosek*networkdetect*free">&#09;</a><a name="common-const*mosek*networkdetect*free"></a> 
<br/>The network detection is free. </li>
<li><tt class="tt">mosek.networkdetect.simple</tt><a name="const*mosek*networkdetect*simple">&#09;</a><a name="common-const*mosek*networkdetect*simple"></a> 
<br/>The network detection should use a very simple heuristic. </li>
</ul>

</div>

<div>
<h1><a name="251715952">17.28. Objective sense types</a></h1>

<p> <a name="constclass*mosek*objsense">&#09;</a><a name="common-constclass*mosek*objsense"></a> <a name="idx-176189024">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.objsense.maximize</tt><a name="const*mosek*objsense*maximize">&#09;</a><a name="common-const*mosek*objsense*maximize"></a> 
<br/>The problem should be maximized. </li>
<li><tt class="tt">mosek.objsense.minimize</tt><a name="const*mosek*objsense*minimize">&#09;</a><a name="common-const*mosek*objsense*minimize"></a> 
<br/>The problem should be minimized. </li>
<li><tt class="tt">mosek.objsense.undefined</tt><a name="const*mosek*objsense*undefined">&#09;</a><a name="common-const*mosek*objsense*undefined"></a> 
<br/>The objective sense is undefined. </li>
</ul>

</div>

<div>
<h1><a name="251718544">17.29. On/off</a></h1>

<p> <a name="constclass*mosek*onoffkey">&#09;</a><a name="common-constclass*mosek*onoffkey"></a> <a name="idx-176194264">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.onoffkey.off</tt><a name="const*mosek*onoffkey*off">&#09;</a><a name="common-const*mosek*onoffkey*off"></a> 
<br/>Switch the option off. </li>
<li><tt class="tt">mosek.onoffkey.on</tt><a name="const*mosek*onoffkey*on">&#09;</a><a name="common-const*mosek*onoffkey*on"></a> 
<br/>Switch the option on. </li>
</ul>

</div>

<div>
<h1><a name="251720552">17.30. Optimizer types</a></h1>

<p> <a name="constclass*mosek*optimizertype">&#09;</a><a name="common-constclass*mosek*optimizertype"></a> <a name="idx-177555504">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.optimizertype.concurrent</tt><a name="const*mosek*optimizertype*concurrent">&#09;</a><a name="common-const*mosek*optimizertype*concurrent"></a> 
<br/>The optimizer for nonconvex nonlinear problems. </li>
<li><tt class="tt">mosek.optimizertype.conic</tt><a name="const*mosek*optimizertype*conic">&#09;</a><a name="common-const*mosek*optimizertype*conic"></a> 
<br/>The optimizer for problems having conic constraints. </li>
<li><tt class="tt">mosek.optimizertype.dual_simplex</tt><a name="const*mosek*optimizertype*dual-simplex">&#09;</a><a name="common-const*mosek*optimizertype*dual-simplex"></a> 
<br/>The dual simplex optimizer is used. </li>
<li><tt class="tt">mosek.optimizertype.free</tt><a name="const*mosek*optimizertype*free">&#09;</a><a name="common-const*mosek*optimizertype*free"></a> 
<br/>The optimizer is chosen automatically. </li>
<li><tt class="tt">mosek.optimizertype.free_simplex</tt><a name="const*mosek*optimizertype*free-simplex">&#09;</a><a name="common-const*mosek*optimizertype*free-simplex"></a> 
<br/>One of the simplex optimizers is used. </li>
<li><tt class="tt">mosek.optimizertype.intpnt</tt><a name="const*mosek*optimizertype*intpnt">&#09;</a><a name="common-const*mosek*optimizertype*intpnt"></a> 
<br/>The interior-point optimizer is used. </li>
<li><tt class="tt">mosek.optimizertype.mixed_int</tt><a name="const*mosek*optimizertype*mixed-int">&#09;</a><a name="common-const*mosek*optimizertype*mixed-int"></a> 
<br/>The mixed-integer optimizer. </li>
<li><tt class="tt">mosek.optimizertype.nonconvex</tt><a name="const*mosek*optimizertype*nonconvex">&#09;</a><a name="common-const*mosek*optimizertype*nonconvex"></a> 
<br/>The optimizer for nonconvex nonlinear problems. </li>
<li><tt class="tt">mosek.optimizertype.primal_dual_simplex</tt><a name="const*mosek*optimizertype*primal-dual-simplex">&#09;</a><a name="common-const*mosek*optimizertype*primal-dual-simplex"></a> 
<br/>The primal dual simplex optimizer is used. </li>
<li><tt class="tt">mosek.optimizertype.primal_simplex</tt><a name="const*mosek*optimizertype*primal-simplex">&#09;</a><a name="common-const*mosek*optimizertype*primal-simplex"></a> 
<br/>The primal simplex optimizer is used. </li>
<li><tt class="tt">mosek.optimizertype.qcone</tt><a name="const*mosek*optimizertype*qcone">&#09;</a><a name="common-const*mosek*optimizertype*qcone"></a> 
<br/>For internal use only. </li>
</ul>

</div>

<div>
<h1><a name="251728456">17.31. Ordering strategies</a></h1>

<p> <a name="constclass*mosek*orderingtype">&#09;</a><a name="common-constclass*mosek*orderingtype"></a> <a name="idx-177544800">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.orderingtype.appminloc1</tt><a name="const*mosek*orderingtype*appminloc1">&#09;</a><a name="common-const*mosek*orderingtype*appminloc1"></a> 
<br/>Approximate minimum local-fill-in ordering is used. </li>
<li><tt class="tt">mosek.orderingtype.appminloc2</tt><a name="const*mosek*orderingtype*appminloc2">&#09;</a><a name="common-const*mosek*orderingtype*appminloc2"></a> 
<br/>A variant of the approximate minimum local-fill-in ordering is used. </li>
<li><tt class="tt">mosek.orderingtype.free</tt><a name="const*mosek*orderingtype*free">&#09;</a><a name="common-const*mosek*orderingtype*free"></a> 
<br/>The ordering method is chosen automatically. </li>
<li><tt class="tt">mosek.orderingtype.graphpar1</tt><a name="const*mosek*orderingtype*graphpar1">&#09;</a><a name="common-const*mosek*orderingtype*graphpar1"></a> 
<br/>Graph partitioning based ordering. </li>
<li><tt class="tt">mosek.orderingtype.graphpar2</tt><a name="const*mosek*orderingtype*graphpar2">&#09;</a><a name="common-const*mosek*orderingtype*graphpar2"></a> 
<br/>An alternative graph partitioning based ordering. </li>
<li><tt class="tt">mosek.orderingtype.none</tt><a name="const*mosek*orderingtype*none">&#09;</a><a name="common-const*mosek*orderingtype*none"></a> 
<br/>No ordering is used. </li>
</ul>

</div>

<div>
<h1><a name="251733056">17.32. Parameter type</a></h1>

<p> <a name="constclass*mosek*parametertype">&#09;</a><a name="common-constclass*mosek*parametertype"></a> <a name="idx-177544728">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.parametertype.dou_type</tt><a name="const*mosek*parametertype*dou-type">&#09;</a><a name="common-const*mosek*parametertype*dou-type"></a> 
<br/>Is a double parameter. </li>
<li><tt class="tt">mosek.parametertype.int_type</tt><a name="const*mosek*parametertype*int-type">&#09;</a><a name="common-const*mosek*parametertype*int-type"></a> 
<br/>Is an integer parameter. </li>
<li><tt class="tt">mosek.parametertype.invalid_type</tt><a name="const*mosek*parametertype*invalid-type">&#09;</a><a name="common-const*mosek*parametertype*invalid-type"></a> 
<br/>Not a valid parameter. </li>
<li><tt class="tt">mosek.parametertype.str_type</tt><a name="const*mosek*parametertype*str-type">&#09;</a><a name="common-const*mosek*parametertype*str-type"></a> 
<br/>Is a string parameter. </li>
</ul>

</div>

<div>
<h1><a name="251736360">17.33. Presolve method.</a></h1>

<p> <a name="constclass*mosek*presolvemode">&#09;</a><a name="common-constclass*mosek*presolvemode"></a> <a name="idx-177629088">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.presolvemode.free</tt><a name="const*mosek*presolvemode*free">&#09;</a><a name="common-const*mosek*presolvemode*free"></a> 
<br/>It is decided automatically whether to presolve before the problem is optimized. </li>
<li><tt class="tt">mosek.presolvemode.off</tt><a name="const*mosek*presolvemode*off">&#09;</a><a name="common-const*mosek*presolvemode*off"></a> 
<br/>The problem is not presolved before it is optimized. </li>
<li><tt class="tt">mosek.presolvemode.on</tt><a name="const*mosek*presolvemode*on">&#09;</a><a name="common-const*mosek*presolvemode*on"></a> 
<br/>The problem is presolved before it is optimized. </li>
</ul>

</div>

<div>
<h1><a name="251738952">17.34. Problem data items</a></h1>

<p> <a name="constclass*mosek*problemitem">&#09;</a><a name="common-constclass*mosek*problemitem"></a> <a name="idx-177651368">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.problemitem.con</tt><a name="const*mosek*problemitem*con">&#09;</a><a name="common-const*mosek*problemitem*con"></a> 
<br/>Item is a constraint. </li>
<li><tt class="tt">mosek.problemitem.cone</tt><a name="const*mosek*problemitem*cone">&#09;</a><a name="common-const*mosek*problemitem*cone"></a> 
<br/>Item is a cone. </li>
<li><tt class="tt">mosek.problemitem.var</tt><a name="const*mosek*problemitem*var">&#09;</a><a name="common-const*mosek*problemitem*var"></a> 
<br/>Item is a variable. </li>
</ul>

</div>

<div>
<h1><a name="251741608">17.35. Problem types</a></h1>

<p> <a name="constclass*mosek*problemtype">&#09;</a><a name="common-constclass*mosek*problemtype"></a> <a name="idx-177605952">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.problemtype.conic</tt><a name="const*mosek*problemtype*conic">&#09;</a><a name="common-const*mosek*problemtype*conic"></a> 
<br/>A conic optimization. </li>
<li><tt class="tt">mosek.problemtype.geco</tt><a name="const*mosek*problemtype*geco">&#09;</a><a name="common-const*mosek*problemtype*geco"></a> 
<br/>General convex optimization. </li>
<li><tt class="tt">mosek.problemtype.lo</tt><a name="const*mosek*problemtype*lo">&#09;</a><a name="common-const*mosek*problemtype*lo"></a> 
<br/>The problem is a linear optimization problem. </li>
<li><tt class="tt">mosek.problemtype.mixed</tt><a name="const*mosek*problemtype*mixed">&#09;</a><a name="common-const*mosek*problemtype*mixed"></a> 
<br/>General nonlinear constraints and conic constraints. This combination can not be solved by MOSEK. </li>
<li><tt class="tt">mosek.problemtype.qcqo</tt><a name="const*mosek*problemtype*qcqo">&#09;</a><a name="common-const*mosek*problemtype*qcqo"></a> 
<br/>The problem is a quadratically constrained optimization problem. </li>
<li><tt class="tt">mosek.problemtype.qo</tt><a name="const*mosek*problemtype*qo">&#09;</a><a name="common-const*mosek*problemtype*qo"></a> 
<br/>The problem is a quadratic optimization problem. </li>
</ul>

</div>

<div>
<h1><a name="251746208">17.36. Problem status keys</a></h1>

<p> <a name="constclass*mosek*prosta">&#09;</a><a name="common-constclass*mosek*prosta"></a> <a name="idx-176185928">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.prosta.dual_feas</tt><a name="const*mosek*prosta*dual-feas">&#09;</a><a name="common-const*mosek*prosta*dual-feas"></a> 
<br/>The problem is dual feasible. </li>
<li><tt class="tt">mosek.prosta.dual_infeas</tt><a name="const*mosek*prosta*dual-infeas">&#09;</a><a name="common-const*mosek*prosta*dual-infeas"></a> 
<br/>The problem is dual infeasible. </li>
<li><tt class="tt">mosek.prosta.ill_posed</tt><a name="const*mosek*prosta*ill-posed">&#09;</a><a name="common-const*mosek*prosta*ill-posed"></a> 
<br/>The problem is ill-posed. For example, it may be primal and dual feasible but have a positive duality gap. </li>
<li><tt class="tt">mosek.prosta.near_dual_feas</tt><a name="const*mosek*prosta*near-dual-feas">&#09;</a><a name="common-const*mosek*prosta*near-dual-feas"></a> 
<br/>The problem is at least nearly dual feasible. </li>
<li><tt class="tt">mosek.prosta.near_prim_and_dual_feas</tt><a name="const*mosek*prosta*near-prim-and-dual-feas">&#09;</a><a name="common-const*mosek*prosta*near-prim-and-dual-feas"></a> 
<br/>The problem is at least nearly primal and dual feasible. </li>
<li><tt class="tt">mosek.prosta.near_prim_feas</tt><a name="const*mosek*prosta*near-prim-feas">&#09;</a><a name="common-const*mosek*prosta*near-prim-feas"></a> 
<br/>The problem is at least nearly primal feasible. </li>
<li><tt class="tt">mosek.prosta.prim_and_dual_feas</tt><a name="const*mosek*prosta*prim-and-dual-feas">&#09;</a><a name="common-const*mosek*prosta*prim-and-dual-feas"></a> 
<br/>The problem is primal and dual feasible. </li>
<li><tt class="tt">mosek.prosta.prim_and_dual_infeas</tt><a name="const*mosek*prosta*prim-and-dual-infeas">&#09;</a><a name="common-const*mosek*prosta*prim-and-dual-infeas"></a> 
<br/>The problem is primal and dual infeasible. </li>
<li><tt class="tt">mosek.prosta.prim_feas</tt><a name="const*mosek*prosta*prim-feas">&#09;</a><a name="common-const*mosek*prosta*prim-feas"></a> 
<br/>The problem is primal feasible. </li>
<li><tt class="tt">mosek.prosta.prim_infeas</tt><a name="const*mosek*prosta*prim-infeas">&#09;</a><a name="common-const*mosek*prosta*prim-infeas"></a> 
<br/>The problem is primal infeasible. </li>
<li><tt class="tt">mosek.prosta.prim_infeas_or_unbounded</tt><a name="const*mosek*prosta*prim-infeas-or-unbounded">&#09;</a><a name="common-const*mosek*prosta*prim-infeas-or-unbounded"></a> 
<br/>The problem is either primal infeasible or unbounded. This may occur for mixed-integer problems. </li>
<li><tt class="tt">mosek.prosta.unknown</tt><a name="const*mosek*prosta*unknown">&#09;</a><a name="common-const*mosek*prosta*unknown"></a> 
<br/>Unknown problem status. </li>
</ul>

</div>

<div>
<h1><a name="251754760">17.37. Interpretation of quadratic terms in MPS files</a></h1>

<p> <a name="constclass*mosek*qreadtype">&#09;</a><a name="common-constclass*mosek*qreadtype"></a> <a name="idx-177718480">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.qreadtype.add</tt><a name="const*mosek*qreadtype*add">&#09;</a><a name="common-const*mosek*qreadtype*add"></a> 
<br/>All elements in a Q matrix are assumed to belong to the lower triangular part. Duplicate elements in a Q matrix are added together. </li>
<li><tt class="tt">mosek.qreadtype.drop_lower</tt><a name="const*mosek*qreadtype*drop-lower">&#09;</a><a name="common-const*mosek*qreadtype*drop-lower"></a> 
<br/>All elements in the strict lower triangular part of the Q matrices are dropped. </li>
<li><tt class="tt">mosek.qreadtype.drop_upper</tt><a name="const*mosek*qreadtype*drop-upper">&#09;</a><a name="common-const*mosek*qreadtype*drop-upper"></a> 
<br/>All elements in the strict upper triangular part of the Q matrices are dropped. </li>
</ul>

</div>

<div>
<h1><a name="251757416">17.38. Response code type</a></h1>

<p> <a name="constclass*mosek*rescodetype">&#09;</a><a name="common-constclass*mosek*rescodetype"></a> <a name="idx-177735656">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.rescodetype.err</tt><a name="const*mosek*rescodetype*err">&#09;</a><a name="common-const*mosek*rescodetype*err"></a> 
<br/>The response code is an error. </li>
<li><tt class="tt">mosek.rescodetype.ok</tt><a name="const*mosek*rescodetype*ok">&#09;</a><a name="common-const*mosek*rescodetype*ok"></a> 
<br/>The response code is OK. </li>
<li><tt class="tt">mosek.rescodetype.trm</tt><a name="const*mosek*rescodetype*trm">&#09;</a><a name="common-const*mosek*rescodetype*trm"></a> 
<br/>The response code is an optimizer termination status. </li>
<li><tt class="tt">mosek.rescodetype.unk</tt><a name="const*mosek*rescodetype*unk">&#09;</a><a name="common-const*mosek*rescodetype*unk"></a> 
<br/>The response code does not belong to any class. </li>
<li><tt class="tt">mosek.rescodetype.wrn</tt><a name="const*mosek*rescodetype*wrn">&#09;</a><a name="common-const*mosek*rescodetype*wrn"></a> 
<br/>The response code is a warning. </li>
</ul>

</div>

<div>
<h1><a name="251761368">17.39. Scaling type</a></h1>

<p> <a name="constclass*mosek*scalingmethod">&#09;</a><a name="common-constclass*mosek*scalingmethod"></a> <a name="idx-177749312">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.scalingmethod.free</tt><a name="const*mosek*scalingmethod*free">&#09;</a><a name="common-const*mosek*scalingmethod*free"></a> 
<br/>The optimizer chooses the scaling heuristic. </li>
<li><tt class="tt">mosek.scalingmethod.pow2</tt><a name="const*mosek*scalingmethod*pow2">&#09;</a><a name="common-const*mosek*scalingmethod*pow2"></a> 
<br/>Scales only with power of 2 leaving the mantissa untouched. </li>
</ul>

</div>

<div>
<h1><a name="251763312">17.40. Scaling type</a></h1>

<p> <a name="constclass*mosek*scalingtype">&#09;</a><a name="common-constclass*mosek*scalingtype"></a> <a name="idx-177764544">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.scalingtype.aggressive</tt><a name="const*mosek*scalingtype*aggressive">&#09;</a><a name="common-const*mosek*scalingtype*aggressive"></a> 
<br/>A very aggressive scaling is performed. </li>
<li><tt class="tt">mosek.scalingtype.free</tt><a name="const*mosek*scalingtype*free">&#09;</a><a name="common-const*mosek*scalingtype*free"></a> 
<br/>The optimizer chooses the scaling heuristic. </li>
<li><tt class="tt">mosek.scalingtype.moderate</tt><a name="const*mosek*scalingtype*moderate">&#09;</a><a name="common-const*mosek*scalingtype*moderate"></a> 
<br/>A conservative scaling is performed. </li>
<li><tt class="tt">mosek.scalingtype.none</tt><a name="const*mosek*scalingtype*none">&#09;</a><a name="common-const*mosek*scalingtype*none"></a> 
<br/>No scaling is performed. </li>
</ul>

</div>

<div>
<h1><a name="251766616">17.41. Sensitivity types</a></h1>

<p> <a name="constclass*mosek*sensitivitytype">&#09;</a><a name="common-constclass*mosek*sensitivitytype"></a> <a name="idx-177778344">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.sensitivitytype.basis</tt><a name="const*mosek*sensitivitytype*basis">&#09;</a><a name="common-const*mosek*sensitivitytype*basis"></a> 
<br/>Basis sensitivity analysis is performed. </li>
<li><tt class="tt">mosek.sensitivitytype.optimal_partition</tt><a name="const*mosek*sensitivitytype*optimal-partition">&#09;</a><a name="common-const*mosek*sensitivitytype*optimal-partition"></a> 
<br/>Optimal partition sensitivity analysis is performed. </li>
</ul>

</div>

<div>
<h1><a name="251768560">17.42. Degeneracy strategies</a></h1>

<p> <a name="constclass*mosek*simdegen">&#09;</a><a name="common-constclass*mosek*simdegen"></a> <a name="idx-177776904">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.simdegen.aggressive</tt><a name="const*mosek*simdegen*aggressive">&#09;</a><a name="common-const*mosek*simdegen*aggressive"></a> 
<br/>The simplex optimizer should use an aggressive degeneration strategy. </li>
<li><tt class="tt">mosek.simdegen.free</tt><a name="const*mosek*simdegen*free">&#09;</a><a name="common-const*mosek*simdegen*free"></a> 
<br/>The simplex optimizer chooses the degeneration strategy. </li>
<li><tt class="tt">mosek.simdegen.minimum</tt><a name="const*mosek*simdegen*minimum">&#09;</a><a name="common-const*mosek*simdegen*minimum"></a> 
<br/>The simplex optimizer should use a minimum degeneration strategy. </li>
<li><tt class="tt">mosek.simdegen.moderate</tt><a name="const*mosek*simdegen*moderate">&#09;</a><a name="common-const*mosek*simdegen*moderate"></a> 
<br/>The simplex optimizer should use a moderate degeneration strategy. </li>
<li><tt class="tt">mosek.simdegen.none</tt><a name="const*mosek*simdegen*none">&#09;</a><a name="common-const*mosek*simdegen*none"></a> 
<br/>The simplex optimizer should use no degeneration strategy. </li>
</ul>

</div>

<div>
<h1><a name="251772512">17.43. Exploit duplicate columns.</a></h1>

<p> <a name="constclass*mosek*simdupvec">&#09;</a><a name="common-constclass*mosek*simdupvec"></a> <a name="idx-179094088">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.simdupvec.free</tt><a name="const*mosek*simdupvec*free">&#09;</a><a name="common-const*mosek*simdupvec*free"></a> 
<br/>The simplex optimizer can choose freely. </li>
<li><tt class="tt">mosek.simdupvec.off</tt><a name="const*mosek*simdupvec*off">&#09;</a><a name="common-const*mosek*simdupvec*off"></a> 
<br/>Disallow the simplex optimizer to exploit duplicated columns. </li>
<li><tt class="tt">mosek.simdupvec.on</tt><a name="const*mosek*simdupvec*on">&#09;</a><a name="common-const*mosek*simdupvec*on"></a> 
<br/>Allow the simplex optimizer to exploit duplicated columns. </li>
</ul>

</div>

<div>
<h1><a name="251775168">17.44. Hot-start type employed by the simplex optimizer</a></h1>

<p> <a name="constclass*mosek*simhotstart">&#09;</a><a name="common-constclass*mosek*simhotstart"></a> <a name="idx-179113928">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.simhotstart.free</tt><a name="const*mosek*simhotstart*free">&#09;</a><a name="common-const*mosek*simhotstart*free"></a> 
<br/>The simplex optimize chooses the hot-start type. </li>
<li><tt class="tt">mosek.simhotstart.none</tt><a name="const*mosek*simhotstart*none">&#09;</a><a name="common-const*mosek*simhotstart*none"></a> 
<br/>The simplex optimizer performs a coldstart. </li>
<li><tt class="tt">mosek.simhotstart.status_keys</tt><a name="const*mosek*simhotstart*status-keys">&#09;</a><a name="common-const*mosek*simhotstart*status-keys"></a> 
<br/>Only the status keys of the constraints and variables are used to choose the type of hot-start. </li>
</ul>

</div>

<div>
<h1><a name="251777824">17.45. Problem reformulation.</a></h1>

<p> <a name="constclass*mosek*simreform">&#09;</a><a name="common-constclass*mosek*simreform"></a> <a name="idx-179100704">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.simreform.aggressive</tt><a name="const*mosek*simreform*aggressive">&#09;</a><a name="common-const*mosek*simreform*aggressive"></a> 
<br/>The simplex optimizer should use an aggressive reformulation strategy. </li>
<li><tt class="tt">mosek.simreform.free</tt><a name="const*mosek*simreform*free">&#09;</a><a name="common-const*mosek*simreform*free"></a> 
<br/>The simplex optimizer can choose freely. </li>
<li><tt class="tt">mosek.simreform.off</tt><a name="const*mosek*simreform*off">&#09;</a><a name="common-const*mosek*simreform*off"></a> 
<br/>Disallow the simplex optimizer to reformulate the problem. </li>
<li><tt class="tt">mosek.simreform.on</tt><a name="const*mosek*simreform*on">&#09;</a><a name="common-const*mosek*simreform*on"></a> 
<br/>Allow the simplex optimizer to reformulate the problem. </li>
</ul>

</div>

<div>
<h1><a name="251781064">17.46. Simplex selection strategy</a></h1>

<p> <a name="constclass*mosek*simseltype">&#09;</a><a name="common-constclass*mosek*simseltype"></a> <a name="idx-179144392">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.simseltype.ase</tt><a name="const*mosek*simseltype*ase">&#09;</a><a name="common-const*mosek*simseltype*ase"></a> 
<br/>The optimizer uses approximate steepest-edge pricing. </li>
<li><tt class="tt">mosek.simseltype.devex</tt><a name="const*mosek*simseltype*devex">&#09;</a><a name="common-const*mosek*simseltype*devex"></a> 
<br/>The optimizer uses devex steepest-edge pricing (or if it is not available an approximate steep-edge selection). </li>
<li><tt class="tt">mosek.simseltype.free</tt><a name="const*mosek*simseltype*free">&#09;</a><a name="common-const*mosek*simseltype*free"></a> 
<br/>The optimizer chooses the pricing strategy. </li>
<li><tt class="tt">mosek.simseltype.full</tt><a name="const*mosek*simseltype*full">&#09;</a><a name="common-const*mosek*simseltype*full"></a> 
<br/>The optimizer uses full pricing. </li>
<li><tt class="tt">mosek.simseltype.partial</tt><a name="const*mosek*simseltype*partial">&#09;</a><a name="common-const*mosek*simseltype*partial"></a> 
<br/>The optimizer uses a partial selection approach. The approach is usually beneficial if the number of variables is much larger than the number of constraints. </li>
<li><tt class="tt">mosek.simseltype.se</tt><a name="const*mosek*simseltype*se">&#09;</a><a name="common-const*mosek*simseltype*se"></a> 
<br/>The optimizer uses steepest-edge selection (or if it is not available an approximate steep-edge selection). </li>
</ul>

</div>

<div>
<h1><a name="251785728">17.47. Solution items</a></h1>

<p> <a name="constclass*mosek*solitem">&#09;</a><a name="common-constclass*mosek*solitem"></a> <a name="idx-179167312">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.solitem.slc</tt><a name="const*mosek*solitem*slc">&#09;</a><a name="common-const*mosek*solitem*slc"></a> 
<br/>Lagrange multipliers for lower bounds on the constraints. </li>
<li><tt class="tt">mosek.solitem.slx</tt><a name="const*mosek*solitem*slx">&#09;</a><a name="common-const*mosek*solitem*slx"></a> 
<br/>Lagrange multipliers for lower bounds on the variables. </li>
<li><tt class="tt">mosek.solitem.snx</tt><a name="const*mosek*solitem*snx">&#09;</a><a name="common-const*mosek*solitem*snx"></a> 
<br/>Lagrange multipliers corresponding to the conic constraints on the variables. </li>
<li><tt class="tt">mosek.solitem.suc</tt><a name="const*mosek*solitem*suc">&#09;</a><a name="common-const*mosek*solitem*suc"></a> 
<br/>Lagrange multipliers for upper bounds on the constraints. </li>
<li><tt class="tt">mosek.solitem.sux</tt><a name="const*mosek*solitem*sux">&#09;</a><a name="common-const*mosek*solitem*sux"></a> 
<br/>Lagrange multipliers for upper bounds on the variables. </li>
<li><tt class="tt">mosek.solitem.xc</tt><a name="const*mosek*solitem*xc">&#09;</a><a name="common-const*mosek*solitem*xc"></a> 
<br/>Solution for the constraints. </li>
<li><tt class="tt">mosek.solitem.xx</tt><a name="const*mosek*solitem*xx">&#09;</a><a name="common-const*mosek*solitem*xx"></a> 
<br/>Variable solution. </li>
<li><tt class="tt">mosek.solitem.y</tt><a name="const*mosek*solitem*y">&#09;</a><a name="common-const*mosek*solitem*y"></a> 
<br/>Lagrange multipliers for equations. </li>
</ul>

</div>

<div>
<h1><a name="251791624">17.48. Solution status keys</a></h1>

<p> <a name="constclass*mosek*solsta">&#09;</a><a name="common-constclass*mosek*solsta"></a> <a name="idx-179157616">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.solsta.dual_feas</tt><a name="const*mosek*solsta*dual-feas">&#09;</a><a name="common-const*mosek*solsta*dual-feas"></a> 
<br/>The solution is dual feasible. </li>
<li><tt class="tt">mosek.solsta.dual_infeas_cer</tt><a name="const*mosek*solsta*dual-infeas-cer">&#09;</a><a name="common-const*mosek*solsta*dual-infeas-cer"></a> 
<br/>The solution is a certificate of dual infeasibility. </li>
<li><tt class="tt">mosek.solsta.integer_optimal</tt><a name="const*mosek*solsta*integer-optimal">&#09;</a><a name="common-const*mosek*solsta*integer-optimal"></a> 
<br/>The primal solution is integer optimal. </li>
<li><tt class="tt">mosek.solsta.near_dual_feas</tt><a name="const*mosek*solsta*near-dual-feas">&#09;</a><a name="common-const*mosek*solsta*near-dual-feas"></a> 
<br/>The solution is nearly dual feasible. </li>
<li><tt class="tt">mosek.solsta.near_dual_infeas_cer</tt><a name="const*mosek*solsta*near-dual-infeas-cer">&#09;</a><a name="common-const*mosek*solsta*near-dual-infeas-cer"></a> 
<br/>The solution is almost a certificate of dual infeasibility. </li>
<li><tt class="tt">mosek.solsta.near_integer_optimal</tt><a name="const*mosek*solsta*near-integer-optimal">&#09;</a><a name="common-const*mosek*solsta*near-integer-optimal"></a> 
<br/>The primal solution is near integer optimal. </li>
<li><tt class="tt">mosek.solsta.near_optimal</tt><a name="const*mosek*solsta*near-optimal">&#09;</a><a name="common-const*mosek*solsta*near-optimal"></a> 
<br/>The solution is nearly optimal. </li>
<li><tt class="tt">mosek.solsta.near_prim_and_dual_feas</tt><a name="const*mosek*solsta*near-prim-and-dual-feas">&#09;</a><a name="common-const*mosek*solsta*near-prim-and-dual-feas"></a> 
<br/>The solution is nearly both primal and dual feasible. </li>
<li><tt class="tt">mosek.solsta.near_prim_feas</tt><a name="const*mosek*solsta*near-prim-feas">&#09;</a><a name="common-const*mosek*solsta*near-prim-feas"></a> 
<br/>The solution is nearly primal feasible. </li>
<li><tt class="tt">mosek.solsta.near_prim_infeas_cer</tt><a name="const*mosek*solsta*near-prim-infeas-cer">&#09;</a><a name="common-const*mosek*solsta*near-prim-infeas-cer"></a> 
<br/>The solution is almost a certificate of primal infeasibility. </li>
<li><tt class="tt">mosek.solsta.optimal</tt><a name="const*mosek*solsta*optimal">&#09;</a><a name="common-const*mosek*solsta*optimal"></a> 
<br/>The solution is optimal. </li>
<li><tt class="tt">mosek.solsta.prim_and_dual_feas</tt><a name="const*mosek*solsta*prim-and-dual-feas">&#09;</a><a name="common-const*mosek*solsta*prim-and-dual-feas"></a> 
<br/>The solution is both primal and dual feasible. </li>
<li><tt class="tt">mosek.solsta.prim_feas</tt><a name="const*mosek*solsta*prim-feas">&#09;</a><a name="common-const*mosek*solsta*prim-feas"></a> 
<br/>The solution is primal feasible. </li>
<li><tt class="tt">mosek.solsta.prim_infeas_cer</tt><a name="const*mosek*solsta*prim-infeas-cer">&#09;</a><a name="common-const*mosek*solsta*prim-infeas-cer"></a> 
<br/>The solution is a certificate of primal infeasibility. </li>
<li><tt class="tt">mosek.solsta.unknown</tt><a name="const*mosek*solsta*unknown">&#09;</a><a name="common-const*mosek*solsta*unknown"></a> 
<br/>Status of the solution is unknown. </li>
</ul>

</div>

<div>
<h1><a name="251802184">17.49. Solution types</a></h1>

<p> <a name="constclass*mosek*soltype">&#09;</a><a name="common-constclass*mosek*soltype"></a> <a name="idx-179245000">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.soltype.bas</tt><a name="const*mosek*soltype*bas">&#09;</a><a name="common-const*mosek*soltype*bas"></a> 
<br/>The basic solution. </li>
<li><tt class="tt">mosek.soltype.itg</tt><a name="const*mosek*soltype*itg">&#09;</a><a name="common-const*mosek*soltype*itg"></a> 
<br/>The integer solution. </li>
<li><tt class="tt">mosek.soltype.itr</tt><a name="const*mosek*soltype*itr">&#09;</a><a name="common-const*mosek*soltype*itr"></a> 
<br/>The interior solution. </li>
</ul>

</div>

<div>
<h1><a name="251804776">17.50. Solve primal or dual form</a></h1>

<p> <a name="constclass*mosek*solveform">&#09;</a><a name="common-constclass*mosek*solveform"></a> <a name="idx-179250024">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.solveform.dual</tt><a name="const*mosek*solveform*dual">&#09;</a><a name="common-const*mosek*solveform*dual"></a> 
<br/>The optimizer should solve the dual problem. </li>
<li><tt class="tt">mosek.solveform.free</tt><a name="const*mosek*solveform*free">&#09;</a><a name="common-const*mosek*solveform*free"></a> 
<br/>The optimizer is free to solve either the primal or the dual problem. </li>
<li><tt class="tt">mosek.solveform.primal</tt><a name="const*mosek*solveform*primal">&#09;</a><a name="common-const*mosek*solveform*primal"></a> 
<br/>The optimizer should solve the primal problem. </li>
</ul>

</div>

<div>
<h1><a name="251807432">17.51. Status keys</a></h1>

<p> <a name="constclass*mosek*stakey">&#09;</a><a name="common-constclass*mosek*stakey"></a> <a name="idx-179270792">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.stakey.bas</tt><a name="const*mosek*stakey*bas">&#09;</a><a name="common-const*mosek*stakey*bas"></a> 
<br/>The constraint or variable is in the basis. </li>
<li><tt class="tt">mosek.stakey.fix</tt><a name="const*mosek*stakey*fix">&#09;</a><a name="common-const*mosek*stakey*fix"></a> 
<br/>The constraint or variable is fixed. </li>
<li><tt class="tt">mosek.stakey.inf</tt><a name="const*mosek*stakey*inf">&#09;</a><a name="common-const*mosek*stakey*inf"></a> 
<br/>The constraint or variable is infeasible in the bounds. </li>
<li><tt class="tt">mosek.stakey.low</tt><a name="const*mosek*stakey*low">&#09;</a><a name="common-const*mosek*stakey*low"></a> 
<br/>The constraint or variable is at its lower bound. </li>
<li><tt class="tt">mosek.stakey.supbas</tt><a name="const*mosek*stakey*supbas">&#09;</a><a name="common-const*mosek*stakey*supbas"></a> 
<br/>The constraint or variable is super basic. </li>
<li><tt class="tt">mosek.stakey.unk</tt><a name="const*mosek*stakey*unk">&#09;</a><a name="common-const*mosek*stakey*unk"></a> 
<br/>The status for the constraint or variable is unknown. </li>
<li><tt class="tt">mosek.stakey.upr</tt><a name="const*mosek*stakey*upr">&#09;</a><a name="common-const*mosek*stakey*upr"></a> 
<br/>The constraint or variable is at its upper bound. </li>
</ul>

</div>

<div>
<h1><a name="251812680">17.52. Starting point types</a></h1>

<p> <a name="constclass*mosek*startpointtype">&#09;</a><a name="common-constclass*mosek*startpointtype"></a> <a name="idx-179291848">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.startpointtype.constant</tt><a name="const*mosek*startpointtype*constant">&#09;</a><a name="common-const*mosek*startpointtype*constant"></a> 
<br/>The optimizer constructs a starting point by assigning a constant value to all primal and dual variables. This starting point is normally robust. </li>
<li><tt class="tt">mosek.startpointtype.free</tt><a name="const*mosek*startpointtype*free">&#09;</a><a name="common-const*mosek*startpointtype*free"></a> 
<br/>The starting point is chosen automatically. </li>
<li><tt class="tt">mosek.startpointtype.guess</tt><a name="const*mosek*startpointtype*guess">&#09;</a><a name="common-const*mosek*startpointtype*guess"></a> 
<br/>The optimizer guesses a starting point. </li>
<li><tt class="tt">mosek.startpointtype.satisfy_bounds</tt><a name="const*mosek*startpointtype*satisfy-bounds">&#09;</a><a name="common-const*mosek*startpointtype*satisfy-bounds"></a> 
<br/>The starting point is choosen to satisfy all the simple bounds on nonlinear variables. If this starting point is employed, then more care than usual should employed when choosing the bounds on the nonlinear variables. In particular very tight bounds should be avoided. </li>
</ul>

</div>

<div>
<h1><a name="251815984">17.53. Stream types</a></h1>

<p> <a name="constclass*mosek*streamtype">&#09;</a><a name="common-constclass*mosek*streamtype"></a> <a name="idx-179305936">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.streamtype.err</tt><a name="const*mosek*streamtype*err">&#09;</a><a name="common-const*mosek*streamtype*err"></a> 
<br/>Error stream. Error messages are written to this stream. </li>
<li><tt class="tt">mosek.streamtype.log</tt><a name="const*mosek*streamtype*log">&#09;</a><a name="common-const*mosek*streamtype*log"></a> 
<br/>Log stream. Contains the aggregated contents of all other streams. This means that a message written to any other stream will also be written to this stream. </li>
<li><tt class="tt">mosek.streamtype.msg</tt><a name="const*mosek*streamtype*msg">&#09;</a><a name="common-const*mosek*streamtype*msg"></a> 
<br/>Message stream. Log information relating to performance and progress of the optimization is written to this stream. </li>
<li><tt class="tt">mosek.streamtype.wrn</tt><a name="const*mosek*streamtype*wrn">&#09;</a><a name="common-const*mosek*streamtype*wrn"></a> 
<br/>Warning stream. Warning messages are written to this stream. </li>
</ul>

</div>

<div>
<h1><a name="251819288">17.54. Integer values</a></h1>

<p> <a name="constclass*mosek*value">&#09;</a><a name="common-constclass*mosek*value"></a> <a name="idx-179311896">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.value.license_buffer_length</tt><a name="const*mosek*value*license-buffer-length">&#09;</a><a name="common-const*mosek*value*license-buffer-length"></a> 
<br/>The length of a license key buffer. </li>
<li><tt class="tt">mosek.value.max_str_len</tt><a name="const*mosek*value*max-str-len">&#09;</a><a name="common-const*mosek*value*max-str-len"></a> 
<br/>Maximum string length allowed in MOSEK. </li>
</ul>

</div>

<div>
<h1><a name="251821232">17.55. Variable types</a></h1>

<p> <a name="constclass*mosek*variabletype">&#09;</a><a name="common-constclass*mosek*variabletype"></a> <a name="idx-179332232">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.variabletype.type_cont</tt><a name="const*mosek*variabletype*type-cont">&#09;</a><a name="common-const*mosek*variabletype*type-cont"></a> 
<br/>Is a continuous variable. </li>
<li><tt class="tt">mosek.variabletype.type_int</tt><a name="const*mosek*variabletype*type-int">&#09;</a><a name="common-const*mosek*variabletype*type-int"></a> 
<br/>Is an integer variable. </li>
</ul>

</div>

<div>
<h1><a name="251823240">17.56. XML writer output mode</a></h1>

<p> <a name="constclass*mosek*xmlwriteroutputtype">&#09;</a><a name="common-constclass*mosek*xmlwriteroutputtype"></a> <a name="idx-179334032">&#09;</a> </p>

<ul class="itemize">
<li><tt class="tt">mosek.xmlwriteroutputtype.col</tt><a name="const*mosek*xmlwriteroutputtype*col">&#09;</a><a name="common-const*mosek*xmlwriteroutputtype*col"></a> 
<br/>Write in column order. </li>
<li><tt class="tt">mosek.xmlwriteroutputtype.row</tt><a name="const*mosek*xmlwriteroutputtype*row">&#09;</a><a name="common-const*mosek*xmlwriteroutputtype*row"></a> 
<br/>Write in row order. </li>
</ul>

</div>

</div>

<div class="navigationarea">
<table class="navigation" width="100%" cellpadding="0" cellspacing="2">
<tbody><tr>
<td><a href="node018.html" target="_self"><img src="graphics/previous.png" class="navbutton-previous" alt="Previous : 16. Response codes" border="0"/></a></td>
<td><a href="index.html" target="_self"><img src="graphics/up.png" class="navbutton-up" alt="Up:  The MOSEK Python API manual. 
Version 6.0 (Revision 137)." border="0"/></a></td>
<td><a href="node020.html" target="_self"><img src="graphics/next.png" class="navbutton-next" alt="Next:  A. Problem analyzer examples" border="0"/></a></td>
<td align="center" class="navtitle">The MOSEK Python API manual. 
<br/>Version 6.0 (Revision 137).</td>
<td><a href="index.html"><img src="graphics/contents.png" class="navbutton-contents" alt="" border="0"/></a></td>
<td><a href="node028.html"><img src="graphics/index.png" class="navbutton-index" alt="" border="0"/></a></td></tr>
</tbody>
</table>


<table class="trail"><tr>
<td valign="top"><b>Previous : </b><a href="node018.html" target="_self">16. Response codes</a></td>
<td valign="top"><b>Up : </b><a href="index.html" target="_self">The MOSEK Python API manual. 
<br/>Version 6.0 (Revision 137).</a></td>
<td valign="top"><b>Next : </b><a href="node020.html" target="_self">A. Problem analyzer examples</a></td>
<td valign="top"><a href="index.html" target="_self"><b>Contents</b></a></td>
<td valign="top"><a href="node028.html"><b>Index</b></a></td></tr></table>

<hr/>
</div>

<div class="gentime">Tue Apr 10 10:54:31 2012</div>
</body></html>